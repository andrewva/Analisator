Лекция 1. Платформа Microsoft .Net Framework 2.0	4
1.2 Понятия приложения, проекта, решения	5
1.3 Среда разработки Visual Studio .Net	5
1.4 Создание первого проекта	6
1. 5 Компиляция и выполнение программы в среде CLR	9
Лекция 2. Состав языка С#	12
2.1 Основы технологии ООП	12
2.2 Состав языка	13
2.3 Типы данных	14
2.4 Переменные и константы	15
2.5 Организация ввода-вывода данных. Форматирование	17
Лекция 3. Операции языка С#	22
3.1 Некоторые операции С#	22
3.2 Выражения и преобразование типов	26
3.3 Перечень операций	27
3.4 Математические функции языка С#	28
Лекция 4. Операторы языка C#	30
4.1 Операторы следования	30
4.2 Операторы ветвления	30
4.3 Операторы цикла	34
4.4 Операторы безусловного перехода	37
Самостоятельная работа	40
Лекция 5. Методы: основные понятия. Перегрузка методов	41
5.1 Методы: основные понятия	41
5.2 Перегрузка методов	45
Самостоятельная работа	47
Лекция 6. Рекурсивные методы	50
6.1 Прямая рекурсия	50
6.2 Косвенная рекурсия	56
Самостоятельная работа	57
Лекция 7. Обработка исключений	58
7.1 Оператор try	58
7.2 Операторы checked и unchecked	61
Самостоятельная работа	67
Лекция 8. Массивы	71
8.1 Одномерные массивы	71
8.2 Массив как параметр	73
8.3 Массив как объект	73
8.4 Многомерные массивы	75
8.5 Ступенчатые массивы	77
8.6 Оператор foreach и его использование при работе с массивами	78
Самостоятельная работа	83
Лекция 9. Символы и строки	92
9.1 Символы char	92
9.2 Неизменяемые строки string	93
9.3 Изменяемые строки	98
Самостоятельная работа. Работа с командной строкой.	102
Лекция 10. Регулярные выражения	106
10.1 Метасимволы в регулярных выражениях	106
10.2 Поиск в тексте по шаблону	108
10.3 Редактирование текста	110
Самостоятельная работа	111
Практическое задание	111
Лекция 11. Организация С#-системы ввода-вывода	113
11.1 Байтовый поток	113
11.2 Символьный поток	115
11.3 Двоичные потоки	118
11.4 Перенаправление стандартных потоков	120
Самостоятельная работа	123
Лекция 12. Работа с файловой системой	124
12.1.Работа с файловой системой: классы Directory и Filе и классы DirectoryInfo и FileInfo	124
12.2 Класс FileSystemInfo	124
12.3 Класс DirectoryInfo	124
12.4 Класс Directory	127
12.2 Работа с файлами	127
Самостоятельная работа	132
Лекция 13. Классы	133
13.2 Данные: поля и константы	135
13.3 Методы	136
13.5 Свойства	140
13.6 Один класс - один файл	142
Самостоятельная работа	144
13.7. Классы: деструкторы, индексаторы	144
13.8 Операции класса	148
Самостоятельная работа	155
Лекция 14. Нследование классов, иерархия классов	156
14.1 Иерархия и наследование	156
14.2 Наследование конструкторов	158
14.3 Многоуровневая иерархия	162
14.4 Переменные базового класса и производного класса	164
14.5 Виртуальные методы	165
14.6 Абстрактные методы и классы	166
14.7 Запрет наследования	168
Лекция 15. Интерфейсы и структуры	169
15.1. Пользовательские и стандартные интерфейсы	169
15.2 Стандартные интерфейсы .Net	172
15.3 Структуры	174
Самостоятельная работа	177
Лекция 16. Коллекции	180
16.1. Классификация коллекций.	180
16.2 Коллекции общего назначения	180
16.3 Класс Stack	181
16.4 Класс Queue	183
16.5 Класс ArrayList	185
16.6 Класс Hashtable	190
Самостоятельная работа	193
Лекция 17. Организация интерфейса windows-приложений.	193
17.1 Струткура простейшего windows-приложения	193
17.2 Элементы управления на форме	195
17.3 Обработка событий	197
17.4 Работа с элементами управления	198
17.5 Кнопки	199
17.6 Работа с элементами управления в режиме работы приложения	202
17.7 Работа со списками: ListBox, ComboBox, NumericUpDown	203
17.8 Работа с переключателями: RadioButton, CheckBox	207
Лекция 18. Графика в windows-приложениях	211
18.1 Рисование в форме	211
18.2 Работа с изображениями	214
 
Лекция 1. Платформа Microsoft .Net Framework 2.0
Совокупность средств, с помощью которых программы пишутся, корректируются, преобразуются в машинные коды, отлаживаются и запускаются, называют средой разработки или оболочкой. Платформа .Net или .Net Framework– это больше чем просто среда разработки программ, это новое революционное объединение ранее разрозненных технологий компанией Microsoft, которые позволяют разрабатывать разнотипные приложения на различных языках программирования под различные операционные системы.
.NET Framework является надстройкой над операционной системой, в качестве которой может выступать любая версия Windows, Unix и вообще любая ОС (по заверению разработчиков), и состоит из ряда компонентов. Так, .NET Framework включает в себя:
1.	Четыре официальных языка: С#, VB.NET, Managed C++ и JScript .NET. 
2.	Общеязыковую объектно-ориентированную среду выполнения CLR (Common Language Runtime), совместно используемую этими языками для создания приложений. 
3.	Ряд связанных между собой библиотек классов под общим именем FCL (Framework Class Library). 
Основным компонентом платформы .NET Framework является общеязыковая среда выполнения программ CLR. Название среды – "общеязыковая среда выполнения" - говорит само за себя: это исполняющая среда, которая подходит для различных языков программирования. К функциям CLR относятся:
1.	двухшаговая компиляция: преобразование программы, написанной на одном из языков программирования в управляемый код на промежуточном языке (Microsoft Intermediate Language, MSIL, или просто IL), а затем преобразование IL-кода в машинный код конкретного процессора, который выполняется с помощью виртуальной машины или JIT-компилятора (Just In Time compiler - компилирование точно к нужному моменту); 
2.	управление кодом: загрузка и выполнение уже готового IL-кода с помощью JIT-компилятора; 
3.	осуществление доступа к метаданным с целью проверки безопасности кода; 
4.	управление памятью при размещении объектов с помощью сборщика мусора (Garbage Collector); 
5.	обработка исключений и исключительных ситуаций, включая межъязыковые исключения; 
6.	осуществление взаимодействия между управляемым кодом (код, созданный для СLR) и неуправляемым кодом; 
7.	поддержка сервисов для разработки разнотипных приложений. 
Следующим компонентом .Net Framework является FCL – библиотека классов платформы. Эта библиотека разбита на несколько модулей таким образом, что имеется возможность использовать ту или иную ее часть в зависимости от требуемых результатов. Так, например, в одном из модулей содержатся "кирпичики", из которых можно построить Windows-приложения, в другом — "кирпичики", необходимые для организации работы в сети и т.д. 
Часть FCL посвящена описанию базисных типов. Тип — это способ представления данных; определение наиболее фундаментальных из них облегчает совместное использование языков программирования с помощью .NET Framework. Все вместе это называется Common Type System (CTS — единая система типов). 
Кроме того, библиотека FCL включает в себя Common Language Specification (CLS – общая языковая спецификация), которая устанавливает: основные правила языковой интеграции. Спецификация CLS определяет минимальные требования, предъявляемые к языку платформы .NET. Компиляторы, удовлетворяющие этой спецификации, создают объекты, способные взаимодействовать друг с другом. Поэтому любой язык, соответствующий требованиям CLS, может использовать все возможности библиотеки FCL.
Как уже отмечалось, основными языками, предназначенными для платформы .NET Framework, являются С#, VB.NET, Managed C++ и JScript .NET. Для данных языков Microsoft предлагает собственные компиляторы, переводящие программу в IL-код, который выполняется JIT-компилятором среды CLR. Кроме Microsoft, еще несколько компаний и академических организаций создали свои собственные компиляторы, генерирующие код, работающий в CLR. На сегодняшний момент известны компиляторы для Pascal, Cobol, Lisp, Perl, Prolog и т.д. Это означает, что можно написать программу, например, на языке Pascal, а затем, воспользовавшись соответствующим компилятором, создать управляемый код, который будет работать в среде CLR.
1.2 Понятия приложения, проекта, решения
.NET Framework не налагает никаких ограничений на возможные типы создаваемых приложений. Тем не менее, давайте рассмотрим некоторые наиболее часто встречающиеся типы приложений:
1.	Консольные приложения позволяют выполнять вывод на "консоль", то есть в окно командного процессора. 
2.	Windows-приложения, использующие элементы интерфейса Windows, включая формы, кнопки, флажки и т.д. 
3.	Web-приложения представляют собой web-страницы, которые могут просматриваться любым web-браузером. 
4.	Web-сервисы представляют собой распределенные приложения, которые позволяют обмениваться по Интернету практически любыми данными с использованием единого синтаксиса независимо от того, какой язык программирования применялся при создании web-службы и на какой системе она размещена. 
Приложение, находящееся в процессе разработки, называется проектом. Несколько приложений могут быть объединены в решение (solution). 
Удобной средой разработки приложений является Visual Studio .Net.
1.3 Среда разработки Visual Studio .Net
В данном курсе мы будем изучать язык С#. Знакомство с языком начнем с разработки консольных приложений. В качестве среды разработки мы будем использовать Visual Studio .Net (VS).
Можно создавать файлы с исходным кодом на С# с помощью обычного текстового редактора, например, Блокнота, и компилировать их в управляемые модули с помощью компилятора командной строки, который является составной частью .NET Framework. Однако наиболее удобно для этих целей использовать VS, потому что:
1.	VS автоматически выполняет все шаги, необходимые для компиляции исходного кода. 
2.	Текстовый редактор VS настроен для работы с теми языками, которые поддерживаются VS, например С#, поэтому он может интеллектуально обнаруживать ошибки и подсказывать в процессе ввода, какой именно код необходим. 
3.	В состав VS входят программы, позволяющие создавать Windows- и Web-приложения путем простого перетаскивания мышью элементов пользовательского интерфейса. 
4.	Многие типы проектов, создание которых возможно на С#, могут разрабатываться на основе "каркасного" кода, заранее включаемого в программу. Вместо того чтобы каждый раз начинать с нуля, VS позволяет использовать уже имеющиеся файлы с исходным кодом, что уменьшает временные затраты на создание проекта. 
1.4 Создание первого проекта
Для создания проекта следует запустить VS, а затем в главном меню VS выбрать команду File – New - Project . После чего откроется диалоговое меню New Project (см. рис.1.1).
 

Рис. 1.1.  
В поле Project types следует выбрать Visual C#, в поле Templates – Console Application. 
В строчке Name введите имя приложения Hello. Обратите внимание на то, что это же имя появится в строчке Solution Name. Уберите галочку в поле Create directory for Application (пока мы создаем простое приложение, и нам нет необходимости усложнять его структуру).
В строке Location определите положение на диске, куда нужно сохранять ваш проект. И нажмите кнопку OK. Примерный вид экрана изображен на рис 1.2
 

Рис. 1.2.  
В правой верхней части располагается окно управления проектом Solution Explorer. Если оно закрыто, то его можно включить командой View - Solution Explorer. В этом окне перечислены все ресурсы, входящие в проект:
1.	AssemblyInfo.cs – информация о сборке. 
Компилятор в качестве результата своего выполнения создает так называемую сборку – файл с расширением exe или dll, который содержит IL-код и метаданные. 
2.	System, System.Data, System.Xml – ссылки на стандартные библиотеки. 
3.	Program.cs - текст программы на языке C#. 
Замечание. В других версиях VS сюда же включается файл с расширением ico, отвечающий за вид ярлыка приложения. 
В правой нижней части экрана располагается окно свойств Properties. Если оно закрыто, то его можно включить командой View - Properties. В этом окне отображаются важнейшие характеристики выделенного элемента.
Основное пространство экрана занимает окно редактора, в котором располагается текст программы, созданный средой автоматически. Текст представляет собой каркас, в который программист будет добавлять нужный код. При этом зарезервированные слова отображаются синим цветом, комментарии – зеленым, основной текст – черным. 
Текст структурирован. Щелкнув на знак минус, мы скроем блок кода, щелкнув на знаке плюс – откроем.
Откроем папку, содержащую проект, и рассмотрим ее структуру (см. рис.1.3). Файлы, выделенные жирным шрифтом, появятся только после компиляции.
 

Рис. 1.3.  
На данном этапе особый интерес для нас будут представлять следующие файлы:
1.	Hello.sln – основной файл, отвечающий за весь проект. Если необходимо открыть проект для редактирования, то нужно выбрать именно этот файл. Остальные файлы откроются автоматически. 
2.	Program.cs – файл, в котором содержится исходный код - код, написанный на языке С#. Именно с этим файлом мы и будем непосредственно работать. 
3.	Hello.exe – файл, в котором содержатся сгенерированный IL-код и метаданные проекта. Другими словами, этот файл и есть готовое приложение, которое может выполняться на любом компьютере, на котором установлена платформа .Net. 
Теперь рассмотрим сам текст программы.
using System – это директива, которая разрешает использовать имена стандартных классов из пространства имен System непосредственно без указания имени пространства, в котором они были определены. 
Ключевое слово namespace создает для проекта свое собственное пространство имен, которое по умолчанию называется именем проекта. В нашем случае пространство имен называется Hello. Однако программист вправе указать другое имя. Пространство имен ограничивает область применения имен, делая его осмысленным только в рамках данного пространства. Это сделано для того, чтобы можно было давать имена программным объектам, не заботясь о том, что они совпадут с именами в других приложениях. Таким образом, пространства имен позволяют избегать конфликта имен программных объектов, что особенно важно при взаимодействии приложений. 
С# - объектно-ориентированный язык, поэтому написанная на нем программа будет представлять собой совокупность взаимодействующих между собой классов. Автоматически был создан класс с именем Program (в других версиях среды может создаваться класс с именем Class1).
Данный класс содержит только один метод - метод Main(). Метод Main() является точкой входа в программу, т.е. именно с данного метода начнется выполнение приложения. Каждая программа на языке С# должна иметь метод Main ().
Замечание. Технически возможно иметь несколько методов Main() в одной программе, в этом случае потребуется с помощью параметра командной строки сообщить компилятору С#, какой именно метод Main() является точкой входа в программу. 
Метод Main() имеет одну важную особенность. Перед объявлением типа возвращаемого значения void (который означает, что метод не возвращает значение) стоит ключевое слово static, которое означает что метод Main() можно вызывать, не создавая объект типа Program.
Замечание. В некоторых версиях требуется, чтобы перед словом static стояло слово public. 
Добавим в метод следующий код:
Console.WriteLine("Hello!");
Здесь Console имя стандартного класса из пространства имен System. Его метод WriteLine выводит на экран текст, заданный в кавычках
Для запуска программы следует нажать клавишу F5 или выполнить команду Debug-Start Debugging. Если программа выполнена без ошибок, то сообщение выведется в консольное окно, которое мелькнет и быстро закроется. Чтобы просмотреть сообщение в нормальном режиме нужно нажать клавиши Ctrl+F5 или выполнить команду Debug-Start Without Debugging. В нашем случае откроется следующее консольное окно:
 
Если код программы будет содержать ошибки, например, пропущена точка с запятой после команды вывода, то после нажатия клавиши F5 откроется диалоговое окно, в котором выведется сообщение о том, что обнаружена ошибка, и вопрос, продолжать ли работу дальше. Если вы ответите Yes, то будет выполнена предыдущая удачно скомпилированная версия программы. Иначе процесс будет остановлен и управление передано окну списка ошибок Error List. 
Задание. Измените текст кода так, чтобы на экран выводилось сообщение: Ура!!!Сегодня информатика!!! 
1. 5 Компиляция и выполнение программы в среде CLR
В прошлом почти все компиляторы генерировали код для конкретных процессорных архитектур. Все CLR-совместимые компиляторы вместо этого генерируют IL-код, который также называется управляемым модулем, потому что CLR управляет его жизненным циклом и выполнением. Рассмотрим составные части управляемого модуля:
1.	Заголовок PE32 или PE32+: Файл с заголовком в формате PE32 может выполняться в 32- или 64-разрядной ОС, а с заголовком PE32+ только в 64-разрядной ОС. Заголовок показывает тип файла: GUI, CUI или DLL, он также имеет временную метку, показывающую, когда файл был собран. Для модулей, содержащих только IL-код, основной объем информации в РЕ-заголовке игнорируется, Для модулей, содержащих процессорный код, этот заголовок содержит сведения о процессорном коде. 
2.	Заголовок CLR: Содержит информацию, которая превращает этот модуль в управляемый. Заголовок включает нужную версию СLR, некоторые флаги, метку метаданных, точки входа в управляемый модуль (метод Main), месторасположение и размер метаданных модуля, ресурсов и т.д. 
3.	Метаданные - это набор таблиц данных, описывающих то, что определено в модуле. Есть два основных вида таблиц: описывающие типы и члены, определенные в вашем исходном коде, и описывающие типы и члены, на которые имеются ссылки в вашем исходном коде. Метаданные служат многим целям: 
o	устраняют необходимость в заголовочных и библиотечных файлах при компиляции, так как все сведения о типах и членах, на которые есть ссылки, содержатся в файле с IL-кодом, в котором они реализованы. Компиляторы могут читать метаданные прямо из управляемых модулей. 
o	при компиляции IL-кода в машинный код CLR выполняет верификацию (проверку "безопасности" выполнения кода) используя метаданные, например, нужное ли число параметров передается методу, корректны ли их типы, правильно ли используется возвращаемое значение и т.д. 
o	позволяют сборщику мусора отслеживать жизненный цикл объектов и т.д. 
4.	IL-код: управляемый код, создаваемый компилятором при компиляции исходного кода. Во время исполнения CLR компилирует IL-код в команды процессора. 
По умолчанию CLR-совместимые компиляторы генерируют управляемый код, безопасность выполнения которого поддается проверке средой CLR. Вместе с тем возможно разрабатывать неуправляемый или "небезопасный" код, которому разрешается работать непосредственно с адресами памяти и управлять байтами в этих адресах. Эта возможность, обычно полезна при взаимодействии с неуправляемым кодом или при необходимости добиться максимальной производительности при выполнении критически важных алгоритмов. Однако использовать неуправляемый код довольно рискованно, т.к. он способен разрушить существующие структуры данных. 
Чтобы понять принцип выполнения программы в среде CLR рассмотрим небольшой пример:
 

Непосредственно перед исполнением функции Main CLR находит все типы, на которые ссылается ее код. В нашем случае метод Main ссылается на единственный тип — Console, и CLR выделяет единственную внутреннюю структуру WriteLine. 
Когда Main первый раз обращается к WriteLine, вызывается функция JITCompiler (условное название), которая отвечает за компиляцию IL-кода вызываемого метода в собственные команды процессора. Функции JITCompiler известен вызываемый метод и тип, в котором он определен. JITCompiler ищет в метаданных соответствующей сборки IL-код вызываемого метода, затем проверяет и компилирует IL-код в собственные команды процессора, которые сохраняются в динамически выделенном блоке памяти. После этого JITCompiler возвращается к внутренней структуре данных типа и заменяет адрес вызываемого метода адресом блока памяти, содержащего собственные команды процессора. В завершение JITCompiler передает управление коду в этом блоке памяти. Далее управление возвращается в Main, который продолжает работу в обычном порядке.
Затем Main обращается к WriteLine вторично. К этому моменту код WriteLine уже проверен и скомпилирован, так что производится обращение к блоку памяти, минуя вызов JITCompiler. Отработав, метод WriteLine возвращает управление Main. 
Таким образом, за счет такой компиляции производительность теряется только при первом вызове метода. Все последующие обращения к одной и той же структуре выполняются "на полной скорости", без повторной верификация и компиляция.
 
Лекция 2. Состав языка С#
2.1 Основы технологии ООП
В основе языка С# лежит технология объектно-ориентированного программирования (ООП). Все программы на языке С# в большей или меньшей степени являются объектно-ориентированными, поэтому, приступая к написанию даже самой простой программы, нужно познакомиться с основными понятиями в рамках ООП. 
ООП основано на таких понятиях как "класс", "объект", "интерфейс", "инкапсуляция", "наследование", "полиморфизм", "событие".
Объект в программе — это абстракция реального объекта. Объект обладает атрибутами, поведением и индивидуальностью. Атрибуты определяют основные черты объекта, поведение — действия над объектом, индивидуальность — отличие одного объекта от другого с такими же атрибутами по их конкретным значениям. Например: два кота, у обоих есть шерсть, но у одного шерсть черного цвета, у другого — рыжая.
Класс – это множество объектов с одинаковыми атрибутами и поведением, представляемое в языке программирования в виде абстрактного типа данных, который включает в себя члены класса. Рассмотрим некоторые из них:
•	поля – непосредственно данные определенного типа для описания атрибутов; 
•	методы - функции, предназначенные для обработки внутренних данных объекта данного класса; 
•	свойства – это специальные поля данных, с помощью которых, можно управлять поведением объектов данного класса. 
Класс служит образцом для создания объектов или, другими словами, объект является экземпляром класса. 
Важным свойством объекта является его обособленность. Детали реализации объекта, то есть внутренние структуры данных и алгоритмы их обработки, скрыты от пользователя и недоступны для непреднамеренного изменения. Объект используется через его интерфейс - совокупность правил доступа. Скрытие деталей реализации называется инкапсуляцией. 
В ООП данные и методы одного класса могут передаваться другим классам с помощью механизма наследования. Порожденный класс (потомок), наследующий характеристики другого класса, обладает теми же возможностями, что и класс (предок), от которого он порожден. При этом класс-предок остается без изменения, а классу-потомку можно добавлять новые элементы (поля, методы, свойства) или изменять унаследованные методы. Благодаря этому класс-потомок обладает большими возможностями, чем предок. Так, например, все классы (а их очень много и с некоторыми из них мы познакомимся чуть позже) порождены от корневого класса System.Object. 
Классы-потомки некоторого класса являются разновидностями этого класса-предка. (Другими словами, класс-предок является обобщением своих потомков). Это означает, что к объектам классов-потомков можно обращаться с помощью одного и того же имени (но при этом могут выполняться различные действия) — что составляет суть полиморфизма. Чаще всего понятие полиморфизма связывают с механизмом виртуальных методов, который мы рассмотрим позднее.
Программу, построенную на принципах ООП, можно представить как совокупность взаимодействующих объектов. Объект А воздействует на объект Б, и для Б возникает событие, на которое Б отреагирует либо ответным воздействием на А, либо воздействием на объект В. Если А — внешний для системы объект, то Б — интерфейсный объект (отвечающий за взаимодействие системы с внешним миром).
Операционная система Windows — объектно-ориентированная система, в которой определены классы для производства объектов, обеспечивающих, в частности, интерфейс с пользователем. Программа, написанная под Windows, обращается к ней, командуя какой интерфейсный объект на каком именно месте создать — так строится внешний вид (интерфейс) программы. Эти интерфейсные объекты кажутся принадлежащими программе, но на самом деле они — часть Windows: именно она отвечает за их базовый внешний вид и поведение. Поэтому, когда пользователь воздействует на интерфейсный объект программы (нажимает кнопку, выбирает пункт меню и т.п.), для этого объекта происходит событие и Windows переводит это событие в сообщение для программы. При написании программы предусматривается однозначная реакция на это сообщение в виде метода, а в методе вызываются методы других объектов. Т.е. воздействие на интерфейсный объект приводит к появлению в недрах Windows сообщения, которое, приходя в программу, запускает цепочку взаимодействий внутренних для нее объектов. Таким образом, ООП программа фактически встраивается в ОС Windows.
Вспомним нашу первую программу:
class Program	//класс
{ 
 static void Main () //метод класса
  { 
   Console.WriteLine(_Hello!!!_);
  }
}
Программа содержит класс Program с единственным статическим (static) методом Main, что позволяет обращаться к данному методу класса без создания его экземпляра. 
2.2 Состав языка
Алфавит – совокупность допустимых в языке символов. Алфавит языка С# включает:
1.	прописные и строчные латинские буквы и буквы национальных алфавитов (включая кириллицу); 
2.	арабские цифры от 0 до 9, шестнадцатеричные цифры от A до F; 
3.	специальные знаки: " { } , | ; [ ] ( ) + - / % * . \ ' : ? < = > ! & ~ ^ @ _ 
4.	пробельные символы: пробел, символ табуляции, символ перехода на новую строку. 
Из символов алфавита формируются лексемы языка: идентификаторы, ключевые (зарезервированные) слова, знаки операций, константы, разделители (скобки, точка, запятая, пробельные символы).
Границы лексем определяются другими лексемами, такими, как разделители или знаки операций. В свою очередь лексемы входят в состав выражений (выражение задает правило вычисления некоторого значения) и операторов (оператор задает законченное описание некоторого действия). 
Идентификатор – это имя программного элемента: константы, переменной, метки, типа, класса, объекта, метода и т.д. Идентификатор может включать латинские буквы и буквы национальных алфавитов, цифры и символ подчеркивания. Прописные и строчные буквы различаются, например, myname, myName и MyName — три различных имени. Первым символом идентификатора может быть буква или знак подчеркивания, но не цифра. 
Пробелы внутри имен не допускаются. Язык С# не налагает никаких ограничений на длину имен, однако для удобства чтения и записи кода не стоит делать их слишком длинными.
Для улучшения читабельности кода программным элементам следует давать осмысленные имена, составленные в соответствии с определенными правилами. Существует несколько видов нотаций – соглашений о правилах создания имен.
В нотации Pascal каждое слово, входящее в идентификатор, начинается с заглавной буквы. Например:Age, LastName, TimeOfDeath.
Венгерская нотация отличается от предыдущей наличием префикса, соответствующего типу величины. Например: fAge, sName, iTime.
В нотации Camel с заглавной буквы начинается каждое слово идентификатора, кроме первого. Например: age, lastName, timeOfDeath.
Наиболее часто используются нотации Pascal или Camel. Мы будем придерживаться нотации Pascal. Однако в простых программах будут использоваться однобуквенные переменные.
Ключевые слова – это зарезервированные идентификаторы, которые имеют специальное значение для компилятора, например, include, main, int и т.д. Ключевые слова можно использовать только по прямому назначению. С ключевыми словами и их назначением можно ознакомиться в справочной системе С#. 
Замечание. Другие лексемы (знаки операций и константы), а также правила формирования выражений и различные виды операторов будут рассмотрены чуть позже.
2.3 Типы данных
С# является языком со строгой типизацией. В нем необходимо объявлять тип всех создаваемых программных элементов (например, переменных, объектов, окон, кнопок и т. д.), что позволяет компилятору предотвращать возникновение ошибок, следя за тем, чтобы объектам присваивались значения только разрешенного типа. Тип программного элемента сообщает компилятору о его размере (например, тип int показывает, что объект занимает 4 байта) и возможностях (например, кнопка может быть нарисована, нажата и т. д.).
В С# типы делятся на две группы: базовые типы, предлагаемые языком, и типы, определяемые пользователем. Кроме того, типы С# разбиваются на две другие категории: размерные типы (типы по значению) и ссылочные типы. Почти все базовые типы являются размерными типами. Исключение составляют типы Object и String. Все пользовательские типы, кроме структур, являются ссылочными. Дополнительно к упомянутым типам, язык С# поддерживает типы указателей, однако они используются только с неуправляемым кодом. 
Принципиальное различие между размерными и ссылочными типами состоит в способе хранения их значений в памяти. В первом случае фактическое значение хранится в стеке (или как часть большого объекта ссылочного типа). Адрес переменной ссылочного типа тоже хранится в стеке, но сам объект хранится в куче.
Замечание. Стек- это структура, используемая для хранения элементов по принципу первым пришел - последним ушел. В данном случае под стеком понимается область памяти, обслуживаемая процессором, в которой хранятся значения локальных переменных. Куча – область памяти, которая используется для хранения данных, работа с которыми реализуется через указатели и ссылки. Память для размещения таких данных динамически выделяется или освобождается в куче неявно (средствами CLR) или явно (программистом). 
Сборщик мусора уничтожает программные элементы в стеке через некоторое время после того, как закончит существование раздел стека, в котором они объявлены. В типичном случае раздел стека определяется методом. То есть, если в пределах метода объявлена локальная переменная, соответствующий программный элемент будет помечен для сборки мусора по окончании метода. Объект в куче подвергается сборке мусора через некоторое время после того, как уничтожена последняя ссылка на него.
Язык С# предлагает обычный набор базовых типов, каждому из них соответствует тип, поддерживаемый общеязыковой спецификацией .NET (CLS). Соответствие базовых типов языка С# и типов платформы .NET гарантирует, что объекты, созданные в С#, могут быть использованы на равных основаниях с объектами, созданными в любом другом языке, удовлетворяющем требованиям .NET CLS (например, в языке VB.NET).
Тип	Размер в байтах	Тип .NET	Описание 
Базовый тип
object		Object	Может хранить все что угодно, т.к. является всеобщим предком
Логический тип
bool	1	Bolean	true или false
Целые типы
sbyte	1	SByte	Целое со знаком (от -128 до 127)
byte	1	Byte	Целое без знака (от 0 до 255)
short	2	Int16	Целое со знака (от -32768 до 32767)
ushort	2	UInt16	Целое без знака (от 0 до 65535)
int	4	Int32	Целое со знаком (от -2147483648 до 2147483647)
uint	4	UInt	Целое число без знака ( от 0 до 4 294 967 295)
long	8	Int64	Целое со знаком (от -9223372036854775808 до 9223372036854775807) 
ulong	8	UInt64	Целое без знака (от 0 до 0fffffffffffffff)
Вещественные типы
float	4	Single	Число с плавающей точкой двойной точности. Содержит значения приблизительно от -1.5*10-45 до +3.4*1038 c 7 значащими цифрами
double	8	Double	Число с плавающей точкой двойной точности. Содержит значения приблизительно от -5. 0*10-324 до -1.7*10308 c 15-16 значащими цифрами 
Символьный тип
char	2	Сhar	Символы Unicode
Строковый тип
string		String	Строка из Unicode-символов
Финансовый тип
decimal 	12	Decimal 	Число до 28 знаков с фиксированным положением десятичной точки. Обычно используется в финансовых расчетах. Требует суффикса <<m>> или <<М>>
2.4 Переменные и константы
Переменная представляет собой типизированную область памяти. Программист создает переменную, объявляя ее тип и указывая имя. При объявлении переменной ее можно инициализировать (присвоить ей начальное значение), а затем в любой момент ей можно присвоить новое значение, которое заменит собой предыдущее. 
static void Main()
 {
   int i=10;	//объявление и инициализация целочисленной переменной i
   Console.WriteLine(i);		//просмотр значения переменной
   i=100;		//изменение значение переменной
   Console.WriteLine(i);
 }
В языке С# требуется, чтобы переменные были явно проинициализированы до их использования. Проверим этот факт на примере.
static void Main()
 {
   int i;
   Console.WriteLine(i);
 }
При попытке скомпилировать этот пример в списке ошибок будет выведено следующее сообщение: Use of unassigned local variable 'i' (используется неинициализированная локальная переменная i). 
Однако инициализировать каждую переменную необязательно, но необходимо присвоить ей значение до того, как она будет использована.
Константа - это переменная, значение которой нельзя изменить. Константы бывают трех видов: литералы, символические константы и перечисления. 
В операторе присваивания: x=32;
число 32 является литеральной константой. Его значение всегда равно 32 и его нельзя изменить. 
Символические константы именуют постоянные значения. Определение символической константы происходит следующим образом: 
const <тип>  <идентификатор> = <значение>;
Рассмотрим пример:
static void Main()
 {
   const int i=10;	//объявление целочисленной константы i
   Console.WriteLine(i);		//просмотр значения константы
   i=100;		//ошибка
   Console.WriteLine(i);
 }

Задание. Измените программу так, чтобы при объявлении константы не происходила инициализация. Как на это отреагирует компилятор и почему? 
Перечисления (enumerations) являются альтернативой константам. Перечисление - это особый размерный тип, состоящий из набора именованных констант (называемых списком перечисления).
Синтаксис определения перечисления следующий:
[атрибуты] [модификаторы] enum <имя> [ : базовый тип]
{список-перечисления констант(через запятую)};
Замечание. Атрибуты и модификаторы, являются необязательными элементами этой конструкции. Более подробно мы рассмотрим их позже. 
Базовый тип - это тип самого перечисления. Если не указать базовый тип, то по умолчанию будет использован тип int. В качестве базового типа можно выбрать любой целый тип, кроме char. Пример использования перечисления:
class Program
 {
   enum gradus:int
   {
    min=0,
    krit=72,
    max=100,
   }

   static void Main()
   {
    Console.WriteLine("минимальная температура=" + (int) gradus.min);
    Console.WriteLine("критическая температура=" + (int)gradus.krit);
    Console.WriteLine("максимальная температура=" + (int)gradus.max);
   }
}
Замечания 
1.	Запись (int) gradus.min используется для явного преобразования перечисления к целому типу. Если убрать (int), то на экран будет выводиться название констант. 
2.	Символ + в записи "минимальная температура=" + (int) gradus.min при обращении к методу WriteLine означает, что строка "минимальная температура=" будет "склеена" со строковым предствлением значения (int) gradus.min. В результате получится новая строка, которая и будет выведена на экран. 
2.5 Организация ввода-вывода данных. Форматирование
Программа при вводе данных и выводе результатов взаимодействует с внешними устройствами. Совокупность стандартных устройств ввода (клавиатура) и вывода (экран) называется консолью. В языке С# нет операторов ввода и вывода. Вместо них для обмена данными с внешними устройствами используются специальные объекты. В частности, для работы с консолью используется стандартный класс Console, определенный в пространстве имен System.
Вывод данных
В приведенных выше примерах мы уже рассматривали метод WriteLine, реализованный в классе Console, который позволяет организовывать вывод данных на экран. Однако существует несколько способов применения данного метода:
1.	Console.WriteLine(x); //на экран выводится значение идентификатора х 
2.	Console.WriteLine("x=" + x +"y=" + y); /* на экран выводится строка, образованная последовательным слиянием строки "x=", значения x, строки "у=" и значения у */ 
3.	Console.WriteLine("x={0} y={1}", x, y); /* на экран выводится строка, формат которой задан первым аргументом метода, при этом вместо параметра {0} выводится значение x, а вместо {1} – значение y*/ 
Замечание. 
Рассмотрим следующий фрагмент программы:
int i=3, j=4; Console.WriteLine("{0} {1}", i, j); 
При обращении к методу WriteLine через запятую перечисляются три аргумента: "{0} {1}", i, j. Первый аргумент определяет формат выходной строки. Следующие аргументы нумеруются с нуля, так переменная i имеет номер 0, j – номер 1. Значение переменной i будет помещено в выходную строку на место {0}, а значение переменной j –на место {1}. В результате на экран будет выведена строка: 3 4. Если мы обратимся к методу WriteLine следующим образом Console.WriteLine("{0} {1} {2)", j, i, j), то на экран будет выведена строка: 4 3 4. 
Последний вариант использования метода WriteLine является наиболее универсальным, потому что он позволяет не только выводить данные на экран, но и управлять форматом их вывода. Рассмотрим несколько примеров:
1.	Использование управляющих последовательностей: 
Управляющей последовательностью называют определенный символ, предваряемый обратной косой чертой. Данная совокупность символов интерпретируется как одиночный символ и используется для представления кодов символов, не имеющих графического обозначения (например, символа перевода курсора на новую строку) или символов, имеющих специальное обозначение в символьных и строковых константах (например, апостроф). Рассмотрим управляющие символы:
Вид	Наименование
\a	Звуковой сигнал
\b	Возврат на шаг назад
\f	Перевод страницы
\n	Перевод строки
\r	Возврат каретки
\t	Горизонтальная табуляция
\v	Вертикальная табуляция
\\	Обратная косая черта
\'	Апостроф
\"	Кавычки
Пример:
static void Main()
{
Console.WriteLine("Ура!\nСегодня \"Информатика\"!!!");    
}
 
2.	Управление размером поля вывода: 
Первым аргументом WriteLine указывается строка вида {n, m} – где n определяет номер идентификатора из списка аргументов метода WriteLine, а m – количество позиций (размер поля вывода), отводимых под значение данного идентификатора. При этом значение идентификатора выравнивается по правому краю. Если выделенных позиций для размещения значения идентификатора окажется недостаточно, то автоматически добавиться необходимое количество позиций. Пример:
static void Main()
   {
    double x= Math.E;
    Console.WriteLine("E={0,20}", x);
    Console.WriteLine("E={0,10}", x);
    }	 3.	Управление размещением вещественных данных: 
Первым аргументом WriteLine указывается строка вида {n: ##.###} – где n определяет номер идентификатора из списка аргументов метода WriteLine, а ##.### определяет формат вывода вещественного числа. В данном случае под целую часть числа отводится две позиции, под дробную – три. Если выделенных позиций для размещения целой части значения идентификатора окажется недостаточно, то автоматически добавиться необходимое количество позиций. Пример:
static void Main()
   {
    double x= Math.E;
    Console.WriteLine("E={0:##.###}", x);
    Console.WriteLine("E={0:.####}", x);
    }	 Задание. Измените программу так, чтобы число e выводилось на экран с точностью до 6 знаков после запятой.
4.	Управление форматом числовых данных: 
Первым аргументом WriteLine указывается строка вида {n: <спецификатор>m} – где n определяет номер идентификатора из списка аргументов метода WriteLine, <спецификатор> - определяет формат данных, а m – количество позиций для дробной части значения идентификатора. В качестве спецификаторов могут использоваться следующие значения:
Параметр	Формат	Значение
C или c	Денежный. По умолчанию ставит знак р. Изменить его можно с помощь объекта NumberFormatInfo	Задается количество десятичных разрядов. 
D или d	Целочисленный (используется только с целыми числами)	Задается минимальное количество цифр. При необходимости результат дополняется начальными нулями
E или e	Экспоненциальное представление чисел	Задается количество символов после запятой. По умолчанию используется 6
F или f	Представление чисел с фиксированной точкой	Задается количество символов после запятой
G или g	Общий формат (или экспоненциальный, или с фиксированной точкой)	Задается количество символов после запятой. По умолчанию выводится целая часть
N или n	Стандартное форматирование с использованием запятых и пробелов в качестве разделителей между разрядами	Задается количество символов после запятой. По умолчанию – 2, если число целое, то ставятся нули
X или x	Шестнадцатеричный формат	
P или p	Процентный	
Пример:
static void Main()
 {
   Console.WriteLine("C Format:{0,14:C} \t{0:C2}", 12345.678);
   Console.WriteLine("D Format:{0,14:D} \t{0:D6}", 123);
   Console.WriteLine("E Format:{0,14:E} \t{0:E8}", 12345.6789);
   Console.WriteLine("G Format:{0,14:G} \t{0:G10}", 12345.6789);
   Console.WriteLine("N Format:{0,14:N} \t{0:N4}", 12345.6789);
   Console.WriteLine("X Format:{0,14:X} ", 1234);
   Console.WriteLine("P Format:{0,14:P} ", 0.9);    
 }
 
Ввод данных
Для ввода данных обычно используется метод ReadLine, реализованный в классе Console. Особенностью данного метода является то, что в качестве результата он возвращает строку (string). Пример:
static void Main()
 {
   string s = Console.ReadLine();
   Console.WriteLine(s);
 }
Для того чтобы получить числовое значение необходимо воспользоваться преобразованием данных. Пример:
static void Main()
 {
   string s = Console.ReadLine();
   int x = int.Parse(s); //преобразование строки в число
   Console.WriteLine(x);
 }
Или сокращенный вариант:
static void Main()
 {
   //преобразование введенной строки в число
   int x = int.Parse(Console.ReadLine()); 
   Console.WriteLine(x);
 }
Для преобразования строкового представления целого числа в тип int мы используем метод int.Parse(), который реализован для всех числовых типов данных. Таким образом, если нам потребуется преобразовать строковое представление в вещественное, мы можем воспользоваться методом float.Parse() или double.Parse(). В случае, если соответствующее преобразование выполнить невозможно, то выполнение программы прерывается и генерируется исключение System.FormatExeption (входная строка имела неверный формат).
Задание. Измените предыдущий фрагмент программы так, чтобы с клавиатуры вводилось вещественное число, а на экран это число выводилось с точностью до 3 знаков после запятой.
 
Лекция 3. Операции языка С#
В данном разделе мы подробно рассмотрим только часть операций, остальные операции будут вводиться по мере необходимости. 
Замечание. Операции можно классифицировать по количеству операндов на: унарные - воздействуют на один операнд, бинарные - воздействуют на два операнда, тернарные - воздействует на три операнда. Некоторые символы используются для обозначения как унарных, так и бинарных операций. Например, символ "минус" используется как для обозначения унарной операции - арифметического отрицания, так и для обозначения бинарной операции вычитание. Будет ли данный символ обозначать унарную или бинарную операцию, определяется контекстом, в котором он используется.
3.1 Некоторые операции С#
1.	Инкремент (++) и декримент(--). 
Эти операции имеют две формы записи - префиксную, когда операция записывается перед операндом, и постфиксную - операция записывается после операнда. Префиксная операция инкремента (декремента) увеличивает (уменьшает) свой операнд и возвращает измененное значение как результат. Постфиксные версии инкремента и декремента возвращают первоначальное значение операнда, а затем изменяют его.
Рассмотрим эти операции на примере.
static void Main()
{
 int i = 3, j = 4;
 Console.WriteLine("{0} {1}", i, j);
 Console.WriteLine("{0} {1}", ++i, --j);
 Console.WriteLine("{0} {1}", i++, j--);
 Console.WriteLine("{0} {1}", i, j);
}	Результат работы программы: 
3 4
4 3
4 3
5 2
Задание. Выясните, допустимы ли следующие способы записи ++(++i), (i--)--, ++(i--) и т.д. И почему. 
Замечание. Префиксная версия требует существенно меньше действий: она изменяет значение переменной и запоминает результат в ту же переменную. Постфиксная операция должна отдельно сохранить исходное значение, чтобы затем вернуть его как результат. Для сложных типов подобные дополнительные действия могут оказаться трудоемки. Поэтому постфиксную форму имеет смысл использовать только при необходимости.
2.	Операция new. Используется для создания нового объекта. С помощью ее можно создавать как объекты ссылочного типа, так и размерные, например: 
3.	object z=new object();
4.	int i=new int(); // то же самое, что и int i =0;
5.	Отрицание: 
o	Арифметическое отрицание (-) - меняет знак операнда на противоположный. 
o	Логическое отрицание (!) - определяет операцию инверсия для логического типа. 
Рассмотрим эти операции на примере. 
static void Main()
{
 int i = 3, j=-4;
 bool a = true, b=false;
 Console.WriteLine("{0} {1}", -i, -j);
 Console.WriteLine("{0} {1}", !a, !b);
}	Результат работы программы: 
-3   4
False True
Задание. Выясните, допустимы ли следующие способы записи !(-i), -(!a). И почему. 
6.	Явное преобразование типа. Используется для явного преобразования из одного типа в другой. Формат операции: 
7.	(тип) выражение;
Рассмотрим эту операцию на примере.
Static void Main()
{
 int i = -4;
 byte j = 4;
 int a = (int)j;  //преобразование без потери точности
 byte b = (byte)i; //преобразование с потерей точности
 Console.WriteLine("{0} {1}", a, b);
}	Результат работы программы: 
4   252
Задание. Объясните, почему операция (byte)i вместо ожидаемого значения -4 дала нам в качестве результата значение 252.
8.	Умножение (*), деление (/) и деление с остатком (%). Операции умножения и деления применимы для целочисленных и вещественных типов данных. Для других типов эти операции применимы, если для них возможно неявное преобразование к целым или вещественным типам. При этом тип результата равен "наибольшему" из типов операндов, но не менее int. Если оба операнда при делении целочисленные, то и результат тоже целочисленный. 
Рассмотрим эти операции на примере.
static void Main()
{
  int i = 100, j = 15;
  double a = 14.2, b = 3.5;
  Console.WriteLine("{0} {1} {2}", i*j, i/j, i%j);
  Console.WriteLine("{0} {1} {2}", a * b, a / b, a % b);
}	
Результат работы программы:
1500    6    10
49.7     4.05714285714286     0.1999999999999999
Задание. Выясните, чему будет равен результат операции: 
o	1.0/0; 
o	1/0
И объясните, как получился данный результат.
9.	Сложение (+) и вычитание (-). Операции сложения и вычитания применимы для целочисленных и вещественных типов данных. Для других типов эти операции применимы, если для них возможно неявное преобразование к целым или вещественным типам. 
10.	Операции отношения ( <, <=, >, >=, ==, !=). Операции отношения сравнивают значения левого и правого операндов. Результат операции логического типа: true - если значения совпадают, false - в противном случае. Рассмотрим операции на примере: 
static void Main()
 {
  int i = 15, j = 15;
  Console.WriteLine(i<j); //меньше
  Console.WriteLine(i<=j);  //меньше или равно
  Console.WriteLine(i>j);  //больше
  Console.WriteLine(i>=j); //больше или равно
  Console.WriteLine(i==j);  //равно
  Console.WriteLine(i!=j);  //не равно
 }	Результат работы программы: 
False
True
False 
True
True
False
11.	Задание. Выясните, чему равен результат данного выражения: 
o	i<j<k 
o	true<false 
И объясните, как получился данный результат.
12.	Логические операции: И (&&), ИЛИ (||). 
Логические операции применяются к операндам логического типа. 
Результат логической операции И имеет значение истина тогда и только тогда, когда оба операнда принимают значение истина.
Результат логической операции ИЛИ имеет значение истина тогда и только тогда, когда хотя бы один из операндов принимает значение истина.
Рассмотрим операции на примере:
static void Main()
{
  Console.WriteLine("x     y     x и y    x или y");
  Console.WriteLine("{0} {1} {2} {3}", false, false, false&&false, false||false);
  Console.WriteLine("{0} {1} {2} {3}", false, true, false&&true, false||true);
  Console.WriteLine("{0} {1} {2} {3}", true, false, true&&false, true||false);
  Console.WriteLine("{0} {1} {2} {3}", true, true, true&&true, true||true);
}
Результат работы программы:
x	y	x и y	x или y
False	False	False	False
False	True	False	True
True	False	False	True
True	True	True	True
Замечание. Фактически была построена таблица истинности для логических операций И и ИЛИ.
Задание. Объясните, какое значение примет переменная t в данном фрагменте программы: int a=10, b=3; bool t=(a>=b && a!=2*b || a<0); 
13.	Условная операция. 
Формат: (<операнд1>)? <операнд2> : <операнд3>;
Операнд1 - это логическое выражение, которое оценивается с точки зрения его эквивалентности константам true и false. Если результат вычисления операнда1 равен true, то результатом условной операции будет значение операнда2, иначе - операнда3. Фактически условная операция является сокращенной формой условного оператора if, который будет рассмотрен позже.
Пример использования условной операции: 
static void Main()
{
  int x=5; int y=10;
  int max = (x > y) ? x : y;
  Console.WriteLine(max);
}
Задание. Измените программу так, чтобы: 
o	вычислялось наименьшее значение из двух вещественных чисел x и y; 
o	если число двузначное, то на экран выводилось "Да", и "Нет" в противном случае. 
14.	Операции присваивания: =, +=, -= и т.д. 
Формат операции простого присваивания (=):
операнд_2 = операнд_1;
В результате выполнения этой операции вычисляется значение операнда_1, и результат записывается в операнд_2. Возможно связать воедино сразу несколько операторов присваивания, записывая такие цепочки: a=b=c=100. Выражение такого вида выполняется справа налево: результатом выполнения c=100 является число 100, которое затем присваивается переменной b, результатом чего опять является 100, которое присваивается переменной a.
Кроме простой операции присваивания существуют сложные операции присваивания, например, умножение с присваиванием (*=), деление с присваиванием (/=), остаток от деления с присваиванием (%=), сложение с присваиванием (+=), вычитание с присваиванием (-=) и т.д.
В сложных операциях присваивания, например, при сложении с присваиванием, к операнду_2 прибавляется операнд_1, и результат записывается в операнд_2. То есть, выражение с += а является более компактной записью выражения с = с + а . Кроме того, сложные операции присваивания позволяют сгенерировать более эффективный код, за счет того, что в простой операции присваивания для хранения значения правого операнда создается временная переменная, а в сложных операциях присваивания значение правого операнда сразу записывается в левый операнд. 
Задание. Объясните, какие значения примут переменные t и b после выполнения данного фрагмента программы: int a=10, b=3; int t=(a++)-b; int b+=t*a; 
Рассмотренные операции приведены с учетом убывания приоритета. Если в одном выражении соседствуют операции одного приоритета, то операции присваивания и условная операции выполняются справа налево, а остальные наоборот. Если необходимо изменить порядок выполнения операций, то в выражении необходимо поставить круглые скобки.
3.2 Выражения и преобразование типов
Выражение - это синтаксическая единица языка, определяющая способ вычисления некоторого значения. Выражения состоят из операндов, операций и скобок. Каждый операнд является в свою очередь выражением или одним из его частных случаев - константой, переменной или функций. 
Замечание. Список математических функции, реализованных в С# приведен в приложении 2. 
Примеры выражений:
(а + 0.12)/6			
х && у || !z			
(t * Math.Sin(x)-l.05e4)/((2 * k + 2) * (2 * k + 3))
Операции выполняются в соответствии с приоритетами (см. приложение 1). Для изменения порядка выполнения операций используются круглые скобки. Если в одном выражении записано несколько операций одинакового приоритета, то унарные операции, условная операция и операции присваивания выполняются справа налево, остальные - слева направо. Например,
а = b = с означает a=(b=c),
a+b+c означает (а + b) + с.
Задания 
1.	Укажите последовательность выполнения операций в данном выражении: 
(x*x+Math.Sin(x+1))/x-2.
2.	Запишите заданное математическое выражение по правилам языка С#: 
o	 
o	 
o	 
Результат вычисления выражения характеризуется значением и типом. Например, если а и b - переменные целого типа и описаны так:
int а = 2, b = 5;
то выражение а + b имеет значение 7 и тип int.
В выражение могут входить операнды различных типов. Если операнды имеют одинаковый тип, то результат операции будет иметь тот же тип. Если операнды разного типа, то перед вычислениями выполняются преобразования более коротких типов в более длинные для сохранения значимости и точности. Иерархия типов данных приведена в следующей схеме: 
 

Преобразование типов в выражениях происходит неявно (без участия программистов) следующим образом: Если одни из операндов имеет тип, изображенный на более низком уровне, чем другой, то он приводится к типу второго операнда при наличии пути между ними. Если пути нет, то возникает ошибка компиляции (чтобы ее избежать, необходимо воспользоваться операцией явного преобразования). Если путей преобразования несколько, то выбирается наиболее короткий, не содержащий пунктирных линий.
3.3 Перечень операций 
Операции языка С# приведены в порядке убывания приоритетов. Операции с разными приоритетами разделены чертой.
Операция	Описание 
.	Доступ к элементу
x()	Вызов метода или делегата
x[]	Доступ к элементу
x++	Постфиксный инкремент
x--	Постфиксный декремент
new	Выделение памяти
typeof	Получение типа
checked	Проверяемый код
unchecked	Непроверяемый код
+	Унарный плюс
-	Арифметическое отрицание
!	Логическое отрицание
~	Поразрядное отрицание
++x	Префиксный инкремент
--x	Префиксный декремент
(тип) x	Преобразование типа
*	Умножение
/	Деление
%	Остаток от деления
<<	Сдвиг влево
>>	Сдвиг вправо
<	Меньше
>	Больше
<=	Меньше или равно
>=	Больше или равно
is	Проверка принадлежности типу
as	Приведение типа
==	Равно
!=	Не равно
&	Поразрядное И
^	Поразрядное исключающее ИЛИ
|	Поразрядное ИЛИ
&&	Логическое И
||	Логическое ИЛИ
? :	Условная операция
=	Простое присваивание
*=	Умножение с присваиванием
/=	Деление с присваиванием
%=	Остаток от деления с присваиванием
+=	Сложение с присваиванием
-=	Вычитание с присваиванием
<<=	Сдвиг влево с присваиванием
>>=	Сдвиг вправо с присваиванием 
&=	Поразрядное И с присваиванием
^=	Поразрядное исключающее ИЛИ с присваиванием
|=	Поразрядное ИЛИ с присваиванием



3.4 Математические функции языка С#
С# содержит большое количество встроенных математических функций, которые реализованы в классе Math пространства имен System. 
Рассмотрим краткое описание некоторых математических функций, подробнее с ними можно познакомиться в справочной систем VS или технической документации. Особое внимание следует обратить на типы операндов и результатов, т.к. каждая функция может имееть несколько перегруженных версий.
Замечание. Использование нескольких функций с одним и тем же именем, но с различными типами параметров, называется перегрузкой функции. Например, функция Math.Abs(), вычисляющая модуль числа, имеет 7 перегруженных версий: double Math.Abs (double x), float Math.Abs (float x), int Math.Abs(int x), и т.д.
№	Название	Описание
1.	Math.Abs(<выражение>)	Модуль
2.	Math.Ceiling(<выражение>)	Округление для большего целого
3.	Math.Cos(<выражение>)	Косинус
4.	Math.Е	Число е
5.	Math.Exp(<выражение>)	Экспонента
6.	Math.Floor(<выражение>)	Округление до меньшего целого
7.	Math.Log(<выражение>)	Натуральный логарифм
8.	Math.Log10(<выражение>)	Десятичный логарифм
9.	Math.Max(<выражение1>, <выражение2>)	Максимум из двух значений
10.	Math.Min(<выражение1>, <выражение2>)	Минимум из двух значений
11.	Math.PI	Число  12.	Math.Pow(<выражение1>, <выражение2>)	Возведение в степень
13.	Math.Round(<выражение>)	Простое округление
14.	Math.Sign(<выражение>)	Знак числа
15.	Math.Sin(<выражение>)	Синус
16.	Math.Sqrt(<выражение>)	Квадратный корень
17.	Math.Тan(<выражение>)	Тангенс


 
Лекция 4. Операторы языка C#
Программа на языке С# состоит из последовательности операторов, каждый из которых определяет законченное описание некоторого действия и заканчивается точкой с запятой. Все операторы можно разделить на 4 группы: операторы следования, операторы ветвления, операторы цикла и операторы передачи управления.
4.1 Операторы следования
Операторы следования выполняются компилятором в естественном порядке: начиная с первого до последнего. К операторам следования относятся: выражение и составной оператор. 
Любое выражение, завершающееся точкой с запятой, рассматривается как оператор, выполнение которого заключается в вычислении значения выражения или выполнении законченного действия, например, вызова метода. Например:
++i;			//оператор инкремента
x+=y;			//оператор сложение с присваиванием
Console.WriteLine(x); 	//вызов метода
x=Math.Pow(a,b)+a*b;	//вычисление сложного выражения

Частным случаем оператора выражения является пустой оператор ; Он используется тогда, когда по синтаксису оператор требуется, а по смыслу - нет. В этом случае лишний символ ; является пустым оператором и вполне допустим, хотя и не всегда безопасен. Например, случайный символ ; после условия оператора while или if может совершенно поменять работу этого оператора.
Составной оператор или блок представляет собой последовательность операторов, заключенных в фигурные скобки {}. Блок обладает собственной областью видимости: объявленные внутри блока имена доступны только внутри данного блока или блоков, вложенных в него. Составные операторы применяются в случае, когда правила языка предусматривают наличие только одного оператора, а логика программы требует нескольких операторов. Например, тело цикла while должно состоять только из одного оператора. Если заключить несколько операторов в фигурные скобки, то получится блок, который будет рассматриваться компилятором как единый оператор. 
4.2 Операторы ветвления
Операторы ветвления позволяют изменить порядок выполнения операторов в программе. К операторам ветвления относятся условный оператор if и оператор выбора switch.
Условный оператор if
Условный оператор if используется для разветвления процесса обработки данных на два направления. Он может иметь одну из форм: сокращенную или полную. 
Форма сокращенного оператора if: 
if (B)  S;
где В - логическое или арифметическое выражение, истинность которого проверяется; S - оператор: простой или составной.
При выполнении сокращенной формы оператора if сначала вычисляется выражение B, затем проводится анализ его результата: если B истинно, то выполняется оператор S; если B ложно, то оператор S пропускается. Таким образом, с помощью сокращенной формы оператора if можно либо выполнить оператор S, либо пропустить его. 
Форма полного оператора if:
if (B) S1; else S2;
где B - логическое или арифметическое выражение, истинность которого проверяется; S1, S2- оператор: простой или составной.
При выполнении полной формы оператора if сначала вычисляется выражение B, затем анализируется его результат: если B истинно, то выполняется оператор S1, а оператор S2 пропускается; если B ложно, то выполняется оператор S2, а S1 - пропускается. Таким образом, с помощью полной формы оператора if можно выбрать одно из двух альтернативных действий процесса обработки данных.
Рассмотрим несколько примеров записи условного оператора if:
if (a > 0) x=y;		// Сокращенная форма c простым оператором 
if (++i) {x=y; y=2*z;}		// Сокращенная форма c составным оператором
if (a > 0 || b<0) x=y; else  x=z;	// Полная форма с простым оператором
if (i+j-1) { x= 0; y= 1;} else {x=1; y:=0;}	// Полная форма с составными операторами

Рассмотрим пример использования условного оператора.
static void Main()
{
  Console.Write("x= ");
  float x = float.Parse(Console.ReadLine());
  	Console.Write("y=");
  float y = float.Parse(Console.ReadLine());
  if (x < y ) Console.WriteLine("min= "+x);
  else Console.WriteLine("min= "+y);
}
Результат работы программы: 
x	y	min
0	0	0
1	-1	-1
-2	2	-2
Задание. Измените программу так, чтобы вычислялось наибольшее значение из х и у.
Операторы S1 и S2 могут также являться операторами if. Такие операторы называют вложенными. При этом ключевое слово else связывается с ближайшим предыдущим словом if, которое еще не связано ни с одним else. Рассмотрим пример программы, использующей вложенные условные операторы.
Пример: Дана мишень.  
Подсчитать количество очков после выстрела по данной мишени.
static void Main()
{
  int Ball=0;
   Console.Write("x= ");
  float x = float.Parse(Console.ReadLine());
  Console.Write("y= ");
  float y = float.Parse(Console.ReadLine());
  if (x * x + y * y <=1) Ball = 10;	//окружность с радиусом 1
  else  if (x * x + y * y <= 4) Ball = 5;	//окружность с радиусом 2
  Console.WriteLine("Ball= "+ Ball);
}
Результат работы программы: 
x	y	Ball
0	0	10
1	-1	5
-2	2	0
Задание. Измените программу так, чтобы подсчитывалось количество очков для мишени вида  
Оператор выбора switch
Оператор выбора switch предназначен для разветвления процесса вычислений по нескольким направлениям. Формат оператора:
switch ( <выражение> )
{ 
  case <константное_выражение_1>: 
   [<оператор 1>];  <оператор перехода>;
  case <константное_выражение_2>: 
   [<оператор 2>]; <оператор перехода>; 
  ...
  case <константное_выражение_n>: 
   [<оператор n>]; <оператор перехода>;
   [default: <оператор>; ] 
}
Замечание. Выражение, записанное в квадратных скобках, является необязательным элементом в операторе switch. Если оно отсутствует, то может отсутствовать и оператор перехода. 
Выражение, стоящее за ключевым словом switch, должно иметь арифметический, символьный, строковый тип или тип указатель. Все константные выражения должны иметь разные значения, но их тип должен совпадать с типом выражения, стоящим после switch или приводиться к нему. Ключевое слово case и расположенное после него константное выражение называют также меткой case.
Выполнение оператора начинается с вычисления выражения, расположенного за ключевым словом switch. Полученный результат сравнивается с меткой case. Если результат выражения соответствует метке case, то выполняется оператор, стоящий после этой метки, за которым обязательно должен следовать оператор перехода: break, goto и т.д. При использовании оператора break происходит выход из switch и управление передается оператору, следующему за switch. Если же используется оператор goto, то управление передается оператору, помеченному меткой, стоящей после goto. 
Пример. По заданному виду арифметической операции (сложение, вычитание, умножение и деление) и двум операндам, вывести на экран результат применения данной операции к операндам.
static void Main()
{
  Console.Write("OPER= ");
  char oper=char.Parse(Console.ReadLine());
  bool ok=true;
  Console.Write("A= ");
  int a=int.Parse(Console.ReadLine());
  Console.Write("B= ");            
  int b=int.Parse(Console.ReadLine());
  float res=0;
  switch (oper)
  {
    case '+': res = a + b; break;	//1
    case '-': res = a - b; break;
    case '*': res = a * b; break;
    case ':': if (b != 0)
    { 
      res = (float)a / b; break;
    }
    else goto default;
    default: ok = false; break;        
  }
  if (ok) Console.WriteLine("{0} {1} {2} = {3}", a, oper, b, res);
  else Console.WriteLine("error");
}
Результат выполнения программы: 
oper	x	y	rez
+	4	5	9
:	4	0	error
%	4	3	error
Задания. 
1.	Замените в строке 1 оператор break, на оператор goto case '-' и посмотрите, что произойдет, если в качестве операции ввести +. 
2.	В условном операторе if уберите ветку else и посмотрите, что произойдет. 
Если необходимо, чтобы для разных меток выполнялось одно и тоже действие, то метки перечисляются через двоеточие. Например:
switch (oper)
{
  case '+': res = a + b; break;	
  case '-': res = a - b; break;
  case '*': res = a * b; break;
  case '/': case ':': if (b != 0)  // перечисление меток
  {
    res = (float)a / b; break;
  }
  else goto default;
  default: ok = false; break;
}
4.3 Операторы цикла
Операторы цикла используются для организации многократно повторяющихся вычислений. К операторам цикла относятся: цикл с предусловием while, цикл с постусловием do while, цикл с параметром for и цикл перебора foreach.. 
Цикл с предусловием while
Оператор цикла while организует выполнение одного оператора (простого или составного) неизвестное заранее число раз. Формат цикла while: 
while (B) S;
где B - выражение, истинность которого проверяется (условие завершения цикла); S - тело цикла - оператор (простой или составной).
Перед каждым выполнением тела цикла анализируется значение выражения В: если оно истинно, то выполняется тело цикла, и управление передается на повторную проверку условия В; если значение В ложно - цикл завершается и управление передается на оператор, следующий за оператором S. 
Если результат выражения B окажется ложным при первой проверке, то тело цикла не выполнится ни разу. Отметим, что если условие B во время работы цикла не будет изменяться, то возможна ситуация зацикливания, то есть невозможность выхода из цикла. Поэтому внутри тела должны находиться операторы, приводящие к изменению значения выражения B так, чтобы цикл мог корректно завершиться.
В качестве иллюстрации выполнения цикла while рассмотрим программу вывода на экран целых чисел из интервала от 1 до n.
static void Main()
{
  Console.Write("N= ");
  int n=int.Parse(Console.ReadLine());
  int i = 1;
  while (i <= n)           //пока i меньше или равно n
  Console.Write(" "+ i++ ); //выводим i на экран, затем увеличиваем его на 1             
}
Результаты работы программы: 
n               ответ
10               1  2  3  4  5  6  7  8  9  10
Задание. Измените программу так, чтобы: 
1.	числа выводились в обратном порядке; 
2.	выводились только нечетные числа. 
Цикл с постусловием do while
Оператор цикла do while также организует выполнение одного оператора (простого или составного) неизвестное заранее число раз. Однако в отличие от цикла while условие завершения цикла проверяется после выполнения тела цикла. Формат цикла do while: 
do  S while (B);
где В - выражение, истинность которого проверяется (условие завершения цикла); S - тело цикла - оператор (простой или блок).
Сначала выполняется оператор S, а затем анализируется значение выражения В: если оно истинно, то управление передается оператору S, если ложно - цикл завершается, и управление передается на оператор, следующий за условием B. Так как условие В проверяется после выполнения тела цикла, то в любом случае тело цикла выполнится хотя бы один раз.
В операторе do while, так же как и в операторе while, возможна ситуация зацикливания в случае, если условие В всегда будет оставаться истинным. 
В качестве иллюстрации выполнения цикла do while рассмотрим программу вывода на экран целых чисел из интервала от 1 до n.
static void Main()
{
  Console.Write("N= ");
  int n=int.Parse(Console.ReadLine());
  int i = 1;
  do
    Console.Write(" " + i++); 
    //выводим i на экран, затем увеличиваем его на 1
  while (i <= n); //пока i меньше или равно n
}
Задание. Измените программу так, чтобы: 
1.	1. числа выводились в обратном порядке; 
2.	2. выводились только четные числа. 
Цикл с параметром for
Цикл с параметром имеет следующую структуру:
for ( <инициализация>; <выражение>; <модификация>) <оператор>;
Инициализация используется для объявления и/или присвоения начальных значений величинам, используемым в цикле в качестве параметров (счетчиков). В этой части можно записать несколько операторов, разделенных запятой. Областью действия переменных, объявленных в части инициализации цикла, является цикл и вложенные блоки. Инициализация выполняется один раз в начале исполнения цикла. 
Выражение определяет условие выполнения цикла: если его результат истинен, цикл выполняется. Истинность выражения проверяется перед каждым выполнением тела цикла, таким образом, цикл с параметром реализован как цикл с предусловием. В блоке выражение через запятую можно записать несколько логических выражений, тогда запятая равносильна операции логическое И (&&). 
Модификация выполняется после каждой итерации цикла и служит обычно для изменения параметров цикла. В части модификация можно записать несколько операторов через запятую. 
Оператор (простой или составной) представляет собой тело цикла. 
Любая из частей оператора for (инициализация, выражение, модификация, оператор) может отсутствовать, но точку с запятой, определяющую позицию пропускаемой части, надо оставить.
static void Main()
{
Console.Write("N= ");
int n=int.Parse(Console.ReadLine());
for (int i=1; i<=n;)     //блок модификации пустой     
Console.Write(" " + i++); 
}

Задание. Измените программу так, чтобы: 
1.	числа выводились в обратном порядке; 
2.	выводились квадраты чисел. 
Замечание. Цикл перебора foreach будет рассмотрен позже.

Вложенные циклы
Циклы могут быть простые или вложенные (кратные, циклы в цикле). Вложенными могут быть циклы любых типов: while, do while, for. Каждый внутренний цикл должен быть полностью вложен во все внешние циклы. "Пересечения" циклов не допускаются. 
Рассмотрим пример использования вложенных циклов, который позволит вывести на экран числа следующим образом: 
2	2	2	2	2
2	2	2	2	2
2	2	2	2	2
2	2	2	2	2
static void Main()
{
  for (int i = 1; i <= 4; ++i, Console.WriteLine())     //1
  for (int j=1; j<=5; ++j)
  Console.Write(" " + 2); 
}
Замечание. В строке 1 в блоке модификации содержится два оператора ++i и Console.WriteLine(). В данном случае после каждого увеличения параметра i на 1 курсор будет переводиться на новую строку. 
Задание. Измените программу так, чтобы таблица содержала n и m столбцов (значения n и m вводятся с клавиатуры). 
4.4 Операторы безусловного перехода
В С# есть несколько операторов, изменяющих естественный порядок выполнения команд: оператор безусловного перехода goto, оператор выхода break, оператор перехода к следующей итерации цикла continue, оператор возврата из метода return и оператор генерации исключения throw.
Оператор безусловного перехода goto
Оператор безусловного перехода goto имеет формат:
goto <метка>;
В теле той же функции должна присутствовать ровно одна конструкция вида:
<метка>: <оператор>;
Оператор goto передает управление на помеченный меткой оператор. Рассмотрим пример использования оператора goto:
static void Main()
{      
  float x;
  metka: Console.WriteLine("x="); //оператор, помеченный меткой 
  x = float.Parse(Console.ReadLine());
  if (x!=0) Console.WriteLine("y({0})={1}", x, 1 / x ); 
  else
  {
    Console.WriteLine("функция не определена");
    goto metka; // передача управление метке
  }	
}
Следует учитывать, что использование оператора goto затрудняет чтение больших по объему программ, поэтому использовать метки нужно только в крайних случаях, например, в операторе switch.
Оператор выхода break
Оператор break используется внутри операторов ветвления и цикла для обеспечения перехода в точку программы, находящуюся непосредственно за оператором, внутри которого находится break. 
Мы уже применяли оператор break для выхода из оператора switch, аналогичным образом он может применяться для выхода из других операторов.
Оператор перехода к следующей итерации цикла continue
Оператор перехода к следующей итерации цикла continue пропускает все операторы, оставшиеся до конца тела цикла, и передает управление на начало следующей итерации (повторение тела цикла). Рассмотрим оператор continue на примере.
static void Main()
{
  Console.WriteLine("n=");            
  int n = int.Parse(Console.ReadLine());
  for (int i = 1; i <= n; i++)
  {
    if (i % 2 == 0) continue;
    Console.Write(" " + i);
  }
}

Замечание. Операторы return и throw будут рассмотрены позже.
Практикум
1.	Дана точка на плоскости с координатами (х, у). Составить программу, которая выдает одно из сообщений "Да", "Нет", "На границе" в зависимости от того, лежит ли точка внутри заштрихованной области, вне заштрихованной области или на ее границе. 
Пример:
1.  
using System;
namespace Hello
{
  class Program
  {
     static void Main()
     {
     Console.Write("x=");            
     float x = float.Parse(Console.ReadLine());
     Console.Write("y=");
     float y = float.Parse(Console.ReadLine());
     if (x * x + y * y < 9 && y > 0)
       Console.WriteLine("внутри");
     else if (x * x + y * y > 9 || y < 0)
       Console.WriteLine("вне");
       else Console.WriteLine("на границе");
      }
  }
}
2. Дан порядковый номер дня недели, вывести на экран его название. 
Пример:
using System;
namespace Hello
{
  class Program
  {
    static void Main()
    {
      Console.Write("n=");            
      byte n = byte.Parse(Console.ReadLine());
      switch (n)
      {
        case 1: Console.WriteLine("понедельник"); break;
        case 2: Console.WriteLine("вторник"); break;
        case 3: Console.WriteLine("среда"); break;
        case 4: Console.WriteLine("четверг"); break;
        case 5: Console.WriteLine("пятница"); break;
        case 6: Console.WriteLine("суббота"); break;
        case 7: Console.WriteLine("воскресенье"); break;
        default: Console.WriteLine("ВЫ ОШИБЛИСЬ"); break;
      }
    }
  }
}
3. Вывести на экран, используя операторы цикла while, do while и for,целые числа 1, 3, 5, …, 21 в строчку через пробел: 
Пример:
using System;
namespace Hello
{
  class Program
  {
      
    static void Main()
    {
      Console.Write("n=");            
      byte n = byte.Parse(Console.ReadLine());

      Console.Write("while: ");
      int i = 1;           
      while (i <= n)
      {
        Console.Write(" " + i);
        i += 2;
      }

      Console.Write("do while: ");
      i = 1;
      do
{
Console.Write(" " + i);
i += 2;
}
while (i <= n);

Console.Write("For: ");
for (i = 1; i<=n; i+=2)
      {
        Console.Write(" " + i);
      }
    }
  }
}
4. Вывести на экран числа следующим образом: 
Пример:
1)	1	1	1	1	1	1
	2	2	2	2	2	2
	3	3	3	3	3	3
	4	4	4	4	4	4
						
using System;
namespace Hello
{
  class Program
  {
    static void Main()
    {
      for (int i = 1; i<=4; ++i, Console.WriteLine())
      {
        for(int j=1; j<=6; ++j)
        Console.Write(" " + i);
      }
    }
  }
}
Самостоятельная работа 
Задача 1. Дана шахматная доска размером n×n клеток. Верхняя левая клетка доски черная и имеет номер (1, 1). Например, для n=4 шахматная таблица выглядит следующим образом:
	1	2	3	4
1				
2				
3				
4				
1.	для заданного значения n определить количество черных ячеек шахматной доски; 
2.	по номеру ячейки (k, m) определить ее цвет; 
3.	определить, являются ли ячейки с номерами (k1, m1) и (k2, m2) одного цвета; 
4.	определить, находится ли фигура, стоящая в ячейке с номером (k1, m1), под ударом второй фигуры, стоящей в ячейке с номером (k2, m2), при условии, что ход второй фигуры и ей является: 
o	пешка; 
o	слон; 
o	ладья; 
o	ферзь; 
o	конь.
Задача 2. Задана дата в формате <день>.<месяц>.<год>. Определить:
1.	сколько дней прошло с начала года; 
2.	сколько дней осталось до конца года; 
3.	дату предыдущего дня; 
4.	дату следующего дня. 
Задача 3. Натуральное число из n цифр является числом Армстронга, если сумма его цифр, возведенных в n-ную степень, равна самому числу. Например, 153=13+53+33. Найти все трехзначные числа Армстронга.
Задача 4. Стороны прямоугольника заданы натуральными числами n и m. Найти количество квадратов (стороны которых выражены натуральными числами), на которые можно разрезать данный прямоугольник, если от него каждый раз отрезать квадрат: наименьшей площади; наибольшей площади.
 
Лекция 5. Методы: основные понятия. Перегрузка методов
5.1 Методы: основные понятия
Метод – это функциональный элемент класса, который реализует вычисления или другие действия, выполняемые классом или его экземпляром (объектом). Метод представляет собой законченный фрагмент кода, к которому можно обратиться по имени. Он описывается один раз, а вызываться может многократно. Совокупность методов класса определяет, что конкретно может делать класс. Например, стандартный класс Math содержит методы, которые позволяют вычислять значения математический функций. 
Синтаксис метода:
[атрибуты] [спецификторы] тип_возвращаемого_результаты  имя_метода ([список_параметров])
{
тело_метода;
return значение
}
где:
1.	Атрибуты и спецификторы являются необязательными элементами синтаксиса описания метода. На данном этапе атрибуты нами использоваться не будут, а из всех спецификаторов мы в обязательном порядке будем использовать спецификатор static, который позволит обращаться к методу класса без создания его экземпляра. 
Замечание. Остальные спецификаторы мы рассмотрим в разделе "классы".
2.	Тип_возвращаемого_результата определяет тип значения, возвращаемого методом. Это может быть любой тип, включая типы классов, создаваемые программистом. Если метод не возвращает никакого значения, необходимо указать тип void (в этом случае в теле метода отсутсвует оператор return). 
3.	Имя_метода – идентификатор, заданный программистом с учетом требований, накладываемыми на идентификаторы в С#, отличный от тех, которые уже использованы для других элементов программы в пределах текущей области видимости. 
4.	Список_параметров представляет собой последовательность пар, состоящих из типа данных и идентификатора, разделенных запятыми. Параметры — это переменные или константы, которые получают значения, передаваемые методу при вызове. Если метод не имеет параметров, то список_параметров остается пустым. 
5.	Значение определяет значение, возвращаемое методом. Тип значения должен соответствовать типу_возвращаемого_результата или приводится к нему. 
Рассмотрим простейший пример метода:
class Program
  {
     static void Func()	//дополнительный метод
     {
        Console.Write("x= ");
        double x=double.Parse(Console.ReadLine());
        double y = 1 / x;
        Console.WriteLine("y({0})={1}", x,y );
      }

      static void Main()	//точка входа в программу
      {
        Func();	//первый вызов метода Func
        Func();	//второй вызов метода Func
       }
   }

В даном примере в метод Func не передаются никакие значения, поэтому список параметров пуст. Кроме того метод ничего не возвращает, поэтому тип возвращаемого значения void. В основном методе Main мы вызвали метод Func два раза. Если будет необходимо, то данный метод можно будет вызвать еще столько раз, сколько потребуется для решения задачи. 
Задания. 
1.	Добавьте в метод Main третий вызов метода Func. 
2.	2. Преобразуйте программу так, чтобы метод Func вызывался n раз. 
Изменим исходный пример так, чтобы в него передавалось значение х, а сам метод возвращал значение y.
class Program
  {
     static double Func( double x) //дополнительный метод
     {
       return 1 / x; //Возвращаемое значение
     }

     static void Main()	//точка входа в программу
     {
       Console.Write("a=");
       double a=double.Parse(Console.ReadLine());
       Console.Write("b=");
       double b=double.Parse(Console.ReadLine());
       for (double x = a; x <= b; x += 0.5)
        {
           double y = Func(x); //вызов метода Func
           Console.WriteLine("y({0:f1})={1:f2}", x, y); 
        }
   }

В данном примере метод Func содержит параметр х, тип которого double. Для того, чтобы метод Func возвращал в вызывающий его метод Main значение выражения 1/x (тип которого double), перед именем метода указывается тип возвращаемого значения – double, а в теле метода используется оператор передачи управления – return. Оператор return завершает выполнение метода и передает управление в точку его вызова.
Задания. Преобразуйте программу так, чтобы метод Func возвращал значение выражения: 
1.	x2; 
2.	 
Рассмотрим другой пример:
class Program
    {
        static int Func( int x, int y)	//строка 1
        {
            return (x>y)? x:y;
        }

        static void Main()
        {
            Console.Write("a=");
            int a = int.Parse(Console.ReadLine());
            Console.Write("b=");
            int b = int.Parse(Console.ReadLine());
            Console.Write("c=");
            int c = int.Parse(Console.ReadLine());
            int max = Func(Func(a, b), c);	//строка 2 - вызовы метода Func
            Console.WriteLine("max({0}, {1}, {2})={3}", a, b, c, max);     
        }
      }

В данном примере метод Func имеет два целочисленных параметра – x, y, а в качестве результата метод возвращает наибольшее из них. На этапе описания метода (строка 1) указываются формальные параметры, на этапе вызова (строка 2) в метод передаются фактические параметры, которые по количеству и по типу совпадают с формальными параметрами. Если количество фактических и формальных параметров будет различным, то компилятор выдаст соответствующее сообщение об ошибке. Если параметры будут отличаться типами, то компилятор попытается выполнить неявное преобразование типов. Если неявное преобразование невозможно, то также будет сгенерирована ошибка. 
Обратите внимание на то, что при вызове метода Func использовалось вложение одного вызова в другой.
Задание. Преобразуйте программу так, чтобы с помощью метода Func можно было найти наибольшее значение из четырех чисел: a, b, c, d. Метод Func при этом не изменять.
В общем случае параметры используются для обмена информацией между вызывающим и вызываемым методами. В С# для обмена предусмотрено четыре типа параметров: параметры-значения, параметры-ссылки, выходные параметры, параметры-массивы.
При передаче параметра по значению метод получает копии параметров, и операторы метода работают с этими копиями. Доступа к исходным значениям параметров у метода нет, а, следовательно, нет и возможности их изменить.
Замечание. Все примеры, рассмотренные ранее, использовали передачу данных по значению.
Рассмотрим небольшой пример:
class Program
  {
    static void Func(int x)
     {
        x += 10;	// изменили значение параметра 
        Console.WriteLine("In Func: " + x);
      }

     static void Main()
      {
         int a=10;
         Console.WriteLine("In Main: "+ a);
         Func(a);
        Console.WriteLine("In Main: " + a);
      }
  }

Результат работы программы:
In Main: 10	
In Func: 20
In Main: 10
В данном примере значение формального параметра х было изменено в методе Func, но эти изменения не отразились на фактическом параметре а метода Main.
При передаче параметров по ссылке метод получает копии адресов параметров, что позволяет осуществлять доступ к ячейкам памяти по этим адресам и изменять исходные значения параметров. Для того чтобы параметр передавался по ссылке, необходимо при описании метода перед формальным параметром и при вызове метода перед соответствующим фактическим параметром поставить служебное слово ref. 
class Program
  {
     static void Func(int x, ref int y)
     {
       x += 10; y += 10;  //изменение параметров
       Console.WriteLine("In Func: {0}, {1}", x, y);
      }

     static void Main()
     {
        int a=10, b=10;  // строка 1
        Console.WriteLine("In Main: {0}, {1}", a, b);
        Func(a, ref b);
        Console.WriteLine("In Main: {0}, {1}", a, b);
      }
  }

Результат работы программы:
In Main: 10  10	
In Func: 20  20
In Main: 10  20
В данном примере в методе Func были изменены значения формальных параметров х и y. Эти изменения не отразились на фактическом параметре а, т.к. он передавался по значению, но значение b было изменено, т.к. он передавался по ссылке. 
Передача параметра по ссылке требует, чтобы аргумент был инициализирован до вызова метода (см. строку 1). Если в этой строке не проводить инициализацию переменных, то компилятор выдаст сообщение об ошибке. 
Однако в некоторых случаях бывает невозможно инициализировать параметр до вызова метода. Тогда параметр следует передавать как выходной, используя спецификатор out.
class Program
  {
   static void Func(int x, out int y)
     {
       x += 10; y = 10;   // определение значения выходного параметра y
       Console.WriteLine("In Func: {0}, {1}", x, y);
      }

      static void Main()
      {
        int a=10, b;
        Console.WriteLine("In Main: {0}", a);
        Func(a, out b);
        Console.WriteLine("In Main: {0}, {1}", a, b);
      }
  }

Результат работы программы:
In Main: 10 	
In Func: 20  10
In Main: 10  10
В данном примере в методе Func формальный параметр y и соответствующий ему фактический параметр b метода Main были помечены спецификатором out. Поэтому значение b до вызова метода Func можно было не определять, но изменение параметра y отразились на изменении значения параметра b.
Замечание. Параметры-массивы будут рассмотрены позже.
5.2 Перегрузка методов
Иногда бывает удобно, чтобы методы, реализующие один и тот же алгоритм для различных типов данных, имели одно и то же имя. Использование нескольких методов с одним и тем же именем, но различными типами и количеством параметров называется перегрузкой методов. Компилятор определяет, какой именно метод требуется вызвать, по типу и количеству фактических параметров. 
Рассмотрим следующий пример:
class Program
  {
     static int max(int a)	//первая версия метода max
      {
         int b = 0;
         while (a > 0)
         {
            if (a % 10 > b) b = a % 10;
            a /= 10;
          }
         return b;
      }

      static int max(int a, int b) //вторая версия метода max
       {
         if (a > b) return a;
         else return b;
       }
        
      static int max(int a, int b, int c) //третья версия метода max
      {
         if (a > b && a > c) return a;
         else if (b > c) return b;
         else return c;
      }

      static void Main()
      {
         int a = 1283, b = 45, c = 35740;
         Console.WriteLine(max(a));
         Console.WriteLine(max(a, b));
         Console.WriteLine(max(a, b, c));
      }
  }

При вызове метода max компилятор выбирает вариант, соответствующий типу и количеству передаваемых в метод аргументов. Если точного соответствия не найдено, выполняются неявные преобразования типов в соответствии с общими правилами. Если преобразование невозможно, выдается сообщение об ошибке. Если выбор перегруженного метода возможен более чем одним способом, то выбирается "лучший" из вариантов (вариант, содержащий меньшие количество и длину преобразований в соответствии с правилами преобразования типов). Если существует несколько вариантов, из которых невозможно выбрать лучший, выдается сообщение об ошибке.
Перегрузка методов является проявлением полиморфизма, одного из основных свойств ООП. Программисту гораздо удобнее помнить одно имя метода и использовать его для работы с различными типами данных, а решение о том, какой вариант метода вызвать, возложить на компилятор. Этот принцип широко используется в классах библиотеки .NET. Например, в стандартном классе Console метод WriteLine перегружен 19 раз для вывода величин разных типов.
Практикум
1.	Разработать метод  для нахождения минимального из двух чисел. Вычислить с помощью него значение выражения  . 
Пример. 
using System;
namespace Hello
{
 class Program
 {
  static double min(double a, double b)
  {
   return (a < b) ? a : b;
  }

  static void Main(string[] args)
  {
   Console.Write("x=");
   double x = double.Parse(Console.ReadLine());
   Console.Write("y=");
   double y = double.Parse(Console.ReadLine());
   double z = min(3 * x, 2 * y) + min(x - y, x + y);
   Console.WriteLine("z=" + z);
  }
 }
}
2.	Постройте таблицу значений функции  для  с шагом  . 
Замечание. Для решения задачи использовать вспомогательный метод.
 
Пример:
using System;
namespace Hello
{
 class Program
 {
  static double f (double x)
  {
  double y;
  if (x >= 0.9) y = 1 / Math.Pow(1 + x, 2);
  else if (x >= 0) y = 0.2 * x + 0.1;
  else y = x * x + 0.2;
  return y;
 }

 static void Main(string[] args)
{
  Console.Write("a=");
  double a = double.Parse(Console.ReadLine());
  Console.Write("b=");
  double b = double.Parse(Console.ReadLine());
  Console.Write("h=");
  double h = double.Parse(Console.ReadLine());
  for (double i = a; i <= b; i += h)
  Console.WriteLine("f({0:f2})={1:f4}", i, f(i));
  }
 }
}
3.	Перегрузите метод  из предыдущего раздела так, чтобы его сигнатура (заголовок) соответствовала виду static void f (double x, out double y). Продемонстрируйте работу перегруженных методов. 
Самостоятельная работа 
Теоретический материал
Пусть a1, a2, …, an - произвольная числовая последовательность. Рекуррентным соотношением называется такое соотношение между членами последовательности, в котором каждый следующий член выражается через несколько предыдущих, т.е ak = f(ak-1, ak-2, …, ak-l, l < k (1).
Последовательность задана рекуррентно, если для нее определено рекуррентное соотношение вида (1) и заданы первые l ее членов.
Самым простым примером рекуррентной последовательности является арифметическая прогрессия. Рекуррентное соотношение для нее записывается в виде: ak = ak-1 + d, где d - разность прогрессии. Зная первый элемент и разность прогрессии, и, используя данное рекуррентное соотношение, можно последовательно вычислить все остальные члены прогрессии. 
Рассмотрим пример программы, в которой вычисляются первые n членов арифметической прогрессии при условии, что a1=1/2 и d=1/4.
static void Main()
 {
   Console.Write("a=");
   double a = double.Parse(Console.ReadLine());
   Console.Write("h=");
   double d = double.Parse(Console.ReadLine());
   Console.Write("n=");
   int d = int.Parse(Console.ReadLine());
   Console.WriteLine("a1="+ a);	//вывели первый член последовательности
   //организуем вычисление 2, 3, … ,n члена последовательности
   for (int i = 2; i <= n; ++i)
  {
    a += d;		//для этого прибавляем к предыдущему члену значение d
    Console.WriteLine("a{0}={1}", i, a);	//и выводим новое значение а на экран
  }
}
Результат работы программы: 
n	состояние экрана
5
a1: 0.5
a2: 0.75 
a3: 1.
a4: 1.25
a5: 1.5
Более сложная зависимость представлена в последовательности Фибоначчи: a1 = a2= 1, an = an-1 + an-2. В этом случае каждый член последовательности зависит от значений двух предыдущих членов. Рассмотрим пример программы, в которой вычисляются первые n членов последовательности Фибоначчи.
static void Main()
{//задали известные члены последовательности
 int a1=1, a2=1, a3;	
 Console.Write("n=");
 int n = int.Parse(Console.ReadLine());
 //вывели известные члены  последовательности
 Console.WriteLine("a1={0}\na2={1}",a1,a2);	
 
/*Организуем цикл для вычисления членов последовательности с номерами 3 4…n. 
При этом в переменной a1 будет храниться значение члена последовательности с номером i-2,в переменной a2 -  члена с номером i-1, переменная а будет использоваться для вычисления члена с номером i. */

for (int i = 3; i <= n; ++i)
{
 //по рекуррентному соотношению вычисляем член последовательности с номером i    //и выводим его значение на экран
a3=a1+a2;	
Console.WriteLine("a{0}={1}", i, a3); 
 //выполняем рекуррентный пересчет для следующего шага цикла                
 a1 = a2;	//в элемент с номером i-2 записываем значение элемента с   номером i-1
  a2 = a3;	 //в элемент с номером i-1 записываем значение элемента с номером i
 }
}
Результат работы программы: 
n	состояние экрана
5	a1: 1
  	a2: 1 
 	a3: 2
 	a4: 3
 	a5: 5
 
Лекция 6. Рекурсивные методы 
6.1 Прямая рекурсия 
Рекурсивным называют метод, если он вызывает сам себя в качестве вспомогательного. В основе рекурсивного метода лежит так называемое "рекурсивное определение" какого-либо понятия. Классическим примером рекурсивного метода является метод, вычисляющий факториал. 
Из курса математики известно, что 0!=1!=1, n!=1*2*3…*n. С другой стороны n!=(n-1)!*n. Таким образом, известны два частных случая параметра n, а именно n=0 и n=1, при которых мы без каких-либо дополнительных вычислений можем определить значение факториала. Во всех остальных случаях, то есть для n>1, значение факториала может быть вычислено через значение факториала для параметра n-1. Таким образом, рекурсивный метод будет иметь вид:
{
   static long F(int n)  //рекурсивный метод
   {
      if (n==0 || n==1) 
       return 1;    //нерекурсивная ветвь
       else return n*F(n-1);  //шаг рекурсии - повторный вызов метода с другим параметром
    }

    static void Main()
    {
      Console.Write("n=");
       int n =int.Parse( Console.ReadLine());
       long f=F(n); //нерекурсивный вызов метода F
       Console.WriteLine("{0}!={1}",n, f); 
      }
}

Рассмотрим работу описанного выше рекурсивного метода для n=3. 
 

Первый вызов метода осуществляется из метода Main, в нашем случае командой f=F(3). Этап вхождения в рекурсию обозначим жирными стрелками. Он продолжается до тех пор, пока значение переменной n не становится равной 1. После этого начинается выход из рекурсии (тонкие стрелки). В результате вычислений получается, что F(3)=3*2*1.
Рассмотренный вид рекурсии называют прямой. Метод с прямой рекурсией обычно содержит следующую структуру:
if (<условие>)  
<оператор>; 
else <вызов данного метода с другими параметрами>; 
В качестве <условия> обычно записываются некоторые граничные случаи параметров, передаваемых рекурсивному методу, при которых результат его работы заранее известен, поэтому далее следует простой оператор или блок, а в ветви else происходит рекурсивный вызов данного метода с другими параметрами. 
Что необходимо знать для реализации рекурсивного процесса? Со входом в рекурсию осуществляется вызов метода, а для выхода необходимо помнить точку возврата, т.е. то место программы откуда мы пришли и куда нам нужно будет возвратиться после завершения метода. Место хранения точек возврата называется стеком вызовов и для него выделяется определенная область оперативной памяти. В этом стеке запоминаются не только адреса точек возврата, но и копии значений всех параметров. По этим копиям восстанавливается при возврате вызывающий метод. При развертывании рекурсии за счет создания копий параметров возможно переполнение стека. Это является основным недостатком рекурсивного метода. С другой стороны, рекурсивные методы позволяют перейти к более компактной записи алгоритма.
Следует понимать, что любой рекурсивный метод можно преобразовать в обычный метод. И практически любой метод можно преобразовать в рекурсивный, если выявить рекуррентное соотношение между вычисляемыми в методе значениями.
Далее для сравнения каждую задачу будем решать с использованием обычного и рекурсивного методов:
Пример 1: Найти сумму цифр числа А.
Известно, что любое натуральное число A=an an-1… a1 a0, где an an-1… a1 a0 - цифры числа, можно представить следующим образом: 
A=an an-1… a1 a0 = A=an*10n + an-1*10n-1 + … a1*101 + a0*100 = ((…((an*10 + an-1)*10+ an-2)*10…)*10 + a1)*10 + a0 
Например, число 1234 можно представить как:
1234 = 1*103 + 2*102 + 3*101 + 4*100 = ((1*10 + 2)*10 + 3)*10 + 4
Из данного представления видно, что получить последнюю цифру можно, если найти остаток от деления числа на 10. В связи с этим для разложения числа на составляющие его цифры можно использовать следующий алгоритм:
1.	Находим остаток при делении числа А на 10, т.е. получаем крайнюю правую цифру числа. 
2.	Находим целую часть числа при делении A на 10, т.е. отбрасываем от числа A крайнюю правую цифру. 
3.	Если преобразованное A > 0, то переходим на пункт 1. Иначе число равно нулю и отделять от него больше нечего. 
Данный алгоритм будет использоваться при разработке нерекурсивного метода. 
С другой стороны, сумму цифр числа 1234 можно представить следующим образом sum(1234)=sum(123)+4=(sum(12)+3)+4=(((sum(1)+2)+3)+4)=(((sum(0)+1)+2)+3)+4. Таким образом, если А=0, то сумма цифр числа также равна нулю, т.е. sum=0. В противном случае сумму цифр числа A можно представить рекуррентным соотношением sum(A)=sum(A/10)+A%10. Полученное рекуррентное соотношение будем использовать при разработке рекурсивного метода.
  class Program
  {
    static long Sum(long a) //нерекусивный метод
    {
      long sum=0;
      while (a>0) //пока a больше нуля
      {
        sum+=a%10;  //добавляем к сумме последнюю цифру числа а
        a/=10;   //отбрасываем от числа а последнюю цифру
      }
      return sum;  //возвращаем в качестве результата сумму цифр числа a
    }

    static long SumR(long a) //рекурсивный метод
    {
      if (a==0) //если a =0, то
                 return 0; // возвращаем 0
      else return SumR(a/10)+ a%10; //иначе обращаемся к рекуррентному соотношению
    }

    static void Main()
    {
      Console.Write("n=");
      long n=long.Parse(Console.ReadLine());
      Console.WriteLine("Нерекурсивный метод: "+Sum(n));
      Console.WriteLine("Рекурсивный метод: "+SumR(n));
    }  
  }
}

Задание. Изменить методы так, чтобы на экран выводилось количество цифр в числе n.
Пример 2: вычислить n-ный член последовательности Фиббоначи.
Первые два члена последовательности Фиббоначи равны 1, остальные получаются по рекуррентной формуле an=an-1+an-2. 
  class Program
  {
    static int Fb(int n) //нерекурсивный алгоритм
    {
      int a, a1=1, a2=1;
      if (n==1||n==2) return 1;
      else 
      {
        for (int i=2; i<=n; ++i) 
        {
          a=a1+a2;
          a1=a2;
          a2=a;
        }
        return a1;
      }
    }

    static int FbR(int n) //рекурсивный алгоритм
    {
      if (n==1 || n==2 )return 1;
        else return FbR(n-1)+FbR(n-2);
    }

    static void Main()
    {
      Console.Write("n=");
      int n=int.Parse(Console.ReadLine());
      Console.WriteLine("Нерекурсивный метод: "+Fb(n));
      Console.WriteLine("Рекурсивный метод: "+FbR(n));
    }    
  }

Задание. Изменить методы так, чтобы на экран выводилась сумма n элементов последовательности Фиббоначи.
Рассмотренные выше рекурсивные методы возвращали некоторое значение, заданное рекуррентным соотношением. Однако, как мы знаем, не все методы возвращают значение. Кроме того, рассмотренные выше методы определяют простой вариант рекурсивного метода. В общем случае рекурсивный метод включает в себя некоторое множество операторов и один или несколько операторов рекурсивного вызова. Действия могут выполняться после рекурсивного вызова, до рекурсивного вызова, а также и до, и после рекурсивного вызова. Рассмотрим примеры "сложных" рекурсивных методов, не возвращающих значение.
Пример 3. Для заданного значения n вывести на экран n строк, в каждой из которых содержится n звездочек. Например, для n=5 на экран нужно вывести следующую таблицу:
*
**
***
****
*****

  class Program
  {
    static void Stroka(int n) //выводит на экран строку из n звездочек
    {
      for (int i=1; i<=n; ++i)
      {
        Console.Write('*');
      }
      Console.WriteLine();
    }

    static void Star(int n) //нерекурсивный метод
    {
      for (int i=1; i<=n;++i) //выводит n строк по i звездочек в каждой
        Stroka(i);
    }
  
    //рекурсивный метод, где i – номер текущей строки, n – номер последней строк 
    static void StarR(int i,int n) 
    {
      if (i<=n ) //если номер текущей строки не больше номера последней строки, то
      {
        Stroka(i); //выводим i звездочек в текущей строке и 
        StarR(i+1,n); //переходим к формированию следующей строки
      }
    }

    static void Main()
    {
      Console.Write("n=");
      int n=int.Parse(Console.ReadLine());
      Console.WriteLine("Нерекурсивный метод: ");
      Star(n);
      Console.WriteLine("Рекурсивный метод: ");
      StarR(1,n); // параметр 1 – это номер первой строки, n – номер последней строки
    }  
  }

Задание. Изменить методы так, чтобы для заданного значения n (в нашем случае для n=5) на экран выводилась следующая таблица: 
*****
****
***
**
*
Пример 4. Для заданного значения n (например для n=7) вывести на экран следующую таблицу:
* * * * * * *
  * * * * *
    * * *
      *
      *
    * * *
  * * * * *
* * * * * * *

Данную таблицу условно можно разделить на две части. Рассмотрим отдельно верхнюю часть:
Номер строки 	Содержимое экрана 	i - количество пробелов в строке 	Количество звездочек в строке 
0 	******* 	0 	7 
1 	***** 	1 	5 
2 	*** 	2 	3 
3 	* 	3 	1 
Таким образом, если нумеровать строки с нуля, то номер строки совпадает с количеством пробелов, которых нужно напечатать в начале этой строки. При этом количество звездочек в строке, можно определить по формуле n-2i, где n – это количество звездочек в нулевой строке. Так как количество звездочек в каждой строке уменьшается на 2, то всего нужно напечатать n/2+1 строк.
Аналогичную зависимость можно выявить и для нижней части таблицы.
class Program
  {
    static void Stroka(int n, char a) //выводит на экран n раз символ а 
    {
      for (int i=1; i<=n; ++i)
      {
        Console.Write(a);
      }
    }

    static void Star(int n) //нерекурсивный метод
    {
      for (int i=0; i<=n/2;++i) //выводим верхнюю часть таблицы, в которой в каждой строке вначале
      { 
        Stroka(i,' '); //печатаем пробелы
        Stroka(n-2*i,'*'); //затем звездочки
        Console.WriteLine(); //затем переводим курсор на новую строку
      }
      for (int i=n/2; i>=0;--i) // аналогично выводим нижнюю часть таблицы
      { 
        Stroka(i,' ');
        Stroka(n-2*i,'*');
        Console.WriteLine();
      }
    }
  
    //рекурсивный метод, где i определяет номер текущей строки, n – количество звездочек в строке 
    static void StarR(int i, int n) 
    {
      if (n>0 ) 
      {
        //действия до рекурсивного вызова – позволят вывести верхнюю часть таблицы 
        Stroka(i, ' ');
        Stroka(n, '*'); 
        Console.WriteLine(); 
        //вызываем этот же метод, увеличивая номер строки, и уменьшая количество звездочек в ней
        StarR(i+1,n-2);  
        //действия после рекурсивного вызова – позволят вывести нижнюю часть таблицы
        Stroka(i, ' ');
        Stroka(n, '*');
        Console.WriteLine();
      }
    }

    static void Main()
    {
      Console.Write("n=");
      int n=int.Parse(Console.ReadLine());
      Console.WriteLine("Нерекурсивный метод: ");
      Star(n);
      Console.WriteLine("Рекурсивный метод: ");
      StarR(0,n);
    }      
  }
}

Задание. Изменить методы так, чтобы для заданного значения n (в нашем случае для n=7) на экран выводилась следующая таблица: 
      *
    * * *
  * * * * *
* * * * * * *
* * * * * * *
  * * * * * 
    * * *
      *

6.2 Косвенная рекурсия 
Все примеры, рассмотренные ранее, относились к прямой рекурсии. Однако существует еще и косвенная рекурсия, в которой метод вызывает себя в качестве вспомогательного не непосредственно, а через другой вспомогательный метод. Косвенную рекурсию демонстрирует следующая программа, которая для заданного значения n выводит на экран следующее за ним простое число.
Данная программа содержит метод Prim, который возвращает true, если его параметр является простым числом, false – в противном случае. Чтобы установить, является ли число j простым, нужно проверить делимость числа j на все простые числа, не превышающие квадратный корень из j. Перебор таких простых чисел можно организовать так: рассмотреть первое простое число – 2, а затем, используя метод NextPrim, возвращающий следующее за значением ее параметра простое число, получить все простые числа, не превышающие квадрата числа j. В свою очередь метод NextPrim обращается к методу Prim для того, чтобы определить является ли заданное число простым. 
Таким образом методы Prim и NextPrim перекрестно вызывают друг друга. В этом и проявляется косвенная рекурсия.
class Program
   {
      static bool Prim (int j)
      {
         int k=2; //первое простое число
         //значение k "пробегает" последовательность простых чисел, начиная с 2 до корня из j, при
         //этом проверяется делится ли j на одно из таких простых чисел
         while (k*k<=j && j%k!=0)
            k=NextPrim(k); //вызов метода NextPrim
         return (j%k==0)?false:true;
      }

      static int NextPrim(int i)
      {
         int p=i+1;
         while (!Prim(p))	//вызов метода Prim
            ++p;
         return p;
      }

      static void Main()
      {
         Console.Write("n=");
         int n=int.Parse(Console.ReadLine());
         Console.WriteLine("Следующее за {0} простое число равно {1}.", n, NextPrim(n));
      }  
   }

Задание. Изменить программу так, чтобы на экран выводились все простые числа меньшие N.
Рекурсия является удобным средством решения многих задач: сортировки числовых массивов, обхода таких структур данных как деревья и графы.
С другой стороны, применение рекурсивных методов в ряде случаев оказывается нерациональным. Вспомним рекурсивный метод подсчета n-ного члена последовательности Фиббоначи. Данный метод будет работать весьма неэффективно. FbR(17) вычисляется в ней как FbR(16)+ FbR(15). В свою очередь FbR(16) вычисляется в ней как FbR(15)+ FbR(14). Таким образом, FbR(15) будет вычисляться 2 раза, FbR(14) – 3 раза, FbR(13) – 5 раз и т.д. Всего для вычисления FbR(17) потребуется выполнить более тысячи операций сложения. Для сравнения при вычислении Fb(17), т.е. используя не рекурсивный метод, потребуется всего лишь 15 операций сложения.
Таким образом, при разработке рекурсивного метода следует задуматься об его эффективности.
Самостоятельная работа 
Задача 1. Разработать рекурсивный метод для вывода на экран всех возможных разложений натурального числа n на множители (без повторений). Например, для n=12 на экран должно быть выведено:
2*2*3=12
2*6=12
3*4=12 
Задача 2. Разработать рекурсивный метод для вывода на экран всех возможных разложений натурального числа n на слагаемые (без повторений). Например, для n=5 на экран должно быть выведено:
1+1+1+1+1=5
1+1+1+2=5
1+1+3=5
1+4=5
2+1+2=5
2+3=5

 
Лекция 7. Обработка исключений
Язык С#, как и многие другие объектно-ориентированные языки, реагирует на ошибки и ненормальные ситуации с помощью механизма обработки исключений. Исключение - это объект, генерирующий информацию о "необычном программном происшествии". При этом важно проводить различие между ошибкой в программе, ошибочной ситуацией и исключительной ситуаций. 
Ошибка в программе допускается программистом при ее разработке. Например, вместо операции сравнения (==) используется операция присваивания (=). Программист должен исправить подобные ошибки до передачи кода программы заказчику. Использование механизма обработки исключений не является защитой от ошибок в программе.
Ошибочная ситуация вызвана действиями пользователя. Например, пользователь вместо числа ввел строку. Такая ошибка способна вызывать исключение. Программист должен предвидеть ошибочные ситуации и предотвращать их с помощью операторов, проверяющих допустимость поступающих данных.
Даже если программист исправил все свои ошибки в программе, предвидел все ошибочные ситуации, он все равно может столкнуться с непредсказуемыми и неотвратимыми проблемами - исключительными ситуациями. Например, нехваткой доступной памяти или попыткой открыть несуществующий файл. Исключительные ситуации программист предвидеть не может, но он может отреагировать на них так, что они не приведут к краху программы. 
Для обработки ошибочных и исключительных ситуаций в С# используется специальная подсистема обработки исключений. Преимущество данной подсистемы состоит в автоматизации создания большей части кода по обработке исключений. Раньше этот код приходилось вводить в программу "вручную". Кроме этого обработчик исключений способен распознавать и выдавать информацию о таких стандартных исключениях, как деление на нуль или попадание вне диапазона определения индекса.
7.1 Оператор try
В С# исключения представляются классами. Все классы исключений порождены от встроенного класса исключений Exception, который определен в пространстве имен System.
Управление обработкой исключений основывается на использовании оператора try. Синтаксис оператора: 
try	// контролируемый блок
{ 
…
}
catch //один или несколько блоков обработки исключений
{ 
…
}
finally	//блок завершения
{
…
}
Программные инструкции, которые нужно проконтролировать на предмет исключений, помещаются в блок try. Если исключение возникает в этом блоке, оно дает знать о себе выбросом определенного рода информации. Выброшенная информация может быть перехвачена и обработана соответствующим образом с помощью блока catch. Любой код, который должен быть обязательно выполнен при выходе из блока try, помещается в блок finally. Рассмотрим пример, демонстрирующий, как отследить и перехватить исключение.
static void Main()
{
int  x = int.Parse(Console.ReadLine());
int y =1 / x; 
Console.WriteLine(y);
}
Перечислим, какие исключительные ситуации могут возникнуть:
1.	пользователь может ввести нечисловое значение 
2.	если ввести значение 0, то произойдет деление на 0. 
Создайте указанные исключительные ситуации и посмотрите, как отреагирует на них система. 
Задание. Переменные x и y объявлены целочисленными. Объясните, что будет выведено на экран, если замените их тип на double и ввести с клавиатуры значение х равное 0, и почему. 
Теперь попробуем обработать эти ситуации. Для этого изменим код следующим образом. 
static void Main()
{ 
  try
  {
    int x = int.Parse(Console.ReadLine());    
    int y =1 / x;
Console.WriteLine("y={0}", y);
    Console.WriteLine("блок try выполнилсь успешно");
  }
  catch		// *
  {
    Console.WriteLine("возникла какая-то ошибка");
  }
  Console.WriteLine("конец программы");
}
Рассмотрим, как обрабатываются исключения в данном примере. Когда возникает исключение, выполнение программы останавливается и управление передается блоку catch. Этот блок никогда не возвращает управление в то место программы, где возникло исключение. Поэтому команды из блока try, расположенные ниже строки, в которой возникло исключение, никогда не будут выполнены. Блок catch обрабатывает исключение, и выполнение программы продолжается с оператора, следующего за этим блоком.
В нашем случае при вводе нечислового значения или 0 будет выведено сообщение "возникла ошибка", а затем сообщение "конец программы".
Обработчик исключений позволяет не только отловить ошибку, но и вывести полную информацию о ней. Для демонстрации сказанного заменим блок catch следующим фрагментом. 
catch (Exception error)
{
  Console.WriteLine("Возникла ошибка {0}", error);
}
Теперь, если возникнет исключительная ситуация, "выброшенная" информация будет записана в идентификатор error. Данную информацию можно просмотреть с помощью метода WriteLine. Такое сообщение очень полное и будет полезно только разработчику на этапе отладки проекта. 
Для пользователя на этапе эксплуатации приложения достаточно более краткой информации о типе ошибке. С этой целью в С# выделены стандартные классы исключений, такие как DivideByZeroException, FormatException. Внесем изменения в программу.
static void Main()
{ 
  try
  {
    int x = int.Parse(Console.ReadLine());    // 1 ситуация              
    int y =1 / x;   // 2 ситуация
    Console.WriteLine("y={0}", y);
    Console.WriteLine("блок try выполнилсь успешно");
  }
  catch(FormatException)  // обработка 1 ситуации
  {
    Console.WriteLine("Ошибка: введено нечисловое значение!");                
  }
  catch (DivideByZeroException) // обработка 2 ситуации
  {
    Console.WriteLine("Ошибка: деление на 0!");
  }
  Console.WriteLine("конец программы");
}
В данном примере обрабатывается каждая ситуация в отдельности, при этом пользователю сообщается лишь минимальная информация об ошибке. В следующей таблице содержится описание наиболее часто используемых обработчиков стандартных исключений.
Имя	Описание
ArithmeticException	Ошибка в арифметических операциях или преобразованиях
ArrayTypeMismatchException	Попытка сохранения в массиве элемента несовместимого типа 
DivideByZeroException	Попытка деления на ноль
FormatException	Попытка передать в метод аргумент неверного формата
IndexOutOfRangeException	Индекс массива выходит за границу диапазона
InvalidCastException	Ошибка преобразования типа
OutOfMemoryException	Недостаточно памяти для нового объекта
OverflowException	Переполнение при выполнении арифметических операций
StackOverflowException	Переполнение стека
Одно из основных достоинств обработки исключений состоит в том, что она позволяет программе отреагировать на ошибку и продолжить выполнение. Рассмотрим программу, которая строит таблицу значений для функции вида y(x)=100/(x2-1). 
static void Main()
{
 Console.WriteLine("a=");
 int a = int.Parse( Console.ReadLine());
 Console.WriteLine("b=");
 int b = int.Parse(Console.ReadLine());
 for (int i = a; i <= b; ++i)
 {
  try
  {
   Console.WriteLine("y({0})={1}", i, 100 / (i * i - 1));
  }
  catch (DivideByZeroException)
  {
   Console.WriteLine("y({0})=Деление на 0", i);
  }
 }
}
Если встречается деление на нуль, генерируется исключение типа DivideByZeroException. В программе это исключение обрабатывается выдачей сообщения об ошибке, после чего выполнение программы продолжается. При этом попытка разделить на нуль не вызывает внезапную динамическую ошибку (т.к. блок обработки прерываний помещен внутрь цикла for). Вместо этого исключение позволяет красиво выйти из ошибочной ситуации и продолжить выполнение программы.
7.2 Операторы checked и unchecked
В С# предусмотрено специальное средство, которое связано с генерированием исключений, вызванных переполнением результата в арифметических вычислениях. Например, когда значение арифметического выражения выходит за пределы диапазона, определенного для типа данных выражения. Рассмотрим небольшой фрагмент программы:
static void Main()
{
 byte x = 200; byte y = 200;
 byte result = (byte) (x + y);
 Console.WriteLine(result);
}
Здесь сумма значений а и b превышает диапазон представления значений типа byte. Следовательно, результат данного выражения не может быть записан в переменную result, тип которой byte.
Для управления подобными исключениями в С# используются операторы checked и unchecked. Чтобы указать, что некоторое выражение должно быть проконтролировано на предмет переполнения, используйте ключевое слово checked. А чтобы проигнорировать переполнение, используйте ключевое слово unchecked. В последнем случае результат будет усечен так, чтобы его тип соответствовал типу-результату выражения.
Замечание. По умолчанию проверка переполнения отключена (галочка не стоит). В результате код выполняется быстро, но тогда программист должен быть уверен, что переполнения не случится или предусмотреть его возникновение. Как мы уже упоминали, можно включить проверку переполнения для всего проекта, однако она не всегда нужна. С помощью использования операторов checked и unchecked в С# реализуется механизм гибкого управления проверкой
Можно задать (или отключить) проверку переполнения сразу для всего проекта. Для этого необходимо выполнить следующие действия
1.	Щелкнуть правой кнопкой мыши на имени проекта 
2.	В выпадающем меню выбрать Properties 
3.	В появившемся окне (см. рис.) выбрать слева страницу Build 
4.	Щелкнуть на кнопке Advanced 
5.	В появившемся окошке поставить или убрать галочку напротив Check for arithmetic overflow/underflow property. 
 


Оператор checked имеет две формы:
1.	проверяет конкретное выражение и называется операторной checked-формой 
2.	checked ((тип-выражения) expr)
где expr — выражение, значение которого необходимо контролировать. Если значение контролируемого выражения переполнилось, генерируется исключение типа OverflowException.
3.	проверяет блок инструкций 
4.	checked 
5.	{
6.	 // Инструкции, подлежащие проверке.
7.	}
Оператор unchecked также имеет две формы:
1.	операторная форма, которая позволяет игнорировать переполнение для заданного выражения 
2.	unchecked ((тип-выражения) expr)
где ехрr — выражение, которое не проверяется на предмет переполнения. В случае переполнения это выражение усекается.
3.	игнорирует переполнение, которое возможно в блоке инструкций 
4.	unchecked 
5.	{
6.	 // Инструкции, для которых переполнение игнорируется.
7.	}
Рассмотрим пример программы, которая демонстрирует использование checked и unchecked.
static void Main()
{
 byte x = 200; byte y = 200;
 try
 {
  byte result = unchecked((byte)(x + y)); 
  Console.WriteLine("1: {0}", result);
  result = checked((byte)(x + y));
  Console.WriteLine("2: ", result);
 }
 catch (OverflowException)
 {
  Console.WriteLine("возникло переполнение");
 }
}
Результат выполнения программы:
1: 144
возникло переполнение
Задание. Уберите блок uncheсked. Посмотрите, что изменится в выполнении программы и дайте этому объяснение
В данном примере мы посмотрели, как использовать checked и uncheсked для проверки выражения. А теперь посмотрим, как использовать их для контроля за блоком инструкций.
static void Main()
{
 byte n = 1; byte i;
 try
 {
  unchecked	//блок без проверки
  {
   for (i = 1; i < 10; i++) n *= i;
   Console.WriteLine("1: {0}", n);
  }
  checked 	//блок с проверкой
  {
   n=1;
   for (i = 1; i < 10; i++) n *= i;
   Console.WriteLine("2: ", n);
  }
 }
 catch (OverflowException)
 {
  Console.WriteLine("возникло переполнение");
 }
}
Результат выполнения программы:
1: 128
возникло переполнение
Задание. Поменяйте местами блоки unchecked и checked. Посмотрите, что изменится в выполнении программы и дайте этому объяснение
7.3 Генерация собственных исключений
До сих пор мы рассматривали исключения, которые генерирует среда, но сгенерировать исключение может и сам программист. Для этого необходимо воспользоваться оператором throw, указав параметры, определяющие вид исключения. Параметром должен быть объект, порожденный от стандартного класса System.Exception. Этот объект используется для передачи информации об исключении обработчику.
static void Main()
{
 try
 {
  int x = int.Parse(Console.ReadLine());
  if (x < 0) throw new Exception(); //1
  Console.WriteLine("ok");
 }
 catch 
 {
  Console.WriteLine("введено недопустимое значение");
 }
}
В строчке 1 c помощью команды new был создан объект исключения типа Exception. При необходимости можно генерировать исключение любого типа.
При генерации исключения можно определить сообщение, которое будет "выбрасываться" обработчиком исключений. Например:
static void Main()
{
 try
 {
  int x = int.Parse(Console.ReadLine());
  if (x < 0) throw new Exception("введено недопустимое значение"); //1
  Console.WriteLine("ok");
 }
 catch (Exception error)
 {
  Console.WriteLine(error.Message);
 } 
}
7.4 Приемы использования обработчиков исключений
Рассмотрим несколько полезных приемов использования обработчиков исключений.
Пример 1. Один try-блок можно вложить в другой. Исключение, сгенерированное во внутреннем try-блоке и не перехваченное catch-инструкцией, которая связана с этим try-блоком, передается во внешний try-блок. Например, в следующей программе исключение типа ArithmeticException перехватывается не внутренним try-блоком, а внешним.
static void Main()
{
 Console.WriteLine("a=");
 byte a = byte.Parse(Console.ReadLine());
 Console.WriteLine("b=");
 byte b = byte.Parse(Console.ReadLine());
 int f=1;
 try //Внешний блок-try
 {
  for (byte i = a; i <= b; ++i)
  {
   try //Внутренний блок-try
   {
    f=checked((int)(f*i));
    Console.WriteLine("y({0})={1:f6}", i, 100 / (f - 1));
   }
   catch (DivideByZeroException)
   {
    Console.WriteLine("y({0})=Деление на 0", i);
   }
  }
 }
 catch (ArithmeticException)
 {
  Console.WriteLine("ERROR");
 }
}
Использование вложенных try-блоков обусловлено желанием обрабатывать различные категории ошибок различными способами. Одни типы ошибок носят катастрофический характер и не подлежат исправлению. Другие — неопасны для дальнейшего функционирования программы, и с ними можно справиться прямо на месте их возникновения. Поэтому внешний try-блок можно использовать для перехвата самых серьезных ошибок, позволяя внутренним try-блокам обрабатывать менее опасные.
Пример 2. Исключение, перехваченное одной catch-инструкцией, можно сгенерировать повторно, чтобы обеспечить возможность его перехвата другой (внешней) catch-инструкцией. Это позволяет нескольким обработчикам получить доступ к исключению. 
static void genException ()
{
 Console.WriteLine("a=");
 double a = double.Parse(Console.ReadLine());
 Console.WriteLine("b=");
 double b = double.Parse(Console.ReadLine());
 int f = 1;
 try //Внешний блок-try
 { 
  for (double i = a; i <= b; ++i)
  {
   try //Внутренний блок-try
   {
    f = checked((int)(f * i));
    Console.WriteLine("y({0})={1:f6}", i, 100 / (f - 1));
  }
  catch (DivideByZeroException)
  {
   Console.WriteLine("y({0})=Деление на 0", i);
   }
  }
 }
 catch (ArithmeticException)
 {
  Console.WriteLine("ERROR");
  throw ; //повторная генерация исключения
 }
}

static void Main()
{
 try
 {
  genException();
 }
 catch
 {
  Console.WriteLine("НЕИСПРАВИМАЯ ОШИБКА!!!");
 }
} 
Нужно помнить, что при повторном генерировании исключения оно не будет повторно перехватываться той же catch-инструкцией, а передается следующей (внешней) catch-инструкции.
Задания. 
1.	Объясните почему не было сгенерировано исключение DivideByZeroException. 
2.	Сгенерируйте собственное исключение DivideByZeroException и его обработку для ситуации f-1<0.000001. 
Пример 3. Как упоминалось выше, тип исключения должен совпадать с типом, заданным в catch-инструкции. В противном случае это исключение не будет перехвачено. Можно перехватывать все исключения, используя catch-инструкцию без параметров. Кроме того, с try-блоком можно связать не одну, а несколько catch-инструкций. В этом случае все catch-инструкции должны перехватывать исключения различного типа. Если вы все же не уверены, что предусмотрели все ситуации, то последней можно добавить catch-инструкцию без параметров.
Замечание. Иногда возникает потребность в обязательном выполнении каких-то действий, которые должны выполниться по выходу из try/catch-блока. Например, генерируется исключение и происходит преждевременное завершение выполнения программного фрагмента, но при этом остается открытым файл. Для выхода из такой ситуации С# предоставляет блок finally, который добавляется после всех блоков catch.
static void Main()
{
 for (int i = 0; i < 5; i++)
 {
  try
  {
   Console.WriteLine("Введите два числа");
   int a = int.Parse(Console.ReadLine());
   int b = int.Parse(Console.ReadLine());
   Console.WriteLine(a+"/"+b+"="+a/b);
  }
  catch (FormatException)
  {
   Console.WriteLine("Нужно ввести число!");
  }
  catch (DivideByZeroException)
  {
   Console.WriteLine("Делить на нуль нельзя!");
  }
  catch 
  {
   Console.WriteLine("Какая-то ошибка");
  }
  finally
  {
   Console.WriteLine("после try-блока");
  }
 }
}
Задание. Протестируйте данную программу, вводя поочередно следующие значения: 
a=4, b=2
a=3, b=g
a=d, b=1
a=2, b=0,
a=123456789987654321, b=1

Самостоятельная работа 
Вычисление конечных сумм и произведений
Решение многих задач связано с нахождением суммы или произведения элементов заданной последовательности. В данном разделе мы рассмотрим основные приемы вычисления конечных сумм и произведений.
Пусть  - произвольная последовательность n функций. Будем рассматривать конечную сумму вида  . Такую сумму можно записать более компактно, используя следующее обозначение:  . При  значение суммы равно 0.
В дальнейшем будем также использовать сокращенную запись для конечного произведения данной последовательности, которая выглядит следующим образом:  .
1.	Написать программу, которая подсчитывает сумму натуральных чисел от  до  ( ). 
Указания по решению задачи. Пусть  - сумма натуральных чисел от  до  . Тогда  Мы пришли к рекуррентному соотношению  , которым мы можем воспользоваться для подсчета суммы. Соотношение  говорит о том, что сумма на  -ном шаге равна сумме, полученной на предыдущем шаге, плюс очередное слагаемое. 
static void Main()
{
 Console.Write("Ввведите значение n: ");
 int n=int.Parse(Console.ReadLine());
 int s=0;
 for (int i=1; i<=n; ++i)
  s+=i;
 Console.WriteLine("s="+s);
}
2.	Написать программу, которая подсчитывает  для вещественного  и натурального  . 
Указание по решению задачи. Из свойства факториала  ,  ,  . Следовательно, факториал можно вычислять, используя рекуррентное соотношение  . 
static void Main()
{
 Console.Write("Ввведите значение n: ");
 int n=int.Parse(Console.ReadLine());
 int f=1;
 for (int i=1; i<=n; ++i)
 f*=i;
 Console.WriteLine("{0}!={1}", n, f);
}
3.	Написать программу для подсчета суммы  , где  - вещественное число,  - натуральное число. 
Указания по решению задачи. Если пронумеровать слагаемые, начиная с  , то мы увидим, что номер слагаемого совпадает со значением знаменателя. Рассмотрим каждый числитель отдельно:  Эту последовательность можно представить рекуррентным соотношением  (1). Теперь сумму можно представить следующим образом,  , а для нее справедливо рекуррентное соотношение  ,  (2). При составлении программы будем использовать формулы (1-2). 
static void Main()
{
 Console.Write("Ввведите значение n: ");
 int n=int.Parse(Console.ReadLine());
 Console.Write("Ввведите значение x: ");
 double x=double.Parse(Console.ReadLine());
 double b=0, s=0;
 for (int i=1; i<=n; ++i)
 {
  b+=Math.Cos(i*x);
  s+=b/i;
 }
 Console.WriteLine("s={0:f2}",s);
}
4.	Написать программу для подсчета суммы  , где  - вещественное число,  - натуральное число. 
Указания по решению задачи. Перейдем от сокращенной формы записи к развернутой, получим 
 
Каждое слагаемое формируется по формуле  . Если в эту формулу подставить  , то получим  . 
Чтобы не вводить несколько рекуррентных соотношений (отдельно для числителя, отдельно для знаменателя), представим общий член последовательности слагаемых с помощью рекуррентного соотношением вида  , где  для нас пока не известно. Найти его можно из выражения  . Произведя необходимые расчеты, получим, что  . Следовательно, для последовательности слагаемых мы получили рекуррентное соотношение  ,  (3). А всю сумму, по аналогии с предыдущими примерами, можно представить рекуррентным соотношением:  ,  (4). Таким образом, при составлении программы будем пользоваться формулами (3-4).
using System;

namespace Hello
{
 class Program
 {
  static void Main()
  {
   Console.Write("Ввведите значение n: ");
   int n=int.Parse(Console.ReadLine());
   Console.Write("Ввведите значение x: ");
   double x=double.Parse(Console.ReadLine());
   double a=-1, s=0;
   for (int i=1; i<=n; ++i)
   {
    a*=-x/i;  s+=a;
   }
   Console.WriteLine("s={0:f2}",s);
  }
 }
}
Вычисление бесконечных сумм
Будем теперь рассматривать бесконечную сумму вида  . Это выражение называется функциональным рядом. При различных значениях  из функционального ряда получаются различные числовые ряды  . Числовой ряд может быть сходящимся или расходящимся. Совокупность значений  , при которой функциональный ряд сходится, называется его областью сходимости.
Числовой ряд называется сходящимся, если сумма n первых его членов  при  имеет предел, в противном случае, ряд называется расходящимся. Ряд может сходиться лишь при условии, что общий член ряда  при неограниченном увеличении его номера стремится к нулю:  . Это необходимый признак сходимости для всякого ряда.
В случае бесконечной суммы будем вычислять ее с заданной точностью  Cчитается, что требуемая точность достигается, если вычислена сумма нескольких первых слагаемых и очередное слагаемое оказалось по модулю меньше чем е, то есть это слагаемое на результат практически не влияет. Тогда его и все последующие слагаемые можно не учитывать. 
Пример. Написать программу для подсчета суммы  с заданной точностью  ( ). 
Указание по решению задачи. Рассмотрим, что представляет из себя заданный ряд:  . Как видим, общий член ряда с увеличением значения i стремится к нулю. Поэтому данную сумму можно вычислить, но только с определенной точностью  . Заметим также, что последовательность слагаемых можно выразить с помощью рекуррентного соотношения  ,  , а всю сумму - с помощью рекуррентного соотношения  . (Данные рекуррентные соотношения выведите самостоятельно.)
using System;
namespace Hello
{
 class Program
 {
  static void Main()
  {
   Console.Write("Задайте точность вычислений е: ");
   double e=double.Parse(Console.ReadLine());
   double a=-1, s=0;
   for (int i=2; Math.Abs(a)>=e; ++i)
   {
    s+=a;
    a/=-i;
   }
   Console.WriteLine("s={0:f2}",s);
  }
 }
}

 
Лекция 8. Массивы
Массив - набор элементов одного и того же типа, объединенных общим именем. Массивы в С# можно использовать по аналогии с тем, как они используются в других языках программирования. Однако С#-массивы имеют существенные отличия: они относятся к ссылочным типам данных, более того - реализованы как объекты. Фактически имя массива является ссылкой на область кучи (динамической памяти), в которой последовательно размещается набор элементов определенного типа. Выделение памяти под элементы происходит на этапе инициализации массива. А за освобождением памяти следит система сборки мусора - неиспользуемые массивы автоматически утилизируются данной системой. 
Рассмотрим различные типы массивов.
8.1 Одномерные массивы
Одномерный массив - это фиксированное количество элементов одного и того же типа, объединенных общим именем, где каждый элемент имеет свой номер. Нумерация элементов массива в С# начинается с нуля, то есть, если массив состоит из 10 элементов, то его элементы будут иметь следующие номера: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9. 
Одномерный массив в С# реализуется как объект, поэтому его создание представляет собой двухступенчатый процесс. Сначала объявляется ссылочная переменная на массив, затем выделяется память под требуемое количество элементов базового типа, и ссылочной переменной присваивается адрес нулевого элемента в массиве. Базовый тип определяет тип данных каждого элемента массива. Количество элементов, которые будут храниться в массиве, определяется размер массива.
В общем случае процесс объявления переменной типа массив, и выделение необходимого объема памяти может быть разделено. Кроме того на этапе объявления массива можно произвести его инициализацию. Поэтому для объявления одномерного массива может использоваться одна из следующих форм записи:
Форма записи	Пояснения 
базовый_тип [] имя__массива;
Например: 
int [] a;  	Описана ссылка на одномерный массив, которая в дальнейшем может быть использована: 
1.	для адресации на уже существующий массив; 
2.	передачи массива в метод в качестве параметра 
3.	отсроченного выделения памяти под элементы массива. 
базовый_тип [] имя__массива = new базовый_тип [размер];
Например: 
int []a=new int [10];	Объявлен одномерный массив заданного типа и выделена память под одномерный массив указанной размерности. Адрес данной области памяти записан в ссылочную переменную. Элементы массива равны нулю. 
Замечание. Надо отметить, что в C# элементам массива присваиваются начальные значения по умолчанию в зависимости от базового типа. Для арифметических типов - нули, для ссылочных типов - null, для символов - пробел.
базовый_тип [] имя__массива={список инициализации};
Например: 
int []a={0, 1, 2, 3};	Выделена память под одномерный массив, размерность которого соответствует количеству элементов в списке инициализации. Адрес этой области памяти записан в ссылочную переменную. Значение элементов массива соответствует списку инициализации.
Обращения к элементам массива происходи с помощью индекса, для этого нужно указать имя массива и в квадратных скобках его номер. Например, a[0], b[10], c[i]. 
Так как массив представляет собой набор элементов, объединенных общим именем, то обработка массива обычно производится в цикле. Рассмотрим несколько простых примеров работы с одномерными массивами.
Пример 1.
static void Main()
{
  int[] myArray = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  int i;
  for (i = 0; i < 10; ++i)
  Console.WriteLine(myArray[i]);
}
Задание. Измените программу так, чтобы числа выводились в строчку.
Пример 2.
static void Main()
{
  int[] myArray = new int[10];
  int i;
  for (i = 0; i < 10; i++)
  myArray[i] = i * i;
  for (i = 0; i < 10; i++)
  Console.WriteLine(myArray[i]);
}
Задание. Измените программу так, чтобы обрабатывался массив из n чисел.
Хотя при инициализации массива нет необходимости использовать операцию new, все же массив можно инициализировать следующим образом: 
int [ ] myArray = new int [ ] { 99, 10, 100, 18, 78, 23, 163, 9, 87, 49 };
Несмотря на избыточность, данная форма инициализации массива может оказаться полезной в том случае, когда уже существующей ссылке на одномерный массив присваивается ссылка на новый массив. Например:
static void Main()
{
  int[] myArray = { 0, 1, 2, 3, 4, 5};
  int i;
  for (i = 0; i < 10; i++)
  Console.Write(" "+myArray[i]);
  Console.WriteLine("\nНовый массив: ");
  myArray = new int[] { 99, 10, 100, 18, 78, 23, 163, 9, 87, 49 }; // 1
  for (i = 0; i < 10; i++)
  Console.Write(" " + myArray[i]);
}
Следует отметить, что первоначально переменная myArray ссылалась на 6-ти элементный массив. В строке 1 переменной myArray была присвоена ссылка на новый 10-элементный массив, в результате чего исходный массив оказался неиспользуемым, т.к. на него теперь не ссылается ни один объект. Поэтому он автоматически будет удален сборщиком мусора.
Массивы и исключения
Выход за границы массива в C# расценивается как ошибка, в ответ на которую генерируется исключение - IndexOutOfRangeException. 
Рассмотрим следующий пример:
static void Main()
{
  int[] myArray = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  int i;
  try
  {
    for (i = 0; i <= 10; i++) Console.WriteLine(myArray[i]);
  }
  catch (IndexOutOfRangeException)
  {
    Console.WriteLine("Exception: Выход за границу диапазона");
  }
}
Задание. Добавьте в программу обработчики исключений FormatException и OutOfMemoryException. Вспомните, что они контролируют.
8.2 Массив как параметр
Так как имя массива фактически является ссылкой, то он передается в метод по ссылке и, следовательно, все изменения элементов массива, являющегося формальным параметром, отразятся на элементах соответствующего массива, являющимся фактическим параметром. 
Рассмотрим пример передачи массива как параметра:
class Program
{
  static void Print(int n, int[] a) //n - размерность массива, а - ссылка на массив
  {
    for (int i = 0; i < n; i++) Console.Write("{0} ", a[i]);
    Console.WriteLine();
  }

  static void Change(int n, int[] a)
  {
    for (int i = 0; i < n; i++)
    if (a[i] > 0) a[i] = 0; // изменяются элементы массива
  }

  static void Main()
  {
    int[] myArray = { 0, -1, -2, 3, 4, 5, -6, -7, 8, -9 };
    Print(10, myArray);
    Change(10, myArray);
    Print(10, myArray);
  }
}
Задание. Измените программу так, чтобы метод Change удваивал значения положительных элементов массива.
8.3 Массив как объект
Мы уже говорили о том, что массивы в С# реализованы как объекты. Если говорить более точно, то они реализованы на основе базового класса Array, определенного в пространстве имен System. Данный класс содержит различные свойства и методы. Например, свойство Length позволяет определять количество элементов в массиве. Преобразуем предыдущий пример:
class Program
{
  static void Print(int[] a) // передаем только ссылку на массив
  {
    for (int i = 0; i < a.Length; i++) Console.Write("{0} ", a[i]);
    Console.WriteLine();
  }

  static void Change(int[] a)
  {
    for (int i = 0; i < a.Length; i++)
    if (a[i] > 0) a[i] = 0;
  }

  static void Main()
  {
    int[] myArray = { 0, -1, -2, 3, 4, 5, -6, -7, 8, -9 };
    Print(myArray);
    Change(myArray);
    Print(myArray);
  }
}
Другие свойства и методы класса Array приведены в следующей таблице:
Элемент	Вид	Описание
Length	свойство	Количество элементов массива (по всем размерностям)
BinarySearch	статический метод 	Двоичный поиск в отсортированном массиве
Clear	статический метод	Присваивание элементам массива значений по умолчанию
Copy	статический метод	Копирование заданного диапазона элементов одного массива в другой
CopyTo	экземплярный метод	Копирование всех элементов текущего одномерного массива в другой массив
GetValue	экземплярный метод	Получение значения элемента массива
IndexOf	статический метод	Поиск первого вхождения элемента в одномерный массив
LastIndexOf	статический метод	Поиск последнего вхождения элемента в одномерный массив
Reverse	статический метод	Изменение порядка следования элементов на обратный
SetValue	экземплярный метод	Установка значения элемента массива
Sort	статический метод	Упорядочивание элементов одномерного массива
Вызов статических методов происходит через обращение к имени класса, например, Array.Sort(myArray). В данном случае мы обращаемся к статическому методу Sort класса Array и передаем данному методу в качестве параметра объект myArray - экземпляр класса Array.
Обращение к свойству или вызов экземплярного метода производится через обращение к экземпляру класса, например, myArray.Length или myArray.GetValue(i).
Пример:
class Program
{
  static void Main()
  {
    try
    {
      int[] MyArray;
      Console.Write("Введите размерность массива: ");
      int n = int.Parse(Console.ReadLine());
      MyArray = new int[n];
      for (int i = 0; i < MyArray.Length; ++i)
      {
        Console.Write("a[{0}]=",i);
        MyArray[i] = int.Parse(Console.ReadLine());
      }
      PrintArray("исходный массив:", MyArray);
      Array.Sort(MyArray);
      PrintArray("массив отсортирован по возрастанию", MyArray);
      Array.Reverse(MyArray);
      PrintArray("массив отсортирован по убыванию", MyArray);
    }
    catch (FormatException)
    {
      Console.WriteLine("неверный формат ввода данных");
    }
    catch (OverflowException)
    {
      Console.WriteLine("переполнение");
    }
    catch (OutOfMemoryException)
    {
      Console.WriteLine("недостаточно памяти для создания нового объекта");
    }
  }

  static void PrintArray(string a, int[] mas)
  {
    Console.WriteLine(a);
    for (int i = 0; i < mas.Length; i++) Console.Write("{0} ", mas[i]);
    Console.WriteLine();
  }
}
}
Задание. Добавьте в программу метод InputArray, предназначенный для ввода с клавиатуры элементов массива. Продемонстрируйте работу данного метода.
8.4 Многомерные массивы
Многомерные массивы имеют более одного измерения. Чаще всего используются двумерные массивы, которые представляют собой таблицы. Каждый элемент массива имеет два индекса, первый определяет номер строки, второй - номер столбца, на пересечении которых находится элемент. Нумерация строк и столбцов начинается с нуля. 
Объявить двумерный массив можно одним из предложенных способов:
тип [,] имя__массива;
тип [,] имя__массива = new тип [размер1, размер2];
тип [,] имя__массива={{элементы 1-ой строки}, … , {элементы n-ой строки}};
тип [,] имя__массива= new тип [,]{{элементы 1-ой строки}, … ,{элементы n-ой строки}};
строки}};
Например:
int [,] a; 
int [,] a= new int [3, 4];
int [,] a={{0, 1, 2}, {3, 4, 5}};
int [,] a= new int [,]{{0, 1, 2}, {3, 4, 5}};

Замечания. 
1.	Как и в случае с одномерными массивами, последние два описания являются избыточными. 
2.	При работе с многомерными массивами можно использовать приемы, которые мы рассмотрели для одномерных массивов. 
3.	При обращении к свойству Length для двумерного массива мы получим общее количество элементов в массиве. Чтобы получить количество строк нужно обратиться к методу GetLength с параметром 0. Чтобы получить количество столбцов - к методу GetLength с параметром 1. 
Пример:
class Program
  {
    static void PrintArray(string a, int[,] mas)
    {
      Console.WriteLine(a);
      for (int i = 0; i < mas.GetLength(0); i++)
      {
        for (int j = 0; j < mas.GetLength(1); j++)
          Console.Write("{0} ", mas[i, j]);
        Console.WriteLine();
      }
    }

    static void Change(int[,] mas)
    {
      for (int i = 0; i < mas.GetLength(0); i++)
        for (int j = 0; j < mas.GetLength(1); j++)
          if (mas[i, j] % 2 == 0) mas[i, j] = 0;              
    }

    static void Main()
    {
      try
      {
        int[,] MyArray ={ { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
        PrintArray("исходный массив:", MyArray);
        Change(MyArray);
        PrintArray("итоговый массив", MyArray);
      }
      catch (FormatException)
      {
            Console.WriteLine("неверный формат ввода данных");
      }
      catch (OverflowException)
      {
            Console.WriteLine("переполнение");
      }
      catch (OutOfMemoryException)
      {
            Console.WriteLine("недостаточно памяти для создания нового объекта");
      }
    }
  }
Задания. 
1.	Добавьте в программу метод InputArray, предназначенный для ввода с клавиатуры элементов массива. Продемонстрируйте работу данного метода. 
2.	Измените метод Change так, чтобы он вычислял сумму четных элементов двумерного массива. 
8.5 Ступенчатые массивы
В ступенчатых массивах количество элементов в разных строках может быть различным. В памяти ступенчатый массив хранится в виде массива массивов. Структура ступенчатого массива:
Массив	a		a[0]		a[0][0]	a[0][1]	…		
			a[1]						
			…		a[1][0]	a[1][1]	…		
			a[n]						
					a[n][0]	a[n][1]	…		
Объявление ступенчатого массива:
тип [][] имя_массива;
Например:
int [][]a;
Фактически мы объявили одномерный массив ссылок на целочисленные одномерные массивы. При таком описании потребуется не только выделять память под одномерный массив ссылок, но и под каждый из целочисленных одномерных массивов. Такое распределение памяти позволяет определять произвольную длину каждой строки массива (отсюда и произошло название массива - ступенчатый). Например:
int [][] a= new int [3][];  // Создаем три строки
a[0]=new int [2];  // 0-ая строка ссылается на 2-х элементый одномерный массив 
a[1]=new int [3];  // 1-ая строка ссылается на 3-х элементый одномерный массив
a[2]=new int [10];  // 2-ая строка ссылается на 10-х элементый одномерный массив
Другой способ выделения памяти:
int [][] a= {new int [2], new int [3], new int [10]};
Так как каждая строка ступенчатого массива фактически является одномерным массивом, то с каждой строкой можно работать как с экземпляром класса Array. Это является преимуществом ступенчатых массивов перед двумерными массивами.
Пример:
class Program
{
  static void Main()
  {
    try
    {
      int[][] MyArray;
      Console.Write("Ввведите количесвто строк: ");
      int n = int.Parse(Console.ReadLine());
      MyArray = new int[n][];
      for (int i = 0; i < MyArray.Length; i++)
      {
        Console.Write("введите количество элементов в {0} строке: ", i);
        int j = int.Parse(Console.ReadLine());
        MyArray[i] = new int[j];
        for (j = 0; j < MyArray[i].Length; j++)
        {
          Console.Write("a[{0}][{1}]= ", i, j);
          MyArray[i][j] = int.Parse(Console.ReadLine());
        }
      }
      PrintArray("исходный массив:", MyArray);
      for (int i = 0; i < MyArray.Length; i++) Array.Sort(MyArray[i]);
      PrintArray("измененный массив", MyArray);
    }
    catch (FormatException)
    {
      Console.WriteLine("неверный формат ввода данных");
    }
    catch (OverflowException)
    {
      Console.WriteLine("переполнение");
    }
    catch (OutOfMemoryException)
    {
      Console.WriteLine("недостаточно памяти для создания нового объекта");
    }
  }

  static void PrintArray(string a, int[][] mas)
  {
    Console.WriteLine(a);
    for (int i = 0; i < mas.Length; i++)
    {
      for (int j = 0; j < mas[i].Length; j++) Console.Write("{0} ", mas[i][j]);
      Console.WriteLine();
    }
  }
}
Задание. Добавьте в программу метод MakeArray, предназначенный для создания ступенчатого массива, в котором количество элементов в каждой строке больше номера строки в два раза. А сам элемент равен сумме номеров строки и столбца, в котором он находится. Продемонстрируйте работу данного метода.
8.6 Оператор foreach и его использование при работе с массивами 
Оператор foreach применяется для перебора элементов в специальным образом организованной группе данных, в том числе и в массиве. Удобство этого вида цикла заключается в том, что нам не требуется определять количество элементов в группе и выполнять перебор по индексу - мы просто указываем на необходимость перебрать все элементы группы. Синтаксис оператора: 
foreach (<тип> <имя> in <группа>) <тело цикла>
где имя определяет локальную по отношению к циклу переменную, которая будет по очереди принимать все значения из указанной группы, а тип соответствует базовому типу элементов группы.
Ограничением оператора foreach является то, что с его помощью можно только просматривать значения элементов в группе данных, но нельзя их изменять.
Рассмотрим несколько примеров использования оператора foreach:
1.	для работы с одномерными массивами: 
2.	static void PrintArray(string a, int [] mas)
3.	{
4.	  Console.WriteLine(a);
5.	  foreach (int x in mas)Console.Write("{0} ", x);
6.	  Console.WriteLine();
7.	}
8.	для работы с двумерными массивами: 
9.	static int Sum (int [,] mas)
10.	{
11.	  int s=0;
12.	  foreach (int x in mas) s += x;
13.	  return s;
14.	}
15.	для работы со ступенчатыми массивами: 
16.	static void PrintArray3(string a, int[][] mas)
17.	{
18.	  Console.WriteLine(a);
19.	  for (int i = 0; i < mas.Length; i++)
20.	  {
21.	    foreach (int x in mas[i]) Console.Write("{0} ", x);
22.	    Console.WriteLine();
23.	  }
24.	}
Примеры
1.	Дана последовательность целых чисел. Заменить все положительные элементы противоположными им числами. 
Пример 1: для одномерного массива
using System;
namespace ConsoleApplication2
{
  class Class
  {
    static int [] Input ()
    {
      Console.WriteLine("введите размерность массива");
      int n=int.Parse(Console.ReadLine());
      int []a=new int[n];
      for (int i = 0; i < n; ++i) 
      {
        Console.Write("a[{0}]= ", i);
        a[i]=int.Parse(Console.ReadLine());
      }
      return a;
    }

    static void Print(int[] a) 
    {
      for (int i = 0; i < a.Length; ++i) Console.Write("{0} ", a[i]);
      Console.WriteLine();
    }

    static void Change(int[] a)
    {
      for (int i = 0; i < a.Length; ++i)
        if (a[i] > 0) a[i] = -a[i];
    }

    static void Main()
    {
      int[] myArray=Input();
Console.WriteLine("Исходный массив:");
      Print(myArray);
      Change(myArray);
Console.WriteLine("Измененный массив:");
      Print(myArray);
    }
  }
}
Пример 2: для двумерного массива
using System;
namespace ConsoleApplication
{
  class Class
  {
    static int [,] Input (out int n, out int m)
    {
      Console.WriteLine("введите размерность массива");
      Console.Write("n = ");
      n=int.Parse(Console.ReadLine());
      Console.Write("m = ");
      m=int.Parse(Console.ReadLine());
      int [,]a=new int[n, m];
      for (int i = 0; i < n; ++i) 
        for (int j = 0; j < m; ++j)
        {
          Console.Write("a[{0},{1}]= ", i, j);
          a[i, j]=int.Parse(Console.ReadLine());
        }
      return a;
    }

    static void Print(int[,] a) 
    {
      for (int i = 0; i < a.GetLength(0); ++i,Console.WriteLine() )
        for (int j = 0; j < a.GetLength(1); ++j)
          Console.Write("{0,5} ", a[i, j]);
    }

    static void Change(int[,] a)
    {
      for (int i = 0; i < a.GetLength(0); ++i)
        for (int j = 0; j < a.GetLength(1); ++j)
          if (a[i, j] > 0) a[i, j] = -a[i, j];
    }

    static void Main()
    {
      int n,m;
      int[,] myArray=Input(out n, out m);
      Console.WriteLine("Исходный массив:");
      Print(myArray);
      Change(myArray);
      Console.WriteLine("Измененный массив:");
      Print(myArray);
    }
  }
}
2.	Дана последовательность из n действительных чисел. Подсчитать количество максимальных элементов. 
using System;
namespace ConsoleApplication
{
  class Class
  {
    static int [] Input ()
    {
      Console.WriteLine("введите размерность массива");
      int n=int.Parse(Console.ReadLine());
      int []a=new int[n];
      for (int i = 0; i < n; ++i) 
      {
        Console.Write("a[{0}]= ", i);
        a[i]=int.Parse(Console.ReadLine());
      }
      return a;
    }

    static int Max(int[] a)
    {
      int max=a[0];
      for (int i = 1; i < a.Length; ++i)
        if (a[i] > max) max=a[i];
      return max;
    }

    static void Main()
    {
      int[] myArray=Input();
      int max=Max(myArray);
      int kol=0;
      for (int i=0; i<myArray.Length;++i)
        if (myArray[i]==max)++kol;
      Console.WriteLine("Количество максимальных элементов = "+kol);
    }
  }
}
3.	Дан массив размером n×n, элементы которого целые числа. Подсчитать среднее арифметическое нечетных элементов, расположенных выше главной диагонали. 
using System;
namespace ConsoleApplication
{
  class Class
  {
    static int [,] Input (out int n)
    {
      Console.WriteLine("введите размерность массива");
      Console.Write("n = ");
      n=int.Parse(Console.ReadLine());
      int [,]a=new int[n, n];
      for (int i = 0; i < n; ++i) 
        for (int j = 0; j < n; ++j)
        {
          Console.Write("a[{0},{1}]= ", i, j);
          a[i, j]=int.Parse(Console.ReadLine());
        }
      return a;
    }

    static void Print(int[,] a) 
    {
      for (int i = 0; i < a.GetLength(0); ++i,Console.WriteLine() )
        for (int j = 0; j < a.GetLength(1); ++j)
          Console.Write("{0,5} ", a[i, j]);
    }

    static double Rezalt(int[,] a)
    {
      int k=0;
      double s=0;
      for (int i = 0; i < a.GetLength(0); ++i)
        for (int j = i+1; j < a.GetLength(1); ++j)
          if (a[i, j] %2!= 0) {++k; s+=a[i, j];}
      if (k!=0) return s/k;
      else return 0;
    }

    static void Main()
    {
      int n;
      int[,] myArray=Input(out n);
      Console.WriteLine("Исходный массив:");
      Print(myArray);
      double rez=Rezalt(myArray);
      Console.WriteLine("Среднее арифметическое ={0:f2}", rez);
    }
  }
}
4.	Дан массив размером n×n, элементы которого целые числа. Для хранения массив n?n использовать ступенчатый массив.Найти максимальный элемент в каждой строке и записать данные в новый массив. 
using System;
namespace ConsoleApplication
{
  class Class
  {
    static int [][] Input ()
    {
      Console.WriteLine("введите размерность массива");
      Console.Write("n = ");
      int n=int.Parse(Console.ReadLine());
      int [][]a=new int[n][];
      for (int i = 0; i < n; ++i)
      {
        a[i]=new int [n];
        for (int j = 0; j < n; ++j)
        {
          Console.Write("a[{0},{1}]= ", i, j);
          a[i][j]=int.Parse(Console.ReadLine());
        }
      }
      return a;
    }

    static void Print1(int[] a) 
    {
      for (int i = 0; i < a.Length; ++i)
        Console.Write("{0,5} ", a[i]);
    }

    static void Print2(int[][] a) 
    {
      for (int i = 0; i < a.Length; ++i,Console.WriteLine() )
        for (int j = 0; j < a[i].Length; ++j)
          Console.Write("{0,5} ", a[i][j]);
    }

    static int Max(int[] a)
    {
      int max=a[0];
      for (int i = 1; i < a.Length; ++i)
        
        if (a[i] >max) {max=a[i];}
      return max;
    }

    static void Main()
    {
      int[][] myArray=Input();
      Console.WriteLine("Исходный массив:");
      Print2(myArray);
      int[]rez=new int [myArray.Length];
      for (int i=0;i<myArray.Length; ++i)
        rez[i]=Max(myArray[i]);
      Console.WriteLine("Новый массив:");
      Print1(rez);
    }
  }
}
Самостоятельная работа
Вставка и удаление элементов в массивах
При объявлении массива мы определяем его максимальную размерность, которая в дальнейшем изменена быть не может. Однако с помощью вспомогательной переменной можно контролировать текущее количество элементов, которое не может быть больше максимального. 
Замечание. В пространстве имен System.Collection реализована коллекция ArrayList - массив, динамически изменяющий свой размер. Мы будем рассматривать его позже.
Пример. Рассмотрим фрагмент программы:
int []a=new int [10];
int n=5;
for (int i=0; i<5;i++) a[i]:=i*i;

В этом случае массив можно представить следующим образом:
n=5	0	1	2	3	4	5	6	7	8	9
а 	0	1	4	9	16	0 	0	0	0	0
Так как во время описания был определен массив из 10 элементов, а заполнено только первые 5, то оставшиеся элементы будут заполнены нулями.
Что значит удалить из одномерного массива элемент с номером 3? Удаление должно привести к физическому "уничтожению" элемента с номером 3 из массива, при этом общее количество элементов должно быть уменьшено. В этом понимании удаления элемента итоговый массив должен выглядеть следующем образом
	0	1	2	4	5	6	7	8	9	недопустимое состояние
а 	0	1	4	16	0	0	0	0	0	
Такое удаление для массивов невозможно, поскольку элементы массива располагаются в памяти последовательно друг за другом, что позволяет организовать индексный способ обращения к массиву. 
Однако "удаление" можно смоделировать сдвигом элементов влево и уменьшением значения переменной, которая отвечает за текущее количество элементов в массиве, на единицу:
n=4	0	1	2	3	4	5	6	7	8	9
а 	0	1	4	16	0	0	0	0	0	0
В общем случае, если мы хотим удалить элемент массива с номером k (всего в массиве n элементов, а последний элемент имеет индекс n-1), то нам необходимо произвести сдвиг элементов, начиная с k+1-го на одну позицию влево. Т.е. на k-ое место поставить k+1-й элемент, на место k+1 - k+2-й элемент, …, на место n-2 - n-1-й элемент. После чего значение n уменьшить на 1. В этом случае размерность массива не изменится, изменится лишь текущее количество элементов, и у нас создастся ощущение, что элемент с номером k удален. Рассмотрим данный алгоритм на примере:
using System;
namespace ConsoleApplication
{
  class Class
  {
    static int [] Input ()
    {
      Console.WriteLine("введите размерность массива");
      int n=int.Parse(Console.ReadLine());
      int []a=new int[n];
      for (int i = 0; i < n; ++i) 
      {
        Console.Write("a[{0}]= ", i);
        a[i]=int.Parse(Console.ReadLine());
      }
      return a;
    }

    static void Print(int[] a, int n) 
    {
      for (int i = 0; i < n; ++i) Console.Write("{0} ", a[i]);
      Console.WriteLine();
    }

    static void DeleteArray(int[] a, ref int n, int m)
    {
      for (int i = m; i < n-1; ++i)
        a[i] = a[i+1];
      --n;
    }

    static void Main()
    {
      int[] myArray=Input();
      int n=myArray.Length;
      Console.WriteLine("Исходный массив:");
      Print(myArray, n);
      Console.WriteLine("Введите номер элемента для удаления:");
      int m=int.Parse(Console.ReadLine());
DeleteArray(myArray, ref n,m);
      Console.WriteLine("Измененный массив:");
      Print(myArray, n);
    }
  }
}
Задание. Подумайте, какие исключительные ситуации могут возникнуть в данной программе и добавьте в нее соответствующие обработки исключительных ситуаций
Рассмотрим теперь операцию удаления в двумерном массиве. Размерность двумерного массива также зафиксирована на этапе объявления массива. Однако при необходимости можно "смоделировать" удаление целой строки в массиве, выполняя сдвиг всех строк, начиная с k-той на единицу вверх. В этом случае размерность массива не изменится, а текущее количество строк будет уменьшено на единицу. В качестве примера удалим из двумерного массива, строку с номером k.
using System;
namespace ConsoleApplication
{
  class Class
  {
    static int [,] Input (out int n, out int m)
    {
      Console.WriteLine("введите размерность массива");
      Console.Write("n = ");
      n=int.Parse(Console.ReadLine());
      Console.Write("m = ");
      m=int.Parse(Console.ReadLine());
      int [,]a=new int[n, m];
      for (int i = 0; i < n; ++i) 
        for (int j = 0; j < m; ++j)
        {
          Console.Write("a[{0},{1}]= ", i, j);
          a[i, j]=int.Parse(Console.ReadLine());
        }
      return a;
    }

    static void Print(int[,] a, int n, int m) 
    {
      for (int i = 0; i < n; ++i,Console.WriteLine() )
        for (int j = 0; j < m; ++j)
          Console.Write("{0,5} ", a[i, j]);
    }

    static void DeleteArray(int[,] a, ref int n, int m, int k)
    {
      for (int i = k; i < n-1; ++i)
        for (int j = 0; j < m; ++j)
          a[i, j] = a[i+1, j];
      --n;
    }

    static void Main()
    {
      int n,m;
      int[,] myArray=Input(out n, out m);
      Console.WriteLine("Исходный массив:");
      Print(myArray, n, m);
      Console.WriteLine("Введите номер строки для удаления:");
      int k=int.Parse(Console.ReadLine());
      DeleteArray(myArray, ref n, m, k);
      Console.WriteLine("Измененный массив:");
      Print(myArray, n, m);
    }
  }
Задания. 
1.	Подумайте, какие исключительные ситуации могут возникнуть в данной программе и добавьте в нее соответствующие обработки исключительных ситуаций. 
2.	Измените программу так, чтобы она удаляла k-тый столбец в двумерном массиве. 
Рассмотрим модификацию предыдущей программы, для случая, когда используется ступенчатый массив.
using System;
namespace ConsoleApplication
{
  class Class
  {
    
    static int [][] Input (out int n, out int m)
    {
      Console.WriteLine("введите размерность массива");
      Console.Write("n = ");
      n=int.Parse(Console.ReadLine());
      Console.Write("m = ");
      m=int.Parse(Console.ReadLine());
      int [] []a=new int[n][];
      for (int i = 0; i < n; ++i)
      {
        a[i]=new int[m];
        for (int j = 0; j < m; ++j)
        {
          Console.Write("a[{0},{1}]= ", i, j);
          a[i][j]=int.Parse(Console.ReadLine());
        }
      }
      return a;
    }

    static void Print(int[][] a, int n, int m) 
    {
      for (int i = 0; i < n; ++i,Console.WriteLine() )
        for (int j = 0; j < m; ++j)
          Console.Write("{0,5} ", a[i] [j]);
    }

    static void DeleteArray(int[][] a, ref int n, int k)
    {
      for (int i = k; i < n-1; ++i)//производим сдвиг ссылок
        a[i] = a[i+1];
      --n;
    }

    static void Main()
    {
      int n,m;
      int[][] myArray=Input(out n, out m);
      Console.WriteLine("Исходный массив:");
      Print(myArray, n, m);
      Console.WriteLine("Введите номер строки для удаления:");
      int k=int.Parse(Console.ReadLine());
      DeleteArray(myArray, ref n, k);
      Console.WriteLine("Измененный массив:");
      Print(myArray, n, m);
    }
  }
}

Вернемся к массиву, определенному в самом первом примере. И подумаем теперь, что значит добавить элемент в одномерный массив в позицию с номером k? В этом случае все элементы, начиная с k-ого, должны быть сдвинуты вправо на одну позицию. Однако сдвиг нужно начинать с конца, т.е. на первом шаге на n-е место поставить n-1-ый элемент, потом на n-1-ое место поставить n-2-й элемент, …, наконец, на k+1 место вставить k-й элемент. Таким образом, копия k-го элемента будет на k+1-м месте и на k-е место можно поставить новый элемент. Затем необходимо увеличить текущее количество элементов на 1. 
Рассмотрим массив из примера 1 и в качестве k зададим значение равное 3. В этом случае массив будет выглядеть следующим образом: 
k=3	0	1	2	3	4	5	6	7	8	9
а 	0	1	4	9	9	16	0	0	0	0
Теперь в позицию с номером 3 можно поместить новое значение. А текущее количество элементов в массиве становится равным 6. Подумайте, почему сдвиг нужно выполнять с конца массива, а не с начала, как мы это делали в случае удаления элемента из массива.
Рассмотрим программную реализацию данного алгоритма:
using System;
namespace ConsoleApplication
{
  class Class
  {
    static int [] Input (out int n)
    {
      Console.WriteLine("введите размерность массива");
      n=int.Parse(Console.ReadLine());
      int []a=new int[2*n]; //выделяем памяти больше чем требуется
      for (int i = 0; i < n; ++i) 
      {
        Console.Write("a[{0}]= ", i);
        a[i]=int.Parse(Console.ReadLine());
      }
      return a;
    }

    static void Print(int[] a, int n) 
    {
      for (int i = 0; i < n; ++i) Console.Write("{0} ", a[i]);
      Console.WriteLine();
    }

    static void AddArray(int[] a, ref int n, int m)
    {
      for (int i = n; i >= m; --i)
        a[i] = a[i-1];
      ++n;
      Console.WriteLine("Введите значение нового элемента");
      a[m]=int.Parse(Console.ReadLine());
    }

    static void Main()
    {
      int n;
      int[] myArray=Input(out n);
      Console.WriteLine("Исходный массив:");
      Print(myArray, n);
      Console.WriteLine("Введите номер элемента для вставки:");
      int m=int.Parse(Console.ReadLine());
      AddArray(myArray, ref n,m);
      Console.WriteLine("Измененный массив:");
      Print(myArray, n);
    }
  }
}
Теперь рассмотрим добавление строки в двумерный массив. Для этого все строки после строки с номером k передвигаем на 1 строку вниз. Затем увеличиваем количество строк на 1. После этого копия строки с номером k будет находиться в столбце с номером k+1. И, следовательно, k-тый столбец можно заполнить новыми значениями. Рассмотрим программную реализацию алгоритма:
using System;
namespace ConsoleApplication
{
  class Class
  {
    
    static int [,] Input (out int n, out int m)
    {
      Console.WriteLine("введите размерность массива");
      Console.Write("n = ");
      n=int.Parse(Console.ReadLine());
      Console.Write("m = ");
      m=int.Parse(Console.ReadLine());
//выделяем памяти больше чем необходимо
      int [,]a=new int[2*n, m]; 
      for (int i = 0; i < n; ++i) 
        for (int j = 0; j < m; ++j)
        {
          Console.Write("a[{0},{1}]= ", i, j);
          a[i, j]=int.Parse(Console.ReadLine());
        }
      return a;
    }


    static void Print(int[,] a, int n, int m) 
    {
      for (int i = 0; i < n; ++i,Console.WriteLine() )
        for (int j = 0; j < m; ++j)
          Console.Write("{0,5} ", a[i, j]);
    }

    static void AddArray(int[,] a, ref int n, int m, int k)
    {
      for (int i = n; i >=k; --i)
        for (int j = 0; j < m; ++j)
          a[i+1, j] = a[i, j];
      ++n;
      Console.WriteLine("Введите элементы новой строки");
      for (int j=0; j<m;++j)
      {
        Console.Write("a[{0},{1}]=", k, j);
        a[k, j]=int.Parse(Console.ReadLine());
      }
    }

    static void Main()
    {
      int n,m;
      int[,] myArray=Input(out n, out m);
      Console.WriteLine("Исходный массив:");
      Print(myArray, n, m);
      Console.WriteLine("Введите номер строки для добавления:");
      int k=int.Parse(Console.ReadLine());
      AddArray(myArray, ref n, m, k);
      Console.WriteLine("Измененный массив:");
      Print(myArray, n, m);
    }
  }
}
Задания. 
1.	Подумайте, какие исключительные ситуации могут возникнуть в данной программе и добавьте в нее соответствующие обработки исключительных ситуаций. 
2.	Измените программу так, чтобы она добавляла k-тый столбец в двумерном массиве. 
Рассмотрим модификацию предыдущей программы для случая, когда используется ступенчатый массив. 
using System;
namespace ConsoleApplication
{
  class Class
  {
    
    static int [][] Input (out int n, out int m)
    {
      Console.WriteLine("введите размерность массива");
      Console.Write("n = ");
      n=int.Parse(Console.ReadLine());
      Console.Write("m = ");
      m=int.Parse(Console.ReadLine());
//выделяем памяти больше чем неообходимо
      int [][]a=new int[2*n][]; 
      for (int i = 0; i < n; ++i)
      {
        a[i]=new int [m];
        for (int j = 0; j < m; ++j)
        {
          Console.Write("a[{0}][{1}]= ", i, j);
          a[i][j]=int.Parse(Console.ReadLine());
        }
      }
      return a;
    }

    static void Print(int[][] a, int n, int m) 
    {
      for (int i = 0; i < n; ++i,Console.WriteLine() )
        for (int j = 0; j < m; ++j)
          Console.Write("{0,5} ", a[i][j]);
    }

    static void AddArray(int[][] a, ref int n, int m, int k)
    {
      for (int i = n; i >=k; --i)//выполняем сдвиг ссылок
        a[i+1] = a[i];
      ++n;
      a[k]=new int[m]; //создаем новую строку
      Console.WriteLine("Введите элементы новой строки");
      for (int j=0; j<m;++j)
      {
        Console.Write("a[{0}][{1}]=", k, j);
        a[k][j]=int.Parse(Console.ReadLine());
      }
    }

    static void Main()
    {
      int n,m;
      int[][] myArray=Input(out n, out m);
      Console.WriteLine("Исходный массив:");
      Print(myArray, n, m);
      Console.WriteLine("Введите номер строки для добавления:");
      int k=int.Parse(Console.ReadLine());
      AddArray(myArray, ref n, m, k);
      Console.WriteLine("Измененный массив:");
      Print(myArray, n, m);
    }
  }
}

Практические задания
1.	В одномерном массиве, элементы которого - целые числа, произвести следующие действия: 
1.	Удалить из массива все четные числа. 
2.	Вставить новый элемент после всех элементов, которые заканчиваются на данную цифру. 
3.	Удалить из массива повторяющиеся элементы, оставив только их первые вхождения. 
4.	Вставить новый элемент между всеми парами элементов, имеющими разные знаки. 
5.	Уплотнить массив, удалив из него все нулевые значения. 
2.	В двумерном массиве, элементы которого - целые числа, произвести следующие действия: 
1.	Вставить новую строку после строки, в которой находится первый встреченный минимальный элемент. 
2.	Вставить новый столбец перед всеми столбцами, в которых встречается заданное число. 
3.	Удалить все строки, в которых нет ни одного четного элемента. 
4.	Удалить все столбцы, в которых все элементы положительны. 
5.	Удалить из массива k-тую строку и j-тый столбец, если их значения совпадают. 
6.	Уплотнить массив, удалив из него все нулевые строки и столбцы
 
Лекция 9. Символы и строки
Обработка текстовой информации является одной из самых распространенных задач современного программировании. С# предоставляет для ее решения широкий набор средств: символы char, неизменяемые строки string, изменяемые строки StringBuider и регулярные выражения Regex. В данном разделе мы рассмотрим работу с символами, неизменяемыми и изменяемыми строками.
9.1 Символы char
Символьный тип char предназначен для хранения символа в кодировке Unicode. Символьный тип относится к встроенным типам данных С# и соответствует стандартному классу Сhar библиотеки .Net из пространства имен System. В этом классе определены статические методы, позволяющие задавать вид и категорию символа, а также преобразовывать символ в верхний или нижний регистр, в число. Рассмотрим основные методы:
Метод	Описание 
GetNumericValue	Возвращает числовое значение символа, если он является цифрой, и -1 в противном случае.
GetUnicodeCategory	Возвращает категорию Unicode-символа. В Unicode символы разделены на категории, например цифры (DecimalDigitNumber), римские цифры (LetterNumber), разделители строк (LineSeparator), буквы в нижнем регистре (LowercaseLetter) и т.д. 
IsControl	Возвращает true, если символ является управляющим.
IsDigit	Возвращает true, если символ является десятичной цифрой.
IsLetter	Возвращает true, если символ является буквой.
IsLetterOrDigit	Возвращает true, если символ является буквой или десятичной цифрой.
IsLower	Возвращает true, если символ задан в нижнем регистре.
IsNumber	Возвращает true, если символ является числом (десятичным или шестнадцатеричным).
IsPunctuation	Возвращает true, если символ является знаком препинания.
IsSeparator	Возвращает true, если символ является разделителем.
IsUpper	Возвращает true, если символ задан в верхнем регистре.
IsWhiteSpace	Возвращает true, если символ является пробельным (пробел, перевод строки, возврат каретки).
Parse	Преобразует строку в символ (строка должна состоять из одного символа).
ToLower	Преобразует символ в нижний регистр
ToUpper	Преобразует символ в верхний регистр
В следующем примере рассмотрим применение данных методов:
static void Main()
{
 try
 {
  char b = 'B', c = '\x64', d = '\uffff';
  Console.WriteLine("{0}, {1}, {2}", b, c, d);
  Console.WriteLine("{0}, {1}, {2}", char.ToLower(b), char.ToUpper(c), char.GetNumericValue(d));
  char a;
  do	//цикл выполнятеся до тех пор, пока не ввели символ e
  {
   Console.WriteLine("Введите символ: ");
   a = char.Parse(Console.ReadLine());
   Console.WriteLine("Введен символ {0}, его код  {1}, его категория {2}", a,       
                      (int)a, char.GetUnicodeCategory(a));
   if (char.IsLetter(a)) Console.WriteLine("Буква");
   if (char.IsUpper(a)) Console.WriteLine("Верхний регистр");
   if (char.IsLower(a)) Console.WriteLine("Нижний регистр");
   if (char.IsControl(a)) Console.WriteLine("Управляющий символ");
   if (char.IsNumber(a)) Console.WriteLine("Число");
   if (char.IsPunctuation(a)) Console.WriteLine("Разделитель");
  } while (a != 'e');
 }
 catch
 {
  Console.WriteLine("Возникло исключение");
 }
}
Используя символьный тип можно оргранизовать массив символов и работать с ним на основе базового класса Array:
static void Main()
{
 char[] a ={ 'm', 'a', 'Х',  'i', 'M', 'u', 'S' , '!', '!', '!' };
 char [] b="кол около колокола".ToCharArray(); //преобразование строки в массив символов
 PrintArray("Исходный массив а:", a);
 for (int x=0;x<a.Length; x++)
 if (char.IsLower(a[x])) a[x]=char.ToUpper(a[x]);
 PrintArray("Измененный массив а:", a);
 PrintArray("Исходный массив b:", b);
 Array.Reverse(b);
 PrintArray("Измененный массив b:", b);
}

static void PrintArray(string line, Array a)
{
 Console.WriteLine(line);
 foreach( object x in a) Console.Write(x);
 Console.WriteLine('\n');
}
Задание. Измените программу так, чтобы в ней подсчитывалось количество знаков пунктуации в массиве a.
9.2 Неизменяемые строки string
Тип string, предназначенный для работы со строками символов в кодировке Unicode, является встроенным типом С#. Ему соответствует базовый тип класса System.String библиотеки .Net. Каждый объект string - это неизменяемая последовательность символов Unicode, т.е. методы, предназначенные для изменения строк, возвращают измененные копии, исходные же строки остаются неизменными.
Создать строку можно несколькими способами:
1.	string s; 	// инициализация отложена
2.	string s=''кол около колокола''; 	//инициализация строковым литералом
3.	string s=@'Привет!'	//символ @ сообщает конструктору string, что строку 
4.	Сегодня хорошая погода!!! '' // нужно воспринимать буквально, даже если она занимает 
5.	//несколько строк
6.	
7.	string s=new string (' ', 20); 	//конструктор создает строку из 20 пробелов 
8.	int x = 12344556;			//инициализировали целочисленную переменную
9.	string s = x.ToString();		//преобразовали ее к типу string
10.	
11.	char [] a={'a', 'b', 'c', 'd', 'e'};	//создали массив символов
12.	string v=new string (a);		// создание строки из массива символов
13.	
14.	char [] a={'a', 'b', 'c', 'd', 'e'};
15.	// создание строки из части массива символов, при этом:  0 
16.	string v=new string (a, 0, 2)	
17.	// показывает с какого символа, 2 - сколько символов 
18.	// использовать для инициализации
19.	
20.	
Класс string обладает богатым набором методов для сравнения строк, поиска в строке и других действий со строками. Рассмотрим эти методы.
Название	Вид	Описание
Compare	Статический метод	Сравнение двух строк в лексикографическом (алфавитном) порядке. Разные реализации метода позволяют сравнивать строки с учетом или без учета регистра.
CompareTo	Метод	Сравнение текущего экземпляра строки с другой строкой.
Concat	Статический метод	Слияние произвольного числа строк.
Copy	Статический метод	Создание копии строки
Empty	Статическое поле	Открытое статическое поле, представляющее пустую строку
Format	Статический метод	Форматирование строки в соответствии с заданным форматом
IndexOf, IndexOfAny, LastIndexOf, LastIndexOfAny	Экземплярные методы	Определение индексов первого и последнего вхождения заданной подстроки или любого символа из заданного набора в данную строку.
Insert	Экземплярный метод	Вставка подстроки в заданную позицию
Join	Статический метод	Слияние массива строк в единую строку. Между элементами массива вставляются разделители.
Length	Свойство 	Возвращает длину строки
PadLeft, PadRigth	Экземплярные методы	Выравнивают строки по левому или правому краю путем вставки нужного числа пробелов в начале или в конце строки.
Remove	Экземплярный метод	Удаление подстроки из заданной позиции
Replace	Экземплярный метод	Замена всех вхождений заданной подстроки или символа новыми подстрокой или символом.
Split	Экземплярный метод	Разделяет строку на элементы, используя разные разделители. Результаты помещаются в массив строк.
StartWith, EndWith	Экземплярные методы	Возвращают true или false в зависимости от того, начинается или заканчивается строка заданной подстрокой.
Substring	Экземплярный метод	Выделение подстроки, начиная с заданной позиции
ToCharArray	Экземплярный метод	Преобразует строку в массив символов
ToLower, ToUpper	Экземплярные методы	Преобразование строки к нижнему или верхнему регистру
Trim, TrimStart, TrimEnd	Экземплярные методы	Удаление пробелов в начале и конце строки или только с одного ее конца.
Напоминаем, что вызов статических методов происходит через обращение к имени класса, например, String.Concat(str1, str2), в остальных случаях через обращение к экземплярам класса, например, str.ToLower(). На примере рассмотрим использование данных свойств и методов.
static void Main()
{
 string str1 ="Первая строка";
 string str2 = string.Copy(str1);
 string str3 = "Вторая строка";
 string str4 = "ВТОРАЯ строка";
 string strUp, strLow;
 int result, idx;
 Console.WriteLine("str1: " + str1);
 Console.WriteLine("Длина строки str1: " +str1.Length);
 
 // Создаем прописную и строчную версии строки str1.
 strLow = str1.ToLower();
 strUp = str1.ToUpper();
 Console.WriteLine("Строчная версия строки str1: " +strLow);
 Console.WriteLine("Прописная версия строки str1: " +strUp);
 Console.WriteLine();
 
 // Сравниваем строки,
 result = str1.CompareTo(str3);
 if (result == 0) Console.WriteLine("str1 и str3 равны.");
 else if (result < 0) Console.WriteLine("str1 меньше, чем str3");
 else Console.WriteLine("str1 больше, чем str3");
 Console.WriteLine();
 
 //сравниваем строки без учета регистра
 result = String.Compare(str3,str4,true);
 if (result == 0) Console.WriteLine("str3 и str4 равны без учета регистра.");
 else Console.WriteLine("str3 и str4 не равны без учета регистра.");
 Console.WriteLine();
 
 //сравниваем части строк
 result = String.Compare(str1, 4, str2, 4, 2);
 if (result == 0)  Console.WriteLine("часть str1 и str2 равны");
 else  Console.WriteLine("часть str1 и str2 не равны");
 Console.WriteLine();
 
 // Поиск строк.
 idx = str2.IndexOf("строка");
 Console.WriteLine("Индекс первого вхождения подстроки сторка: " + idx);
 idx = str2.LastIndexOf("о");
 Console.WriteLine("Индекс последнего вхождения символа о: " + idx);

 //конкатенация
 string str=String.Concat(str1, str2, str3, str4);
 Console.WriteLine(str);
 
 //удаление подстроки
 str=str.Remove(0,str1.Length);
 Console.WriteLine(str);
 
 //замена подстроки "строка" на пустую подстроку
 str=str.Replace("строка","");
 Console.WriteLine(str);
}
Очень важными методами обработки строк, являются методы разделения строки на элементы Split и слияние массива строк в единую строку Join.
static void Main()
{
 string poems = "тучки небесные вечные странники";
 char[] div = { ' '}; //создаем массив разделителей
 // Разбиваем строку на части,
 string[] parts = poems.Split(div);
 Console.WriteLine("Результат разбиения строки на части: ");
 for (int i = 0; i < parts.Length; i++)
 Console.WriteLine(parts[i]);
 // Теперь собираем эти части в одну строку, в качестве разделителя используем символ |
 string whole = String.Join(" | ", parts);
 Console.WriteLine("Результат сборки: ");
 Console.WriteLine(whole);
}
Задание. Измените программу так, чтобы слова в предложении записывались в обратном порядке.
В общем случае строка может содержать и другие разделители:
static void Main()
{
 string poems = "Тучки небесные, вечные странники...";
 char[] div = { ' ', ',', '.'}; //создаем массив разделителей
 // Разбиваем строку на части,
 string[] parts = poems.Split(div);
 Console.WriteLine("Результат разбиения строки на части: ");
 for (int i = 0; i < parts.Length; i++)
 Console.WriteLine(parts[i]);
 // Теперь собираем эти части в одну строку,
 string whole = String.Join(" | ", parts);
 Console.WriteLine("Результат сборки: ");
 Console.WriteLine(whole);
}
Задания. 
1.	Объясните, почему в массиве строк parts появились пустые строки. 
2.	Внесите изменения в программу так, чтобы пустых строк не было. 
Рассмотрим другой пример - используя метод Split вводить двумерный массив можно не поэлементно, а построчно:
static void Main()
{
 try
 {
  int[][] MyArray;
  Console.Write("введите количество строк: ");
  int n = int.Parse(Console.ReadLine());
  MyArray = new int[n][];
  for (int i = 0; i < MyArray.Length; i++)
  {
   string line = Console.ReadLine();
   string[] mas = line.Split(' ');
   MyArray[i] = new int[mas.Length];
   for (int j = 0; j < MyArray[i].Length; j++)
   {
    MyArray[i][j] = int.Parse(mas[j]);
   }
  }
  PrintArray("исходный массив:", MyArray);
  for (int i = 0; i < MyArray.Length; i++) Array.Sort(MyArray[i]);
  PrintArray("итоговый массив", MyArray);
 }
 catch 
 {
  Console.WriteLine("возникло исключение");
 }
}
 
static void PrintArray(string a, int[][] mas)
{
 Console.WriteLine(a);
 for (int i = 0; i < mas.Length; i++)
 {
  foreach (int x in mas[i]) Console.Write("{0} ", x);
  Console.WriteLine();
 }
}
В этом примере могут возникнуть исключительные ситуации, если введенная строка элементов массива будет содержать лишние пробелы. Следовательно, от этих пробелов нужно избавиться:
static void Main()
{
 try
 {
  int[][] MyArray;
  Console.Write("введите количество строк: ");
  string line= Console.ReadLine()
  int n = int.Parse(line.Trim());
  MyArray = new int[n][];
  for (int i = 0; i < MyArray.Length; i++)
  {
   line = Console.ReadLine();
   line=line.Trim();	//удалаяем пробелы в начале и конце строки 
   //удаляем линшие пробелы внутри строки 
   n = line.IndexOf("  ");
   while (n > 0)
   {
    line = line.Remove(n, 1);
    n = line.IndexOf("  ");
   }          
   string[] mas = line.Split(' ');
   MyArray[i] = new int[mas.Length];
   for (int j = 0; j < MyArray[i].Length; j++)
   {
    MyArray[i][j] = int.Parse(mas[j]);
   }
  }
  PrintArray("исходный массив:", MyArray);
  for (int i = 0; i < MyArray.Length; i++) Array.Sort(MyArray[i]);
  PrintArray("итоговый массив", MyArray);
 }
 catch 
 {
  Console.WriteLine("возникло исключение");
 }
}
 
static void PrintArray(string a, int[][] mas)
{
 Console.WriteLine(a);
 for (int i = 0; i < mas.Length; i++)
 {
  foreach (int x in mas[i]) Console.Write("{0} ", x);
  Console.WriteLine();
 }
}
Задание. Объясните, можно ли удалить внутри строки лишние пробелы, используя метод Replace. Например, следующим способом str.Replace(" ", " "), где мы пытаемся заменить подстроку состоящую из двух, на подстроку из одиного пробела.
При работе с объектами класса string нужно учитывать их свойство неизменяемости, т.е. тот факт, что методы изменяют не сами строки, а их копии. Рассмотрим фрагмент программы:
 string a="";
 for (int i = 1; i <= 100; i++) a +="!";
 Console.WriteLine(a);
В этом случае в памяти компьютера будет сформировано 100 различных строк вида:
!
!!
!!!
…
!!!...!! 
И только последняя строка будет храниться в переменной а. Ссылки на все остальные строчки будут потеряны, но эти строки будут храниться в памяти компьютера и засорять память. Боротся с таким засорением придется сборщику мусора, что будет сказываться на производительности программы. Поэтому если нужно изменять строку, то лучше пользоваться классом StringBuilder. 
9.3 Изменяемые строки
Чтобы создать строку, которую можно изменять, в С# предусмотрен класс StringBuilder, определенный в пространстве имен System.Text. Объекты этого класса всегда объявляются с явным вызовом конструктора класса (через операцию new) . Примеры создания изменяемых строк:
StringBuilder a =new StringBuilder();	//создание пустой строки, размер по умолчанию 16 символов
//инициализация строки и выделение необходимой памяти
StringBuilder b = new StringBuilder("abcd"); 
//создание пустой строки и выделение памяти под 100 символов
StringBuilder с = new StringBuilder(100);
//инициализация строки и выделение памяти под 100 символов 
StringBuilder d = new StringBuilder("abcd", 100);
//инициализация подстрокой "bcd", и выделение памяти под 100 символов	
StringBuilder d = new StringBuilder("abcd", 1, 3,100);  
Основные элементы класса приведены в таблице:
Название	Вид	Описание
Append	Экземплярный метод	Добавление данных в конец строки. Разные варианты метода позволяют добавлять в строку величины любых встроенных типов, массивы символов, строки и подстроки string.
AppendFormat	Экземплярный метод	Добавление форматированной строки в конец строки
Capacity	свойство	Получение и установка емкости буфера. Если устанавливаемое значение меньше текущей длины строки или больше максимального, то генерируется исключение ArgumentOutOfRangeException
Insert	Экземплярный метод	Вставка подстроки в заданную позицию
Length	изменяемое свойство	Возвращает длину строки. Присвоение ему значения 0 сбрасывает содержимое и очищает строку
MaxCapacity	неизменное свойство	Возвращает наибольшее количество символов, которое может быть размещено в строке
Remove	Экземплярный метод	Удаление подстроки из заданной позиции
Replace	Экземплярный метод	Замена всех вхождений заданной подстроки или символа новой подстрокой или символом
ToString	Экземплярный метод 	Преобразование в строку типа string
Chars	изменяемое свойство	Возвращает из массива или устанавливает в массиве символ с заданным индексом. Вместо него можно пользоваться квадратными скобками []
Equals	Экземплярный метод	Возвращает true, только если объекты имеют одну и ту же длину и состоят из одних и тех же символов
CopyTo	Экземплярный метод	Копирует подмножество символов строки в массив char
Как видим, методы класса StringBuilder менее развиты, чем методы класса String, но они позволяют более эффективно использовать память за счет работы с изменяемыми строками. Рассмотрим примеры использования данных методов.
static void Main()
{
 try
 { 
  StringBuilder str=new StringBuilder("Площадь");
  PrintString(str);
  str.Append(" треугольника равна");	
  PrintString(str);
  str.AppendFormat(" {0:f2} см ", 123.456);	
  PrintString(str);
  str.Insert(8, "данного ");
  PrintString(str);
  str.Remove(7, 21);
  PrintString(str);
  str.Replace("а", "о");
  PrintString(str);
  StringBuilder str1=new StringBuilder(Console.ReadLine());
  StringBuilder str2=new StringBuilder(Console.ReadLine());
  Console.WriteLine(str1.Equals(str2));
 }
 catch 
 {
 	Console.WriteLine("Вознико исключение");
 }
}

static void PrintString(StringBuilder a)
{
 Console.WriteLine("Строка: "+a);
 Console.WriteLine("Текущая длина строки " +a.Length);
 Console.WriteLine("Объем буфера "+a.Capacity);
 Console.WriteLine("Максимальный объем буфера "+a.MaxCapacity);
 Console.WriteLine();
}
Задание. Самостоятельно изучите метод CopyTo.
С изменяемой строкой можно работать не только как с объектом, но как с массивом символов:
static void Main()
{
 StringBuilder a = new StringBuilder("2*3=3*2");
 Console.WriteLine(a);
 int k=0;
 for (int i = 0; i < a.Length; ++i )
 if (char.IsDigit(a[i])) k+=int.Parse(a[i].ToString());
 Console.WriteLine(k);
}
На практике часто комбинируют работу с изменяемыми и неизменяемыми строками. Однако если необходимо изменять строку, то в этом случае используют StringBuilder.
Пример. Дана строка, в которой содержится осмысленное текстовое сообщение. Слова сообщения разделяются пробелами и знаками препинания. Вывести все слова сообщения, которые начинаются и заканчиваются на одну и ту же букву.
static void Main()
{
 Console.WriteLine("Введите строку: ");
 StringBuilder a = new StringBuilder(Console.ReadLine());
 Console.WriteLine("Исходная строка: "+a);
 for (int i=0; i<a.Length;)
 if (char.IsPunctuation(a[i])) a.Remove(i,1);
 else ++i;
 string str=a.ToString();
 string []s=str.Split(' ');
 Console.WriteLine("Искомые слова: ");
 for (int i=0; i<s.Length; ++i)
 if (s[i][0]==s[i][s.Length-1]) Console.WriteLine(s[i]);
}
Задание. Измените программу так, чтобы она корректно работала и для случая, когда в исходной строке встречаются лишние пробелы.
Практикум
Замечание. При решении задач следует руководствоваться правилом: если в строке должны производится изменения, то лучше пользоваться классом StringBuilder; если необходимо разбивать строки на слова, то классом String. При решении некоторых задач, потребуется использовать оба класса. 
1.	Разработать программу, которая для заданной строки s вставляет символ x после каждого вхождения символа y; 
using System;
using System.Text;

namespace ConsoleApplication
{
 class Class
 {
  static void Main()
  {
   Console.WriteLine("Введите строку: ");
   StringBuilder a = new StringBuilder(Console.ReadLine());
   Console.WriteLine("Исходная строка: "+a);
   Console.WriteLine("Введите символ x: ");
   char x=char.Parse(Console.ReadLine());
   Console.WriteLine("Введите символ y: ");
   char y=char.Parse(Console.ReadLine());
   for (int i=0; i<a.Length; ++i)
    if (a[i]==x){a.Insert(i+1,y); ++i;}
   Console.WriteLine("Измененная строка: "+a);
   }
 }
}
 
2.	Дана строка, в которой содержится осмысленное текстовое сообщение. Слова сообщения разделяются пробелами и знаками препинания. Вывести только те слова сообщения, в которых содержится заданная подстрока. 
using System;
using System.Text;

namespace ConsoleApplication
{
 class Class
 {
  static void Main()
  {
   Console.WriteLine("Введите строку: ");
   StringBuilder a = new StringBuilder(Console.ReadLine());
   Console.WriteLine("Исходная строка: "+a);
   Console.WriteLine("Введите заданную подстроку: ");
   string x=Console.ReadLine();
   for (int i=0; i<a.Length;)
    if (char.IsPunctuation(a[i]))a.Remove(i,1);
    else ++i;
   string str=a.ToString();
   str=str.Trim();
   string []s=str.Split(' ');
   Console.WriteLine("Искомые слова: ");
   for (int i=0; i<s.Length; ++i)
    if (s[i].IndexOf(x)!=-1) Console.WriteLine(s[i]);
  }
 }
}
Самостоятельная работа. Работа с командной строкой.
Компиляция программы из командной строки
1.	Создайте новый проект или откройте старый, который выводит на экран сообщение: 
2.	"Привет!"
3.	Сохраните исходный текст программы на диск D в папку Temp c именем Program.cs 
Вариант 1
1.	Выполните последовательность действий: Пуск - Все программы - Microsoft Visual Studio 2005 - Visual Studio 2005 Tools - Visual Studio 2005 Command Prompt 
2.	Откроется консольное окно: 
 
Вариант 2
1.	Выполните последовательность действий: Пуск - Все программы - Microsoft .Net Framwork SDK v2.0 - SDK Command Prompt 
2.	Откроется консольное окно: 
 
Замечание. Далее мы будем работать с командным окном SDK Command Prompt
3.	В командной строке окна запишите следующую команду: 
4.	csc  /out:d:\temp\hello.exe  d:\temp\Program.cs
где csc - команда компиляции исполняемого файла
/out - определяет местоположение и название скомпилированного файла, в нашем случае исполняемый файл называется hello.exe и будет располагаться в папке temp диска d.
d:\temp\Program.cs - определяет местоположение и название исходного файла.
5.	Для выполнения команды нажмите клавишу Enter: 
 
Замечание. В данном случае компиляция прошла успешно. В противном случае на экране будет выведено сообщение о том, по какой причине компиляция не возможна. Наиболее часто пользователь неверно указывает путь к файлам или допускает ошибку в имени исходного файла. 
Запуск программы из командной строки
В командной строке SDK Commond Prompt указать полный путь к файлу, например, d:\temp\hello.exe и нажать клавишу Enter.
В нашем случае консольное окно примет вид:
 
Передача параметров в метод Main из командной строки
1.	Создадим новый проект, в котором содержится следующий код: 
2.	static void Main(string[] args) //метод принимает параметры в виде массива строк
3.	{
4.	 Console.WriteLine("Командная строка содержит" + args.Length + "аргументов.\n Вот они");
5.	 for (int i = 0; i < args.Length; i++) //просматриваем содержимое массива args
6.	 Console.WriteLine(args[i]);
7.	}
8.	Сохраним данный проект в папку temp на диске d. 
9.	Запустим SDK Commond Prompt, сгенерируем exe файл и запустим его: 
 
В данном случае никакие параметры при вызове Program.exe не передавались, поэтому список аргументов пуст.
10.	Теперь при обращении к исполняемому файлу после указания его местоположения запишем строку один два три четыре пять и нажмем клавишу Enter. 
 
В нашем случае строка "один два три четыре пять" была передана в метод Main. При передаче строка автоматически разбивается пробелами на подстроки, которые записываются массив args.
11.	Параметры в метод Main могут передаваться только в виде массива строк, но элементы этого массива внутри метода Main могут быть преобразованы к нужном типу. 
12.	Внесем изменения в код метода Main: 
13.	static void Main(string[] args)
14.	{
15.	 if (args.Length ==2)
16.	 {
17.	  try
18.	  {
19.	   int a = int.Parse(args[0]);
20.	   int b = int.Parse(args[1]);
21.	   Console.WriteLine("{0} + {1} = {2}", a, b, a + b);
22.	  }
23.	  catch (FormatException)
24.	  {
25.	  Console.WriteLine("передаваемые параметры должны быть целыми числами");
26.	  }
27.	 }
28.	 else Console.WriteLine("В метод Main следует передавать два целочисленных параметра");
29.	}
30.	Сохраните данный файл в папку temp на диске d, и не забудьте сгенерировать исполняемый файл. 
31.	Несколько раз вызовите исполняемый файл из консольного окна, используя разное количество параметров и разные типы параметров: 
 
 
Лекция 10. Регулярные выражения
Стандартный класс string позволяет выполнять над строками различные операции, в том числе поиск, замену, вставку и удаление подстрок. Тем не менее, есть классы задач по обработке символьной информации, где стандартных возможностей явно не хватает. Чтобы облегчить решение подобных задач, в Net Framework встроен более мощный аппарат работы со строками, основанный на регулярных выражениях.
Регулярные выражения предназначены для обработки текстовой информации и обеспечивают:
1.	Эффективный поиск в тексте по заданному шаблону; 
2.	Редактирование текста; 
3.	Формирование итоговых отчетов по результатам работы с текстом. 
Подробно рассмотрим первые два аспекта применения регулярных выражений.
10.1 Метасимволы в регулярных выражениях
Регулярное выражение - это шаблон, по которому выполняется поиск соответствующего фрагмента текста. Язык описания регулярных выражений состоит из символов двух видов: обычных символов и метасимволов. Обычный символ представляет в выражении сам себя, а метасимвол - некоторый класс символов.
Рассмотрим наиболее употребительные метасимволы:
Класс символов	Описание	Пример
.	Любой символ, кроме \n.	Выражение c.t соответствует фрагментам: cat, cut, c#t, c{t и т.д.
[]	Любой одиночный символ из последовательности, записанной внутри скобок. Допускается использование диапазонов символов.	Выражение c[aui]t соответствует фрагментам: cat, cut, cit. Выражение c[a-c]t соответствует фрагментам: cat, cbt, cct.
[^]	Любой одиночный символ, не входящий в последовательность, записанную внутри скобок. Допускается использование диапазонов символов.	Выражение c[^aui]t соответствует фрагментам: cbt, cct, c2t и т.д. Выражение c[^a-c]t соответствует фрагментам: cdt, cet, c%t и т.д.
\w	Любой алфавитно-цифровой символ.	Выражение c\wt соответствует фрагментам: cbt, cct, c2t и т.д., но не соответствует фрагментам c%t, c{t и т.д.
\W	Любой не алфавитно-цифровой символ.	Выражение c\Wt соответствует фрагментам: c%t, c{t, c.t и т.д., но не соответствует фрагментам cbt, cct, c2t и т.д.
\s	Любой пробельный символ.	Выражение \s\w\w\w\s соответствует любому слову из трех букв, окруженному пробельными символами.
\S	Любой не пробельный символ.	Выражение \s\S\S\S\s соответствует любым трем непробельным символам, окруженным пробельными.
\d	Любая десятичная цифра	Выражение c\dt соответствует фрагментам: c1t, c2t, c3t и т.д.
\D	Любой символ, не являющийся десятичной цифрой	Выражение c\Dt не соответствует фрагментам: c1t, c2t, c3t и т.д.
Кроме метасимволов, обозначающие классы символов, могут применяться уточняющие метасимволы:
Уточняющие символы	Описание
^	Фрагмент, совпадающий с регулярными выражениями, следует искать только в начале строки
$	Фрагмент, совпадающий с регулярными выражениями, следует искать только в конце строки
\А	Фрагмент, совпадающий с регулярными выражениями, следует искать только в начале многострочной строки
\Z	Фрагмент, совпадающий с регулярными выражениями, следует искать только в конце многострочной строки
\b	Фрагмент, совпадающий с регулярными выражениями, начинается или заканчивается на границе слова, т.е. между символами, соответствующими метасимволам \w и \W
\B	Фрагмент, совпадающий с регулярными выражениями, не должен встречаться на границе слов
В регулярных выражениях часто используются повторители - метасимволы, которые располагаются непосредственно после обычного символа или группы символов и задают количество его повторений в выражении. 
Повторители	Описание	Пример
*	Ноль или более повторений предыдущего элемента	Выражение ca*t соответствует фрагментам: ct, cat, caat, caaat и т.д.
+	Одно или более повторений предыдущего элемента	Выражение ca+t соответствует фрагментам: cat, caat, caaat и т.д.
?	Не более одного повторения предыдущего элемента	Выражение ca?t соответствует фрагментам: ct, cat.
{n}	Ровно n повторений предыдущего элемента	Выражение ca{3}t соответствует фрагменту: cаааt. Выражение (cat){2} соответствует фрагменту: cаtcat.
{n,}	По крайней мере n повторений предыдущего элемента	Выражение ca{3,}t соответствует фрагментам: cаааt, caaaat, caaaaaaat и т.д. Выражение (cat){2,} соответствует фрагментам: catcat, catcatcat и т.д.
{n, m}	От n до m повторений предыдущего элемента	Выражение ca{2, 4}t соответствует фрагментам: cааt, caaat, caaaat.
Регулярное выражение записывается в виде строкового литерала, причем перед строкой необходимо ставить символ @, который говорит о том, что строку нужно будет рассматривать и в том случае, если она будет занимать несколько строчек на экране. Однако символ @ можно не ставить, если в качестве шаблона используется шаблон без метасимволов. 
Замечание. Если нужно найти какой-то символ, который является метасимволом, например, точку, можно это сделать защитив ее обратным слэшем. Т.е. просто точка означает любой одиночный символ, а \. означает просто точку.
Примеры регулярных выражений:
1.	слово rus - 
2.	 @"rus"  или "rus"
3.	номер телефона в формате xxx-xx-xx - @"\d\d\d-\d\d-\d\d" или @"\d{3}(-\d\d){2}" 
4.	номер автомобиля - @"[A-Z]\d{3}[A-Z]{2}\d{2,3}RUS" 
Задания. Запишите регулярное выражение, соответствующее: 
1.	1. дате в формате дд.мм.гг или дд.мм.гггг 
2.	2. времени в формате чч.мм или чч:мм 
3.	3. целому числу (со знаком и без) 
4.	4. вещественному числу (со знаком и без, с дробной частью и без, с целой частью и без) 
10.2 Поиск в тексте по шаблону
Пространство имен библиотеки базовых классов System.Text.RegularExpressions содержит все объекты платформы .NET Framework, имеющие отношение к регулярным выражениям. Важнейшим классом, поддерживающим регулярные выражения, является класс Regex, который представляет неизменяемые откомпилированные регулярные выражения. Для описания регулярного выражения в классе определено несколько перегруженных конструкторов:
1.	Regex() - создает пустое выражение; 
2.	Regex(String) - создает заданное выражение; 
3.	Regex(String, RegexOptions) - создает заданное выражение и задает параметры для его обработки с помощью элементов перечисления RegexOptions (например, различать или нет прописные и строчные буквы). 
Поиск фрагментов строки, соответствующих заданному выражению, выполняется с помощью методов IsMach, Mach, Matches класса Regex.
Метод IsMach возвращает true, если фрагмент, соответствующий выражению, в заданной строке найден, и false в противном случае. Например, попытаемся определить, встречается ли в заданном тексте слово собака:
static void Main()
{
  Regex r = new Regex("собака",RegexOptions.IgnoreCase);
  string text1 = "Кот в доме, собака в конуре."; 
  string text2 = "Котик в доме, собачка в конуре.";
  Console.WriteLine(r.IsMatch(text1)); 
  Console.WriteLine(r.IsMatch(text2));     
}
Замечание. RegexOptions.IgnoreCase - означает, что регулярное выражение применяется без учеба регистра символов
Можно использовать конструкцию выбора из нескольких элементов. Варианты выбора перечисляются через вертикальную черту. Например, попытаемся определить, встречается ли в заданном тексте слов собака или кот:
static void Main(string[] args)
{
  Regex r = new Regex("собака|кот",RegexOptions.IgnoreCase);
  string text1 = "Кот в доме, собака в конуре.";
  string text2 = "Котик в доме, собачка в конуре.";
  Console.WriteLine(r.IsMatch(text1)); 
  Console.WriteLine(r.IsMatch(text2));     
}
Попытаемся определить, есть ли в заданных строках номера телефона в формате xx-xx-xx или xxx-xx-xx:
static void Main()
{
  Regex r = new Regex(@"\d{2,3}(-\d\d){2}");
  string text1 = "tel:123-45-67";
  string text2 = "tel:no";
  string text3 = "tel:12-34-56";
  Console.WriteLine(r.IsMatch(text1));
  Console.WriteLine(r.IsMatch(text2));
  Console.WriteLine(r.IsMatch(text3));
}
Задание. Измените программу так, чтобы можно было определить, содержится в тексте дата в формате дд.мм.гг.
Метод Match класса Regex не просто определяет, содержится ли текст, соответствующий шаблону, а возвращает объект класса Match - последовательность фрагментов текста, совпавших с шаблоном. Следующий пример позволяет найти все номера телефонов в указанном фрагменте текста:
static void Main()
{
  Regex r = new Regex(@"\d{2,3}(-\d\d){2}");
  string text = @"Контакты в Москве tel:123-45-67, 123-34-56; fax:123-56-45
                  Контакты в Саратове tel:12-34-56; fax:12-56-45";
  Match tel = r.Match(text);
  while (tel.Success)
  {
    Console.WriteLine(tel);
    tel = tel.NextMatch();
  }
}
Следующий пример позволяет подсчитать сумму целых чисел, встречающихся в тексте:
static void Main()
{
  Regex r = new Regex(@"[-+]?\d+");
  string text = @"5*10=50 -80/40=-2";
  Match teg = r.Match(text);
  int sum = 0;
  while (teg.Success)
  {
    Console.WriteLine(teg);
    sum += int.Parse(teg.ToString());
    teg = teg.NextMatch();
  }
  Console.WriteLine("sum=" + sum);
}
Задание. Измените программу так, чтобы на экран дополнительно выводилось количество найденных чисел.
Метод Matches класса Regex возвращает объект класса MatchCollection - коллекцию всех фрагментов заданной строки, совпавших с шаблоном. При этом метод Matches многократно запускает метод Match, каждый раз начиная поиск с того места, на котором закончился предыдущий поиск.
  static void Main(string[] args)
  {
    string text = @"5*10=50 -80/40=-2";
    Regex theReg = new Regex(@"[-+]?\d+");
    MatchCollection theMatches = theReg.Matches(text);
    foreach (Match theMatch in theMatches)
    {
      Console.Write("{0} ", theMatch.ToString()); 
    }
    Console.WriteLine();
  }
}
10.3 Редактирование текста
Регулярные выражения могут эффективно использоваться для редактирования текста. Например, метод Replace класса Regex позволяет выполнять замену одного фрагмента текста другим или удаление фрагментов текста:
Пример 1. Изменение номеров телефонов:
static void Main(string[] args)
 {            
 string text = @"Контакты в Москве tel:123-45-67, 123-34-56; fax:123-56-45. 
Контакты в Саратове tel:12-34-56; fax:11-56-45";
 Console.WriteLine("Старые данные\n"+text);
 string newText=Regex.Replace(text, "123-", "890-");
 Console.WriteLine("Новые данные\n" + newText);
 }
Задание. Измените программу так, чтобы шестизначные номера заменялись на семизначные добавлением 0 после первых двух цифр. Например, номер 12-34-56 заменился бы на 120-34-56.
Пример 2. Удаление всех номеров телефонов из текста:
  static void Main()
  {            
    string text = @"Контакты в Москве tel:123-45-67, 123-34-56; fax:123-56-45. 
                Контакты в Саратове tel:12-34-56; fax:12-56-45";
    Console.WriteLine("Старые данные\n"+text);
    string newText=Regex.Replace(text, @"\d{2,3}(-\d\d){2}", "");
    Console.WriteLine("Новые данные\n" + newText);
  }
}
Задание. Измените программу так, чтобы из текста удалялись слова tel и fax (если после данных слов стоят двоеточия, то их тоже следует удалить).
Пример 3. Разбиение исходного текста на фрагменты:
static void Main()
{            
  string text = @"Контакты в Москве tel:123-45-67, 123-34-56; fax:123-56-45.  
            Контакты в Саратове tel:12-34-56; fax:12-56-45";
  string []newText=Regex.Split(text,"[ ,.:;]+");
  foreach( string a in newText)
  Console.WriteLine(a);
}
Задание. Разместите текст на одной строке и посмотрите, как изменится вывод данных. Объясните результаты.
Самостоятельная работа
Класс Group позволяет группировать соответствия на основе синтаксиса регулярных выражений и представлять результаты действия одного группирующего выражения. Группирующее выражение именует группу и задает регулярное выражение. Любой фрагмент строки, удовлетворяющий этому регулярному выражению, будет добавлен в группу. Например, группу ip можно задать следующим выражением:
@"(?<ip>(\d|\.)+)\s"
В данной записи (? ) говорит о том, что начинает формироваться группа, <ip> определяет имя данной группы, а (\d|\.)+)\s определяет шаблон регулярного выражения, который будет связан с этой группой. Если при поиске фрагмент текста будет соответствовать данному шаблону, то этот фрагмент будет заноситься в группу ip. 
Класс Match является производным от класса Group и имеет коллекцию Groups, которая содержит все группы, обнаруженные объектом Match. Создание и использование коллекции Groups и классов Group иллюстрируется следующим примером:
static void Main(string[] args)
{
 string text = @"04:55:34 223.34.12.156 www.aaa.ru
                 04:59:55 213.134.112.56 www.bbb.cc.com
                 05:05:01 223.34.12.156 www.aaa.ru";
 Regex theReg = new  Regex(@"(?<time>(\d|\:)+)\s"+
                           @"(?<ip>(\d|\.)+)\s"+
                           @"(?<site>\S+)");
 MatchCollection theMatches = theReg.Matches(text);
 foreach (Match theMatch in theMatches)
 {
  if (theMatch.Length != 0)
  {
   Console.WriteLine("\ntheMatch: {0}", theMatch.ToString()); //1
   Console.WriteLine("time: {0}", theMatch.Groups["time"]);  //2
   Console.WriteLine("ip: {0}", theMatch.Groups["ip"]);  //3
   Console.WriteLine("site: {0}", theMatch.Groups["site"]);  //4
  }
 }
}
В этом примере строка 1 целиком выводит фрагмент текста совпавший с регулярным выражением, а строки 2-4, то только тот текст, который был помещен в конкретную группу
Практическое задание
1.	Шаблоны регулярных выражений для групп time, ip и site записаны в упрощенном виде. Преобразуйте их к такому виду, чтобы они соответствовали ограничениям, накладываемым на формат времени, ip-адреса и адреса web-сайта. 
2.	Используя дополнительную литературу и Интернет, более подробно изучите работу с классом Group и коллекцией Groups класса Match
 
Лекция 11. Организация С#-системы ввода-вывода
С#-программы выполняют операции ввода-вывода посредством потоков, которые построены на иерархии классов. Поток (stream) - это абстракция, которая генерирует и принимает данные. С помощью потока можно читать данные из различных источников (клавиатура, файл) и записывать в различные источники (принтер, экран, файл). Несмотря на то, что потоки связываются с различными физическими устройствами, характер поведения всех потоков одинаков. Поэтому классы и методы ввода-вывода можно применить ко многим типам устройств. 
На самом низком уровне иерархии потоков ввода-вывода находятся потоки, оперирующие байтами. Это объясняется тем, что многие устройства при выполнении операций ввода-вывода ориентированы на байты. Однако для человека привычнее оперировать символами, поэтому разработаны символьные потоки, которые фактически представляют собой оболочки, выполняющие преобразование байтовых потоков в символьные и наоборот. Кроме этого, реализованы потоки для работы с int-, double-, short- значениями, которые также представляют оболочку для байтовых потоков, но работают не с самими значениями, а с их внутренним представлением в виде двоичных кодов. 
Центральную часть потоковой С#-системы занимает класс Stream пространства имен System.IO. Класс Stream представляет байтовый поток и является базовым для всех остальных потоковых классов. Из класса Stream выведены такие байтовые классы потоков как:
1.	FileStream - байтовый поток, разработанный для файлового ввода-вывода 
2.	BufferedStream - заключает в оболочку байтовый поток и добавляет буферизацию, которая во многих случаях увеличивает производительность программы; 
3.	MemoryStream - байтовый поток, который использует память для хранения данных. 
Программист может вывести собственные потоковые классы. Однако для подавляющего большинства приложений достаточно встроенных потоков.
Подробно мы рассмотрим класс FileStream, классы StreamWriter и StreamReader, представляющие собой оболочки для класса FileStream и позволяющие преобразовывать байтовые потоки в символьные, а также классы BinaryWriter и BinaryReader, представляющие собой оболочки для класса FileStream и позволяющие преобразовывать байтовые потоки в двоичные для работы с int-, double-, short- и т.д. значениями.
11.1 Байтовый поток
Чтобы создать байтовый поток, связанный с файлом, создается объект класса FileStream. При этом в классе определено несколько конструкторов. Чаще всего используется конструктор, который открывает поток для чтения и/или записи:
FileStream(string filename, FileMode mode)
где:
1.	параметр filename определяет имя файла, с которым будет связан поток ввода-вывода данных; при этом filename определяет либо полный путь к файлу, либо имя файла, который находится в папке bin/debug вашего проекта. 
2.	параметр mode определяет режим открытия файла, который может принимать одно из возможных значений, определенных перечислением FileMode: 
o	FileMode.Append - предназначен для добавления данных в конец файла; 
o	FileMode.Create - предназначен для создания нового файла, при этом если существует файл с таким же именем, то он будет предварительно удален; 
o	FileMode.CreateNew - предназначен для создания нового файла, при этом файл с таким же именем не должен существовать; 
o	FileMоde.Open - предназначен для открытия существующего файла; 
o	FileMode.ОpenOrCreate - если файл существует, то открывает его, в противном случае создает новый 
o	FileMode.Truncate - открывает существующий файл, но усекает его длину до нуля 
Если попытка открыть файл оказалась неуспешной, то генерируется одно из исключений: FileNotFoundException - файл невозможно открыть по причине его отсутствия, IOException - файл невозможно открыть из-за ошибки ввода-вывода, ArgumentNullException - имя файла представляет собой null-значение, ArgumentException - некорректен параметр mode, SecurityException - пользователь не обладает правами доступа, DirectoryNotFoundException - некорректно задан каталог.
Другая версия конструктора позволяет ограничить доступ только чтением или только записью: 
FileStream(string filename, FileMode mode, FileAccess how)
где:
1.	параметры filename и mode имеют то же назначение, что и в предыдущей версии конструктора; 
2.	параметр how, определяет способ доступа к файлу и может принимать одно из значений, определенных перечислением FileAccess: 
1.	FileAccess.Read - только чтение; 
2.	FileAccess.Write - только запись; 
3.	FileAccess.ReadWrite - и чтение, и запись. 
После установления связи байтового потока с физическим файлом внутренний указатель потока устанавливается на начальный байт файла. 
Для чтения очередного байта из потока, связанного с физическим файлом, используется метод ReadByte(). После прочтения очередного байта внутренний указатель перемещается на следующий байт файла. Если достинут конец файла, то метод ReadByte() возвращает значение -1. 
Для побайтовой записи данных в поток используется метод WriteByte().
По завершении работы с файлом его необходимо закрыть. Для этого достаточно вызвать метод Close (). При закрытии файла освобождаются системные ресурсы, ранее выделенные для этого файла, что дает возможность использовать их для работы с другими файлами. 
Рассмотрим пример использования класса FileStream, для копирования одного файла в другой. Но вначале создадим текстовый файл text.txt в папке bin/debug текущего проекта. И внесем в него произвольную информацию, например:
12    456
Hello! 
23,67  4: Message

using System;
using System.Text;
using System.IO; //для работы с потоками

namespace MyProgram
{
 class Program
 {
  static void Main()
  {
   try
   {
   FileStream fileIn = new FileStream("text.txt", 
                                       FileMode.Open, 
                                       FileAccess.Read);
   FileStream fileOut = new FileStream("newText.txt", 
                                        FileMode.Create, 
                                        FileAccess.Write);
   int i;
   while ((i = fileIn.ReadByte())!=-1)
   {
    //запись очередного файла в поток, связанный с файлом fIleOut
    fileOut.WriteByte((byte)i); 
   } 
   fileIn.Close();
   fileOut.Close();
   }  
   catch (Exception EX)
   {
    Console.WriteLine(EX.Message);
   }
  }
 }
}
Задание. Подумайте, почему для переменной i указан тип int. Можно было бы указать тип byte?
11.2 Символьный поток
Чтобы создать символьный поток нужно поместить объект класса Stream (например, FileStream) "внутрь" объекта класса StreamWriter или объекта класса StreamReader. В этом случае байтовый поток будет автоматически преобразовываться в символьный. 
Классе StreamWriter предназначен для организации выходного символьного потока. В нем определено несколько конструкторов. Один из них записывается следующим образом:
StreamWriter(Stream stream);
где параметр stream определяет имя уже открытого байтового потока. 
Например, создать экземпляр класса StreamWriter можно следующим образом:
StreamWriter fileOut=new StreamWriter(new FileStream("text.txt", 
                                                      FileMode.Create, 
                                                      FileAccess.Write));
Этот конструктор генерирует исключение типа ArgumentException, если поток stream не открыт для вывода, и исключение типа ArgumentNullException, если он (поток) имеет null-значение. 
Другой вид конструктора позволяет открыть поток сразу через обращения к файлу:
StreamWriter(string name);
где параметр name определяет имя открываемого файла.
Например, обратиться к данному конструктору можно следующим образом:
StreamWriter fileOut=new StreamWriter("c:\temp\t.txt");
И еще один вариант конструктора StreamWriter:
StreamWriter(string name, bool appendFlag);
где параметр name определяет имя открываемого файла;
параметр appendFlag может принимать значение true - если нужно добавлять данные в конец файла, или false - если файл необходимо перезаписать.
Например:
StreamWriter fileOut=new StreamWriter("t.txt", true);
Теперь для записи данных в поток fileOut можно обратиться к методу WriteLine. Это можно сделать следующим образом:
fileOut.WriteLine("test");
В данном случае в конец файла t.txt будет дописано слово test.
Класс StreamReader предназначен для организации входного символьного потока. Один из его конструкторов выглядит следующим образом:
StreamReader(Stream stream);
где параметр stream определяет имя уже открытого байтового потока. 
Этот конструктор генерирует исключение типа ArgumentException, если поток stream не открыт для ввода.
Например, создать экземпляр класса StreamWriter можно следующим образом:
StreamReader fileIn = new StreamReader(new FileStream("text.txt", 
                                                       FileMode.Open, 
                                                       FileAccess.Read));
Как и в случае с классом StreamWriter у класса StreamReader есть и другой вид конструктора, который позволяет открыть файл напрямую:
StreamReader (string name);
где параметр name определяет имя открываемого файла.
Обратиться к данному конструктору можно следующим образом:
StreamReader fileIn=new StreamReader ("c:\temp\t.txt");
В C# символы реализуются кодировкой Unicode. Для того, чтобы можно было обрабатывать текстовые файлы, содержащие русский символы, созданные, например, в Блокноте, рекомендуется вызывать следующий вид конструктора StreamReader:
StreamReader fileIn=new StreamReader ("c:\temp\t.txt", 
                                       Encoding.GetEncoding(1251));
Параметр Encoding.GetEncoding(1251) говорит о том, что будет выполняться преобразование из кода Windows-1251 (одна из модификаций кода ASCII, содержащая русские символы) в Unicode. Encoding.GetEncoding(1251) реализован в пространстве имен System.Text. 
Теперь для чтения данных из потока fileIn можно воспользоваться методом ReadLine. При этом если будет достигнут конец файла, то метод ReadLine вернет значение null.
Рассмотрим пример, в котором данные из одного файла копируются в другой, но уже с использованием классов StreamWriter и StreamReader.
static void Main()
{
  StreamReader fileIn = new StreamReader("text.txt", 
                                          Encoding.GetEncoding(1251));
  StreamWriter fileOut=new StreamWriter("newText.txt", false);
  string line;
  while ((line=fileIn.ReadLine())!=null) //пока поток не пуст
  {
    fileOut.WriteLine(line);
  }
  fileIn.Close();
  fileOut.Close();
}
Задание. Выясните, для чего предназначен метод ReadToEnd() и когда имеется смысл его применять. 
Таким образом, данный способ копирования одного файла в другой, даст нам тот же результат, что и при использовании байтовых потоков. Однако, его работа будет менее эффективной, т.к. будет тратиться дополнительное время на преобразование байтов в символы. Но у символьных потоков есть свои преимущества. Например, мы можем использовать регулярные выражения для поиска заданных фрагментов текста в файле.
static void Main()
{
  StreamReader fileIn = new StreamReader("text.txt");
  StreamWriter fileOut=new StreamWriter("newText.txt", false);
  string text=fileIn.ReadToEnd();
  Regex r= new Regex(@"[-+]?\d+");
  Match integer = r.Match(text);
  while (integer.Success)
  {
    fileOut.WriteLine(integer);
    integer = integer.NextMatch();
  }
  fileIn.Close();
  fileOut.Close();
}
11.3 Двоичные потоки
Двоичные файлы хранят данные в том же виде, в котором они представлены в оперативной памяти, то есть во внутреннем представлении. Двоичные файлы не применяются для просмотра человеком, они используются только для программной обработки. 
Выходной поток BinaryWriter поддерживает произвольный доступ, т.е. имеется возможность выполнять запись в произвольную позицию двоичного файла. Наиболее важные методы потока BinaryWriter:
Член класса	Описание
BaseStream	Определяет базовый поток, с которым работает объект BinaryWriter
Close	Закрывает поток
Flush	Очищает буфер
Seek	Устанавливает позицию в текущем потоке
Write	Записывает значение в текущий поток
Наиболее важные методы выходного потока BinaryReader:
Член класса	Описание
BaseStream	Определяет базовый поток, с которым работает объект BinaryReader
Close	Закрывает поток
PeekChar	Возвращает следующий символ потока без перемещения внутреннего указателя в потоке
Read	Считывает очередной поток байтов или символов и сохраняет в массиве, передаваемом во входном параметре
ReadBoolean, ReadByte, ReadInt32 и т.д	Считывает из потока данные определенного типа
Двоичный поток открывается на основе базового протока (например, FileStream), при этом двоичный поток будет преобразовывать байтовый поток в значения int-, double-, short- и т.д. 
Рассмотрим пример формирования двоичного файла:
 
  static void Main()
  {
    //открываем двоичный поток    
    BinaryWriter fOut=new BinaryWriter(new FileStream("t.dat",FileMode.Create));
    //записываем данные в двоичный поток    
    for (int i=0; i<=100; i+=2)
    {
     fOut.Write(i);
    }
    fOut.Close(); //закрываем двоичный поток
  }
Попытка просмотреть двоичный файл через текстовый редактор неинформативна. Двоичный файл просматривается программным путем, например следующим образом:
  static void Main()
  {
     FileStream f=new FileStream("t.dat",FileMode.Open);
    BinaryReader fIn=new BinaryReader(f);
    long n=f.Length/4; //определяем количество чисел в двоичном потоке
    int a;
    for (int i=0; i<n; i++)
    {
     a=fIn.ReadInt32();
     Console.Write(a+" ");
    }
    fIn.Close();
    f.Close();
  }
Двоичные файлы являются файлами с произвольным доступом, при этом нумерация элементов в двоичном файле ведется с нуля. Произвольный доступ обеспечивает метод Seek. Рассмотрим его синтаксис:
Seek(long newPos, SeekOrigin pos)
где параметр newPos определяет новую позицию внутреннего указателя файла в байтах относительно исходной позиции указателя, которая определяется параметром pos. В свою очередь параметр pos должен быть задан одним из значений перечисления SeekOrigin:
Значение	Описание
SeekOrigin.Begin	Поиск от начала файла
SeekOrigin.Current	Поиск от текущей позиции указателя
SeekOrigin.End	Поиск от конца файла
После вызова метода Seek следующие операции чтения или записи будут выполняться с новой позиции внутреннего указателя файла.
Рассмотрим пример организации произвольного доступа к двоичному файлу (на примере файла t.dat):
  static void Main()
  {
    //изменение данных в двоичном потоке
    FileStream f=new FileStream("t.dat",FileMode.Open);
    BinaryWriter fOut=new BinaryWriter(f);
    long n=f.Length; //определяем количество байт в байтовом потоке
    int a;
    for (int i=0; i<n; i+=8) //сдвиг на две позиции, т.к. тип int занимает 4 байта
    {
     fOut.Seek(i,SeekOrigin.Begin);
     fOut.Write(0);
    }
    fOut.Close();
    //чтение данных из двоичного потока
    f=new FileStream("t.dat",FileMode.Open);
    BinaryReader fIn=new BinaryReader(f);
    n=f.Length/4; //определяем количество чисел в двоичном потоке
    for (int i=0; i<n; i++)
    {
     a=fIn.ReadInt32();
     Console.Write(a+" ");
    }
    fIn.Close();
    f.Close();
 }
Поток BinaryReader не имеет метода Seek, однако используя возможности потока FileStream можно организовать произвольный доступ при чтении двоичных файлов. Рассмотрим следующий пример:
static void Main()
{
 //Записываем в файл t.dat целые числа от 0 до 100 
 FileStream f=new FileStream("t.dat",FileMode.Open);
 BinaryWriter fOut=new BinaryWriter(f);
 for (int i=0; i<100; ++i) 
 {
  fOut.Write(i);;
 }
 fOut.Close();
 //Объекты f и fIn связаны с одним и тем же файлом 
 f=new FileStream("t.dat",FileMode.Open);
 BinaryReader fIn=new BinaryReader(f);
 long n=f.Length; //определяем количество байт потоке
 //Читаем данные из файла t.dat, перемещая внутренний указатель на 8 байт, т.е. на два целых числа
 for (int i=0; i<n; i+=8)
 {
  f.Seek(i,SeekOrigin.Begin); 
  int a=fIn.ReadInt32();
  Console.Write(a+" ");
 }
 fIn.Close();
 f.Close();
}
11.4 Перенаправление стандартных потоков
Тремя стандартными потоками, доступ к которым осуществляется через свойства Console.Out, Console.In и Console.Error, могут пользоваться все программы, работающие в пространстве имен System. Свойство Console.Out относится к стандартному выходному потоку. По умолчанию это консоль. Например, при вызове метода Console.WriteLine() информация автоматически передается в поток Console.Out. Свойство Console.In относится к стандартному входному потоку, источником которого по умолчанию является клавиатура. Например, при вводе данных с клавиатуры информация автоматически передается потоку Console.In, к которому можно обратиться с помощью метода Console.ReadLine(). Свойство Console.Error относится к ошибкам в стандартном потоке, источником которого также по умолчанию является консоль. Однако эти потоки могут быть перенаправлены на любое совместимое устройство ввода-вывода, например, на работу с физическими файлами.
Перенаправить стандартный поток можно с помощью методов SetIn(), SetOut() и SetError(), которые являются членами класса Console:
static void Setln(TextReader input)
static void SetOut(TextWriter output)
static void SetError(TextWriter output)
Пример перенаправления потоков проиллюстрирован следующей программой, в которой двумерный массив вводится из файла input.txt, а выводится в файл output.txt
static void Main()
{
 try
 {
  int[,] MyArray;
  StreamReader file=new StreamReader("input.txt"); 
  Console.SetIn(file);  // перенаправляем стандартный входной поток на file
  string line=Console.ReadLine();
  string []mas=line.Split(' ');
  int n=int.Parse(mas[0]);
int m=int.Parse(mas[1]);
  MyArray = new int[n,m];
  for (int i = 0; i < n; i++)
  {
   line = Console.ReadLine();
   mas = line.Split(' ');
   for (int j = 0; j < m; j++)
   {
    MyArray[i,j] = int.Parse(mas[j]);
   }
  }
  PrintArray("исходный массив:", MyArray, n, m);
  file.Close();
}

static void PrintArray(string a, int[,] mas, int n, int m)
{
 StreamWriter file=new StreamWriter("output.txt"); // перенаправляем стандартный входной поток на file
 Console.SetOut(file);
 Console.WriteLine(a);
 for (int i = 0; i < n; i++)
 {
  for (int j=0; j<m; j++) Console.Write("{0} ", mas[i,j]);
  Console.WriteLine();
 }
 file.Close();
}

___input.txt_________
3 4
1 4 2 8
4 9 0 1
5 7 4 2
При необходимости восстановить исходное состояние потока Console.In можно следующим образом:
TextWriter str = Console.In;  // первоначально сохраняем исходное состояние входного потока
…
Console.SetIn(str);    // при необходимости восстанавливаем исходное состояние входного потока
Аналогичным образом можно восстановить исходное состояние потока Console.Out:
TextWriter str = Console.Out;  // первоначально сохраняем исходное состояние выходного потока
…
// при необходимости восстанавливаем исходное состояние выходного потока
Console.SetOut(str); 
Задание. Подумайте для чего нужно два потока Console.Out и Console.Error, если они оба при стандартной работе выводят информацию на экран.
Практикум
1.	Работа с двоичными файлами: создать файл и записать в него вещественные числа из диапазона от a до b с шагом h. Вывести на экран все компоненты файла с нечетными порядковыми номерами. 
using System;
using System.Text;
using System.IO; 

namespace MyProgram
{
 class Program
 {
  static void Main()
  {
    Console.Write("a= ");
    double a=double.Parse(Console.ReadLine());
    Console.Write("b= ");
    double b=double.Parse(Console.ReadLine());
    Console.Write("h= ");
    double h=double.Parse(Console.ReadLine());
    //Записываем в файл t.dat вещественные числа из заданного диапазона 
    FileStream f=new FileStream("t.dat",FileMode.Open);
    BinaryWriter fOut=new BinaryWriter(f);
    for (double i=a; i<=b; i+=h) 
    {
     fOut.Write(i);;
    }
    fOut.Close();
    //Объекты f и fIn связаны с одним и тем же файлом 
    f=new FileStream("t.dat",FileMode.Open);
    BinaryReader fIn=new BinaryReader(f);
    long m=f.Length; //определяем количество байт в потоке
    //Читаем данные из файла t.dat начиная с элемента с номером 1, т.е с 8 байта,
    //перемещая внутренний указатель на 16 байт, т.е. на два вещественных числа
    for (long i=8; i<m; i+=16)
    {
     f.Seek(i,SeekOrigin.Begin); 
     a=fIn.ReadDouble();
     Console.Write("{0:f2} ",a);
    }
    fIn.Close();
    f.Close();
   }
 }
}
 
2.	Работа с текстовым (символьным) файлом. Дан текстовый файл. Найти количество строк, которые начинаются с данной буквы. 
Замечание: Напоминаем, что файл text.txt должен содержать английский текст
using System;
using System.Text;
using System.IO; 
using System.Text.RegularExpressions;

namespace MyProgram
{
 class Program
 {
  static void Main()
  {
    Console.Write("Введите заданную букву: ");
    char a=char.Parse(Console.ReadLine());
    StreamReader fileIn = new StreamReader("text.txt");
    string text=fileIn.ReadToEnd(); //считываем из файла весь текст
    fileIn.Close();
    int k=0;
    //разбиваем текст на слова используя регулярные выражения
    string []newText=Regex.Split(text,"[ ,.:;]+"); 
    //подсчитываем количество слов, начинающихся на заданную букву 
    foreach( string b in newText)
     if (b[0]==a)++k;
    Console.WriteLine("k= "+k);
   }
 }
}
Самостоятельная работа
Используя дополнительную литературу и Интернет рассмотреть использование:
1.	класса MemoryStream; 
2.	классов StringReader и StringWriter
 
Лекция 12. Работа с файловой системой
12.1.Работа с файловой системой: классы Directory и Filе и классы DirectoryInfo и FileInfo
В пространстве имен System.IO предусмотрено четыре класса, которые предназначены для работы с файловой системой компьютера, т.е для создания, удаления переноса и т.д. файлов и каталогов.
Первые два типа - Directory и Fi1е реализуют свои возможности с помощью статических методов, поэтому данные классы можно использовать без создания соответствующих объектов (экземпляров классов). 
Следующие типы - DirectoryInfo и FileInfo обладают схожими функциональными возможностями c Directory и Fi1е, но порождены от класса FileSystemInfo и поэтому реализуются путем создания соответствующих экземпляров классов. 
Замечание. Перед изучением данной лекции скопируйте на диск d своего компьютера папку prim из раздела 12 данного электронного учебника. Внимательно изучите содержимое данной папки.
12.2 Класс FileSystemInfo
Значительная часть членов класса FileSystemInfo предназначена для работы с общими характеристиками файла или каталога (метками времени, атрибутами и т. п.). Рассмотрим некоторые свойства FileSystemInfo:
Свойство 	Описание
Attributes 	Позволяет получить или установить атрибуты для данного объекта файловой системы. Для этого свойства используются значения и перечисления FileAttributes
CreationTime 	Позволяет получить или установить время создания объекта файловой системы
Exists 	Может быть использовано для того, чтобы определить, существует ли данный объект файловой системы
Extension	Позволяет получить расширение для файла
FullName 	Возвращает имя файла или каталога с указанием пути к нему в файловой системе
LastAccessTime 	Позволяет получить или установить время последнего обращения к объекту файловой системы
LastWriteTime 	Позволяет получить или установить время последнего внесения изменений в объект файловой системы
Name 	Возвращает имя указанного файла. Это свойство доступно только для чтения. Для каталогов возвращает имя последнего каталога в иерархии, если это возможно. Если нет, возвращает полностью определенное имя
В FileSystemInfo предусмотрено и несколько методов. Например, метод Delete() - позволяет удалить объект файловой системы с жесткого диска, a Refresh() - обновить информацию об объекте файловой системы.
12.3 Класс DirectoryInfo
Данный класс наследует члены класса FileSystemInfo и содержит дополнительный набор членов, которые предназначены для создания, перемещения, удаления, получения информации о каталогах и подкаталогах в файловой системе. Наиболее важные члены класса содержатся в следующей таблице:
Член	Описание
Create() CreateSubDirectory()	Создают каталог (или подкаталог) по указанному пути в файловой системе
Delete() 	Удаляет пустой каталог
GetDirectories()	Позволяет получить доступ к подкаталогам текущего каталога (в виде массива объектов DirectoryInfo)
GetFiles() 	Позволяет получить доступ к файлам текущего каталога (в виде массива объектов FileInfo)
MoveTo() 	Перемещает каталог и все его содержимое на новый адрес в файловой системе
Parent 	Возвращает родительский каталог в иерархии файловой системы
Работа с типом DirectoryInfo начинается с того, что мы создаем экземпляр класса (объект), указывая при вызове конструктора в качестве параметра путь к нужному каталогу. Если мы хотим обратиться к текущему каталогу (то есть каталогу, в котором в настоящее время производится выполнение приложения), вместо параметра используется обозначение ".". Например:
// Создаем объект DirectoryInfo, которому будет обращаться к текущему каталогу
DirectoryInfo dir1 = new DirectoryInfo(".");
// Создаем объект DirectoryInfo, которому будет обращаться к каталогу d:\prim
DirectoryInfo dir2 = new DirectoryInfo(@"d:\prim");
Если мы попытаемся создать объект DirectoryInfo, связав его с несуществующим каталогом, то будет сгенерировано исключение System.IO.DirectoryNotFoundException. Если же все нормально, то мы сможем получить доступ к данному каталогу. В примере, который приведен ниже, мы создаем объект DlrectoryInfo, который связан с каталогом d:\prim, и выводим информацию о данном каталоге:
using System;
using System.Text;
using System.IO;

namespace MyProgram
{
 class Program
 {
  static void Main(string[] args)
  {
    DirectoryInfo dir = new DirectoryInfo(@"d:\prim");
    Console.WriteLine("***** "+dir.Name+" *****");
    Console.WriteLine("FullName: {0}", dir.FullName);
    Console.WriteLine("Name: {0}", dir.Name);
    Console.WriteLine("Parent: {0}", dir.Parent);
    Console.WriteLine("Creation: {0}", dir.CreationTime);
    Console.WriteLine("Attributes: {0}", dir.Attributes.ToString());
    Console.WriteLine("Root: {0}", dir.Root);
   }
 }
}

Свойство Attributes позволяет получить информацию об атрибутах объекта файловой системы. Возможные значения данного свойства приведены в следующей таблице: 
Значение 	Описание
Archive 	Этот атрибут используется приложениями при проведении резервного копирования, а в некоторых случаях - удаления старых файлов
Compressed 	Определяет, что файл является сжатым
Directory	Определяет, что объект файловой системы является каталогом
Encrypted 	Определяет, что файл является зашифрованным
Hidden 	Определяет, что файл является скрытым (такой файл не будет выводиться при обычном просмотре каталога)
Normal 	Определяет, что файл находится в обычном состоянии и для него установлены любые другие атрибуты. Этот атрибут не может использоваться с другими атрибутами
Offline	Файл (расположенный на сервере) кэширован в хранилище off-line на клиентском компьютере. Возможно, что данные этого файла уже устарели
Readonly 	Файл доступен только для чтения
System 	Файл является системным (то есть файл является частью операционной системы или используется исключительно операционной системой)
Через DirectoryInfo можно не только получать доступ к информации о текущем каталоге, но получить доступ к информации о его подкаталогах:
class Program
{
 static void printDirect( DirectoryInfo dir)
 {
  Console.WriteLine("***** "+dir.Name+" *****");
  Console.WriteLine("FullName: {0}", dir.FullName);
  Console.WriteLine("Name: {0}", dir.Name);
  Console.WriteLine("Parent: {0}", dir.Parent);
  Console.WriteLine("Creation: {0}", dir.CreationTime);
  Console.WriteLine("Attributes: {0}", dir.Attributes.ToString());
  Console.WriteLine("Root: {0}", dir.Root);
 }

 static void Main(string[] args)
 {
  DirectoryInfo dir = new DirectoryInfo(@"d:\prim");
  printDirect(dir);
  DirectoryInfo[] subDirects = dir.GetDirectories();
  Console.WriteLine("Найдено {0} подкаталогов", subDirects.Length);
  foreach (DirectoryInfo d in subDirects)
  {
   printDirect(d);
  }
  }
}
Задание. Преобразуйте метод printDirect в рекурсивный метод таким образом, чтобы можно было просмотреть информацию о всех подкаталогах текущего каталога, независимо от уровня вложенности.
Метод CreateSubdirectory() позволяет создать в выбранном каталоге как единственный подкаталог, так и множество подкаталогов (в том числе, и вложенных друг в друга). Создадим в каталоге несколько дополнительных подкаталогов:
DirectoryInfo dir = new DirectoryInfo(@"d:\prim");
dir.CreateSubdirectory("doc"); //создали подкаталог
dir.CreateSubdirectory(@"book\2008"); //создали вложенный подкаталог

Задание. Создайте вложенный подкаталог best\2008 для каталога d:\prim\bmp.
Метод MoveTo() позволяет переместить текущий каталог по заданному в качестве параметра адресу. При этом возможно произвести переименование каталога. Например:
DirectoryInfo dir = new DirectoryInfo(@"d:\prim\bmp");
dir.MoveTo(@"d:\prim\letter\bmp"); 

В данном случае каталог bmp перемещается в по адресу d:\prim\letter\bmp. Так как имя перемещаемого каталога совпадает с крайним правым именем в адресе нового местоположения каталога, то переименования не происходит. Следующий пример позволит нам переименовать текущий каталог:
DirectoryInfo dir = new DirectoryInfo(@"d:\prim\letter");
dir.MoveTo(@"d:\prim\archive");

12.4 Класс Directory
Работать с каталогами файловой системы компьютера можно и при помощи класса Directory, функциональные возможности которого во многом совпадают с возможностями DirectoryInfo. Но члены данного класса реализованы статически, поэтому для их использования нет необходимости создавать объект. 
Рассмотрим работу с методами данного класса на примерах.
Замечание. Удалите с диска d измененную папку prim. И еще раз скопируйте ее исходную версию из раздела 12 данного электронного учебника. 
Directory.CreateDirectory(@"d:\prim\2008");//создали подкаталог 2008
Directory.Move(@"d:\prim\bmp", 
             @"d:\prim\2008\bmp");//перенесли каталог bmp в каталог 2008
Directory.Move(@"d:\prim\letter", 
             @"d:\prim\archives");//переименовали каталог letter в archives
Замечания. 
1.	Удаление каталога возможно только тогда, когда он пуст. 
2.	На практике комбинируют использование классов Directory и DirectoryInfo. 
Пример. Рассмотрим пример windows - приложения, которое позволяет строить и просматривать дерево папок вашего ПК. При запуске приложения строится дерево дисков. Двойной щелчок покаждому диску позволяет раскрыть дерево папок. Для реализации интерфейса используется компонент TreeView

Приведем реализацию необходимых методов класса Form1

1. При запуске формы должно отображаться дерево всех дисков ПК. Для этого реализован обработчик события активации формы Form1_Activated

private void Form1_Activated(object sender, System.EventArgs e)
{// Получаем все диски (a:, c: и т.д.).
string [] drives = Environment.GetLogicalDrives();
foreach(string s in drives)
	{
	// Добавляем корневой элемент для каждого диска.
	TreeNode tn = treeView1.Nodes.Add(s);
	// Добавляем фиктивный подузел для каждого
	// диска (для появления квадратика с плюсиком).
	tn.Nodes.Add("");
	// Устанавливаем свойство tag.
	// Пустое значение свойства ("") - узел еще не раскрывался.
	// Плюс ("+") - узел раскрывался и в него были
	// добавлены нужные подузлы.
	tn.Tag = "";
	}
}

2. Реализуем метод, позволяющий получить по имени узла полное имя соответствующей папки
// Получение полного имени папки по узлу.
private String GetFullPath(TreeNode tn)
	{
	// Устанавливаем текуший узел на переданный в параметре.
	TreeNode currNode = tn;
	// В полное имя пока записываем текст,показываемый в текущем узле.
	String fullPath = currNode.Text;
	// Двигаемся к корню дерева.
	while(currNode.Parent!=null)
	{
	// Переходим на родительский узел.
	currNode = currNode.Parent;
	// К полному имени приписываем текст родитеского узла.
	fullPath= currNode.Text + @"\" + fullPath;
	}
	// Возвращаем полный путь.
	return fullPath + @"\";
	}
3. Добавление подузлов текущего узла
private void AddTreeNodes(TreeNode tn)
	{
	TreeNode aux;
	// Получаем полный путь для папки узла.
	DirectoryInfo d = new DirectoryInfo(GetFullPath(tn));
	// Массив для хранения подпапок.
	DirectoryInfo[] ds;
	try
		{
		// Получаем все подпапки для папки.
		ds = d.GetDirectories();
		// Для каждой папки выводим ее имя и имена всех подпапок.
		foreach (DirectoryInfo s in ds)
			{
			// Добавляем каждую подпапку.
			aux = tn.Nodes.Add(s.Name);
			// Устанавливаем для нее признак, что ее еще не раскрывали.
			aux.Tag = "";
			try
			{
				// Если она не пуста,
				if(s.GetDirectories().GetLength(0)!=0)
					{
					//  то добавляем в нее фиктивный узел.
					aux.Nodes.Add("");
					}
			}
		// Перехватываем исключение запрещенного доступа.
		catch (UnauthorizedAccessException)
		{
		};

		}
}
//Перехват общего исключения (например, если диск a: не вставлен).
		catch(Exception)	{}
}

4. Раскрытие ветки дерева
	private void NodeExpand(TreeNode tn)
	{
		// Если есть подузлы.
		if(tn.Nodes.Count!=0)
		{
			// Если раскрываем в первый раз.
			if(((string)tn.Tag)=="")
			{
				// Удаляем фиктивный узел.
				tn.Nodes.RemoveAt(0);
				// Добавляем подузлы.
				AddTreeNodes(tn);
				// Устнавливаем признак того, что
				// узел уже раскрывали и добавили в него все подузлы.
				tn.Tag = "+";
			}
		}
	}
5. Перед раскрытием ветки дерева необходимо добавить подузлы. Для этого необходимо реализовтаь обработчик события treeView1_BeforeExpand

private void treeView1_BeforeExpand(object sender, System.Windows.Forms.TreeViewCancelEventArgs e)
		{	// Добавление подузлов перед раскрытием.
			NodeExpand(e.Node);
}
12.2 Работа с файлами
Класс Filelnfo
Класс Filelnfo предназначен для организации доступа к физическому файлу, который содержится на жестком диске компьютера. Он позволяет получать информацию об этом файле (например, о времени его создания, размере, атрибутах и т. п.), а также производить различные операции, например, по созданию файла или его удалению. Класс FileInfo наследует члены класса FileSystemInfo и содержит дополнительный набор членов, который приведен в следующей таблице:
Член 	Описание
AppendText()	Создает объект StreamWriter для добавления текста к файлу
CopyTo()	Копирует уже существующий файл в новый файл
Create()	Создает новый файл и возвращает объект FileStream для взаимодействия с этим файлом
CreateText()	Создает объект StreamWriter для записи текстовых данных в новый файл
Delete()	Удаляет файл, которому соответствует объект FileInfo
Directory	Возвращает каталог, в котором расположен данный файл
DirectoryName	Возвращает полный путь к данному файлу в файловой системе
Length 	Возвращает размер файла
MoveTo()	Перемещает файл в указанное пользователем место (этот метод позволяет одновременно переименовать данный файл)
Name 	Позволяет получить имя файла
Ореn() 	Открывает файл с указанными пользователем правами доступа на чтение, запись или совместное использование с другими пользователями
OpenRead()	Создает объект FileStream, доступный только для чтения
OpenText() 	Создает объект StreamReader (о нем также будет рассказано ниже), который позволяет считывать информацию из существующего текстового файла
OpenWrite()	Создает объект FileStream, доступный для чтения и записи
Как мы видим, большинство методов FileInfo возвращает объекты (FIleStream, StreamWriter, StreamReader и т. п.), которые позволяют различным образом взаимодействовать с файлом, например, производить чтение или запись в него. Приемы работы с данными потоками нам уже известны. Поэтому рассмотрим другие возможности класса FileInfo.
using System;
using System.Text;
using System.IO; //для работы с файловым вводом-выводом
using System.Text.RegularExpressions;

namespace MyProgram
{
 class Program
 {
 static void Main()
 {
   //создаем новый файл  и связываем с ним строковый поток
   FileInfo f = new FileInfo("text.txt"); 
   StreamWriter fOut = new StreamWriter(f.Create());
   //записываем в файл данные и закрываем строковый поток,
// при этом  связь с физическим файлом для f не рвется
   fOut.WriteLine("ОДИН ДВА ТРИ...");
   fOut.Close();
   //получаем информацию о файле
   Console.WriteLine("*******"+f.Name File Inf+"**************");
   Console.WriteLine("File size: {0}", f.Length);
   Console.WriteLine("Creation: {0}", f.CreationTime);
   Console.WriteLine("Attributes: {0}", f.Attributes.ToString());
  }
 }
}
Замечание. Еще раз удалите с диска d измененную папку prim, затем скопирует ее исходную версию из раздела 12 данного электронного учебника. 
Рассмотрим следующий пример:
  static void Main()
  {
    FileInfo f = new FileInfo(@"d:\prim\letter\letter1.txt"); 
    f.CopyTo(@"d:\prim\bmp\letter.txt");
    Directory.CreateDirectory(@"d:\prim\archives");
    f.MoveTo(@"d:\prim\archives\letter1.txt");
    f = new FileInfo(@"d:\prim\letter\letter2.txt");
    f.Delete();
  }
Задание. Посмотрите, что произойдет, если запустить эту программу еще раз. Дайте этому объяснение.
Рассмотрим еще один пример по удалению файлов:
static void printFile( FileInfo file)
{
 Console.WriteLine("***** "+file.Name+" *****");
 Console.WriteLine("File size: {0}", file.Length);
 Console.WriteLine("Creation: {0}", file.CreationTime);
 Console.WriteLine("Attributes: {0}", file.Attributes.ToString());
}

static void Main(string[] args)
{
 DirectoryInfo dir = new DirectoryInfo(@"d:\prim\bmp");
 FileInfo[] files = dir.GetFiles();
 if (files.Length!=0)
  {
   Console.WriteLine("Найдено {0} файла", files.Length);
   foreach (FileInfo f in files)
   {
    printFile(f);
    f.Delete();
   }
   Console.WriteLine("\nТеперь в каталоге содержится {0} файлов и можно его удалить", 
   dir.GetFiles().Length);
   dir.Delete();
  }
}
12.5 Класс File
Доступ к физическим файлам можно получать и через статические методы класса File. Большинство методов объекта Fileinfo представляют в этом смысле зеркальное отражение методов объекта File. 
Замечание. В последний раз удалите с диска d измененную папку prim, затем скопирует ее исходную версию из раздела 12данного электронного учебника. 
static void Main(string[] args)
{
 File.Copy(@"d:\prim\letter\letter1.txt",@"d:\prim\bmp\letter1.txt");
 Directory.CreateDirectory(@"d:\prim\archives");
 File.Move(@"d:\prim\letter\letter1.txt",@"d:\prim\archives\letter1.txt");
 File.Delete(@"d:\prim\letter\letter2.txt");
 Directory.Delete(@"d:\prim\letter");
}  
Имеет прямой смысл использовать статический класс File, когда требуется осуществить единственный вызов метода на объект. В этом случае вызов будет выполнен быстрее, поскольку .NET Framework не придется проходить через процедуру создания экземпляра нового объекта с последующим вызовом метода. Однако если приложение осуществляет несколько операций над файлом, то более разумным представляется создать экземпляр объекта FileInfo и использовать его методы. Это позволит сэкономить определенное время, поскольку объект будет заранее настроен на нужный файл в файловой системе, в то время как статическому классу придется каждый раз осуществлять его поиск заново.
Аналогичное правило действует и при выборе между классами Directory и DirectoryInfo.
Практикум
Программным путем в папке С:\temp создайте папки К1 и К2. 
1.	В папке К1 создайте файл t1.txt, в который запишите следующий текст :Иванов Иван Иванович, 1965 года рождения, место жительства г. Саратов. 
2.	Создайте файл t2.txt, в который запишите следующий текст: Петров Сергей Федорович, 1966 года рождения, место жительства г.Энгельс.
3.	В папке К2 создайте файл t3.txt, в который перепишите вначале текст из файла t1.txt, а затем из t2.txt
4.	Выведите развернутую информацию о созданных файлах.
5.	Файл t2.txt перенесите в папку K2
6.	Файл t1.txt скопируйте в папку K2
7.	Папку K2 переименуйте в ALL, а папку K1 удалите
8.	Вывести полную информацию о файлах папки All
Самостоятельная работа
Используя дополнительную литературу и Интернет, рассмотрите способы организации асинхронного ввода-вывода данных 
 
Лекция 13. Классы
13.1. Классы: основные понятия, данные, методы, конструкторы, свойства
Класс - это обобщенное понятие, определяющие характеристики и поведение некоторого множества объектов, называемых экземплярами класса. "Классический" класс содержит данные, определяющие свойства объектов класса, и методы, определяющие их поведение. Для Windows-приложений в класс добавляется третья составляющая - события, на которые может реагировать объект класса. Все классы библиотеки .Net, а также все классы, которые создает программист в среде .Net, имеют одного общего предка - класс object. 
Все программы, рассмотренные ранее, состояли из одного класса с одним методом Main и несколькими вспомогательными статическими методами. Теперь рассмотрим понятие "класс" более подробно. 
Описание класса содержит ключевое слово class, за которым следует его имя, а далее в фигурных скобках - тело класса. Кроме того, для класса можно задать его базовые классы (предки) и ряд необязательных атрибутов и спецификаторов, определяющих различные характеристики класса:
[ атрибуты ] [ спецификаторы ] class имя_класса [ : предки ] 
{тело_класса}
Простейший пример класса:
class Demo{}
Спецификаторы определяют свойства класса, а также доступность класса для других элементов программы. Возможные значения спецификаторов перечислены в следующей таблице:
№	Спецификатор	Описание
1	new	Задает новое описание класса взамен унаследованного от предка. Используется для вложения классов (в иерархии объектов).
2	public	Доступ к классу не ограничен
3	protected	Доступ только из данного или производного класса. Используется для вложенных классов.
4	internal	Доступ только из данной программы (сборки).
5	protected internal	Доступ только из данного и производного класса и из данной программы (сборки).
6	private	Доступ только из элементов класса, внутри которых описан данный класс. Используется для вложенных классов.
7	static	Статический класс. Позволяет обращатся к методам класса без создания экземпляра класса
8	sealed	Бесплодный класс. Запрещает наследование данного класса. Применяется в иерархии объектов.
9	abstract	Абстрактный класс. Применяется в иерархии объектов.
Спецификаторы 2-6 называются спецификаторами доступа. Они определяют, откуда можно непосредственно обращаться к данному классу. Спецификаторы доступа могут комбинироваться с остальными спецификаторами.
Замечание. Атрибуты будут рассмотрены позже.
Класс можно описывать непосредственно внутри пространства имен или внутри другого класса. В последнем случае класс называется вложенным. В зависимости от места описания класса некоторые из этих спецификаторов могут быть запрещены. В данном разделе мы рассмотрим классы, которые описываются непосредственно в пространстве имен. Для таких классов допускаются только два спецификатора: public и internal. По умолчанию, то есть если ни один спецификатор доступа не указан, подразумевается спецификатор internal.
Объекты создаются явным или неявным образом, то есть либо программистом, либо системой. Программист создает экземпляр класса с помощью операции new, например:
Demo a = new Demo (); // Создается экземпляр класса Demo
Если достаточный для хранения объекта объем памяти выделить не удалось, то генерируется исключение OutOfMemoryException. 
Для каждого объекта при его создании в памяти выделяется отдельная область, в которой хранятся его данные. В классе могут присутствовать статические элементы, которые существуют в единственном экземпляре для всех объектов класса. Статические данные часто называют данными класса, а остальные - данными экземпляра. Для работы с данными класса используются статические методы класса, для работы с данными экземпляра - методы экземпляра, или просто методы. 
До сих пор мы использовали в программах только данные (переменные и константы) и методы. В общем случае класс может содержать следующие функциональные элементы:
1.	Данные: переменные или константы. 
2.	Методы, реализующие не только вычисления, но и другие действия, выполняемые классом или его экземпляром. 
3.	Конструкторы (реализуют действия по инициализации экземпляров или класса в целом). 
4.	Свойства (определяют характеристики класса в соответствии со способами их задания и получения). 
5.	Деструкторы (определяют действия, которые необходимо выполнить до того, как объект будет уничтожен). 
6.	Индексаторы (обеспечивают возможность доступа к элементам класса по их порядковому номеру). 
7.	Операции (задают действия с объектами с помощью знаков операций). 
8.	События (определяют уведомления, которые может генерировать класс). 
9.	Типы (типы данных, внутренние по отношению к классу). 
В данном разделе мы рассмотрим первые четыре категории элементов класса
Прежде чем приступить к проектированию классов, необходимо поговорить о присваивании и сравнении объектов. Механизм выполнения присваивания один и тот же для величин любого типа, как ссылочного, так и размерного, однако результаты различаются. При присваивании значения копируется значение, а при присваивании ссылки - ссылка, поэтому после присваивания одного объекта другому мы получим две ссылки, указывающие на одну и ту же область памяти:
 
Пусть были созданы три объекта а, b и с, а затем выполнено присваивание b = с. Теперь ссылки b и с указывают на один и тот же объект. Старое значение b становится недоступным и очищается сборщиком мусора. 
Аналогичная ситуация с операцией проверки на равенство. Величины значимого типа равны, если равны их значения. Величины ссылочного типа равны, если они ссылаются на одни и те же данные. Так, объекты b и с равны, т.к. они ссылаются на одну и ту же область памяти. Но а не равно b даже при равенстве их значений.
13.2 Данные: поля и константы
Данные, содержащиеся в классе, могут быть переменными или константами и задаются в соответствии с правилами, рассмотренными в теме "Идентификаторы". При описании данных также можно указывать атрибуты и спецификаторы, задающие различные характеристики элементов. Синтаксис описания элемента данных приведен ниже:
[атрибуты] [спецификаторы] [const] тип имя [ = начальное_значение ]
Рассмотрим возможные спецификаторы для данных:
№	Спецификатор	Описание
1	new	Новое описание поля, скрывающее унаследованный элемент класса
2	public	Доступ к элементу не ограничен
3	protected	Доступ только из данного и производных классов 
4	internal	Доступ только из данной сборки
5	protected internal	Доступ только из данного и производных классов и из данной сборки
6	private	Доступ только из данного класса
7	static	Одно поле для всех экземпляров класса
8	readonly	Поле доступно только для чтения (значение таких полей можно установить либо при описании, либо в конструкторе)
9	volatile	Поле может изменяться другим процессом или системой
Замечание. Атрибуты будут рассмотрены позже.
Для констант можно использовать только спецификаторы 1-6.
По умолчанию элементы класса считаются закрытыми private. Для полей класса этот вид доступа является предпочтительным, поскольку поля определяют внутреннее строение класса, которое должно быть скрыто от пользователя. Все методы класса имеют непосредственный доступ к его закрытым полям.
Поля, описанные со спецификатором static, а также константы существуют в единственном экземпляре для всех объектов класса, поэтому к ним обращаются не через имя экземпляра, а через имя класса. Обращение к полю класса выполняется с помощью операции доступа (точка). Справа от точки задается имя поля, слева - имя экземпляра для обычных полей или имя класса для статических. Рассмотрим пример создания класса Demo и два способа обращения к его полям.
class Circle
{
 public int x=0;
 public int y=0;
 public int radius=3;
 public const double pi = 3.14;
 public static string name = "Окружность";
 double p;
 double s;
}

class Program
{
 static void Main()
 {
  Circle cr = new Circle();   //создание экземпляра класса
  Console.WriteLine("pi=" + Circle.pi);// обращение к константе
  Console.Write(Circle.name);// обращение к статическому полю
  //обращение к обычным полям
  Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", cr.x, cr.y, cr.radius);
  // Console.WriteLine(cr.p); - вызовет ошибку, т.к. поле p имеет тип private
               
  Console.Write("Введите коэффициент= ");
  int kof = int.Parse(Console.ReadLine());
  cr.x -= kof; cr.y += kof; cr.radius *= kof;
  Console.WriteLine(" Новая окружность с центром в точке ({0},{1}) и радиусом {2}",
  cr.x, cr.y, cr.radius);
  //cr.s = 2 * Circle.pi * cr.radius; - вызовет ошибку, т.к. поле s имеет тип private
 }
}
13.3 Методы
Замечание. Создание и использование методов было рассмотрено нами ранее. Теперь рассмотрим использование методов в контексте создания классов. 
Методы находятся в памяти в единственном экземпляре и используются всеми объектами одного класса совместно, поэтому необходимо обеспечить работу методов нестатических экземпляров с полями именно того объекта, для которого они были вызваны. Для этого в любой нестатический метод автоматически передается скрытый параметр this, в котором хранится ссылка на вызвавший функцию экземпляр.
В явном виде параметр this применяется для того, чтобы возвратить из метода ссылку на вызвавший объект, а также для идентификации поля в случае, если его имя совпадает с именем параметра метода, например:
class Circle
{
 public int x=0;
 public int y=0;
 public int radius=3;
 public const double pi = 3.14;
 public static string name = "Окружность";
  public Circle T() //метод возвращает ссылку на экземпляр класса
 {
  return this;
 }
 public void Set(int x, int y, int r) 
 {
  this.x = x;
  this.y = y;
 radius=r;
 }
}

class Program
{
 static void Main()
 {
  Circle cr = new Circle();   //создание экземпляра класса
  Console.WriteLine("pi=" + Circle.pi);// обращение к константе
  Console.Write(Circle.name);// обращение к статическому полю
  //обращение к обычным полям
  Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", cr.x, cr.y, cr.radius);      
  cr.Set(1, 1, 10);
  Console.WriteLine("Новая окружность с центром в точке ({0},{1}) и радиусом {2}", 
     cr.x, cr.y, cr.radius);
  Circle b=cr.T();//получаем ссылку на объект cr, аналог b=c
  Console.WriteLine("Новая ссылка на окружность с центром в точке ({0},{1}) 
       и радиусом {2}", b.x, b.y, b.radius);
  }
}
Конструкторы
Конструктор предназначен для инициализации объекта. Конструкторы делятся на конструкторы класса (для статических классов) и конструкторы экземпляра класса (всех остальных классов). 
Конструкторы экземпляра
Конструктор экземпляра вызывается автоматически при создании объекта класса с помощью операции new. Имя конструктора совпадает с именем класса. Рассмотрим основные свойства конструкторов:
1.	Конструктор не возвращает значение, даже типа void. 
2.	Класс может иметь несколько конструкторов с разными параметрами для разных видов инициализации. 
3.	Если программист не указал ни одного конструктора или какие-то поля не были инициализированы, полям значимых типов присваивается нуль, полям ссылочных типов - значение null. 
До сих пор мы задавали начальные значения полей класса при описании класса. Это удобно в том случае, когда для всех экземпляров класса начальные значения некоторого поля одинаковы. Если же при создании объектов требуется присваивать полю разные значения, это следует делать с помощью явного задания конструктора. В следующем примере добавлен конструктор и метод Print для вывода информации об объекте: 
 class Circle
 {
  public int x;
  public int y;
  public int radius;
  public const double pi = 3.14;
  public static string name = "Окружность";
  public Circle(int x, int y, int r)//конструктор
  {
   this.x = x;
   this.y = y;
   radius = r;
  }
  public void Print()
  {
   Console.Write(name);
   Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", x, y, radius); 
   Console.WriteLine();
  }
 }

 class Program
 {
  static void Main()
  {
   Circle a = new Circle(0, 0, 1);   //вызов конструктора 
   a.Print();
   Circle b=new Circle(10, 10, 5);//вызов конструктора 
   b.Print();
  }
 }
Часто бывает удобно задать в классе несколько конструкторов, чтобы обеспечить возможность инициализации объектов разными способами. Для этого конструкторы должны иметь разные сигнатуры. Рассмотрим это на примере:
 class Circle
 {
  public int x;
  public int y;
  public int radius;
  public const double pi = 3.14;
  public static string name = "Окружность";
  public Circle(int x, int y, int r)//конструктор 1
  {
   this.x = x;
   this.y = y;
   radius = r;
  }
  public Circle(int r)//конструктор 2
  {
   radius = r;
  }
  public void Print()
  {
   Console.Write(name);
   Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", x, y, radius); 
   Console.WriteLine();
  }
 }

 class Program
 {
  static void Main()
  {
   Circle a = new Circle(0, 0, 1);   //вызов конструктора 1
   a.Print();
   Circle b=new Circle(5);//вызов конструктора 2
   b.Print();
  }
 }
Обратите внимание на то, что в конструктое 2 не были инициализированы поля x, y, поэтому им присваивается значение 0.
Если один из конструкторов выполняет какие-либо действия, а другой должен делать то же самое плюс еще что-нибудь, то удобно вызвать первый конструктор из второго. Для этого используется уже известное вам ключевое слово this в другом контексте, например:
public Circle(int x, int y, int r):this(r)  //конструктор 1
{
 this.x = x;
 this.y = y;
}

public Circle(int r)    //конструктор 2
{
 radius = r;
}
Конструкция, находящаяся после двоеточия, называется инициализатором, то есть тем кодом, который исполняется до начала выполнения тела конструктора. В нашем случае конструктор 1 до выполнения своего кода вызывает конструктор 2.
13.4 Конструкторы класса
Статические классы содержат только статические члены, в том числе и контруктор, которые храняться в памяти в единственном экземпляре. Поэтому создавать экземпляры класса нет смысла. 
Чтобы подчеркнуть этот факт, в первой версии С# для статических классов создавали два конструктора, один - пустой закрытый (private) конструктор, второй - статический конструктор, не имеющий параметров. Первый конструктор предотвращал попытки создания экземпляров класса. Второй конструктор автоматически вызывается системой до первого обращения к любому элементу статического класса, выполняя необходимые действия по инициализации. Вышесказанное отражено в следующем примере:
class Demo
{
  static int a;
  static int b;
  private Demo(){}   //закрытый конструктор
  static Demo()       //статический конструктор
  {
   a=10;
   b=2;
  }
  public static void Print ()
  {
   Console.WriteLine("{0}+{1}={2}",a,b,a+b);
   Console.WriteLine("{0}*{1}={2}",a,b,a*b);
   Console.WriteLine("{0}-{1}={2}",a,b,a-b);
  }      
}

class Program
{
 static void Main()
 {
  //Demo S=new Demo();    //ошибка содать экземпляр класса нельзя
  Demo.Print();    
 }
}
В версию 2.0 введена возможность описывать статический класс, то есть класс с модификатором static. Экземпляры такого класса создавать запрещено, и кроме того, от него запрещено наследовать. Все элементы такого класса должны явным образом объявляться с модификатором static (константы и вложенные типы классифицируются как статические элементы автоматически). Конструктор экземпляра для статического класса задавать запрещается.
static class Demo
{
  static int a=20;
  static int b=10;
  public static void Print ()
  {
    Console.WriteLine("{0}+{1}={2}",a,b,a+b);
    Console.WriteLine("{0}*{1}={2}",a,b,a*b);
    Console.WriteLine("{0}-{1}={2}",a,b,a-b);
  }      
}

class Program
{
  static void Main()
  {
    Demo.Print();    
  }
}
13.5 Свойства
Иногда требуется создать поле, которое с одной стороны, должно быть доступно для использования, с другой стороны, возможность что-то сделать с этим полем имеет ограничения. Например, полю нельзя присваивать произвольное значение, а только значения из какого-то диапазона. Свойство предлагает простой и удобный способ решения этой проблемы.
Синтаксис свойства:
[атрибуты] [спецификаторы] тип имя_свойства
{
   [get код_доступа]
   [set код_доступа]
}
Значения спецификаторов для свойств и методов аналогичны. Чаще всего свойства объявляются как открытые (со спецификатором public).
Код доступа представляет собой блоки операторов, которые выполняются при получении (get) или установке (set) свойства. Может отсутствовать либо часть get, либо set, но не обе одновременно. Если отсутствует часть set, то свойство доступно только для чтения. Если отсутствует часть get, то свойство доступно только для записи.
Рассмотрим пример работы со свойствами, обращая внимание на то, что синтаксически чтение и запись свойства выглядят почти как методы. При этом get должен содержать оператор return, возвращающий выражение, для типа которого должно существовать неявное преобразование к типу свойства.
 class Circle
 {
  //закрытые поля
  int x;
  int y;
  int radius;
  public static string name = "Окружность";
  public Circle(int x, int y, int r):this(r)//конструктор 1
  {
   this.x = x;
   this.y = y;
  }
  public Circle(int r)//конструктор 2
  {
   radius = r;
  }
  public void Print()
  {
   Console.Write(name);
   Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", x, y, radius); 
   Console.WriteLine();
  }
  public int X //свойство для обращения к полю x
  {
   get 
   { 
    return x;
   }
   set 
   {
    x = value;
   }
  }
  public int Y //свойство для обращения к полю y
  {
   get 
   { 
    return y;
   }
   set 
   {
    y = value;
   }
  }
  public int R //свойство для обращения к полю radius
  {
   get 
   { 
    return radius;
   }
   set 
   {
    radius = value;
   }
  }
  public double P //свойство только для чтения
  {
   get 
   { 
    return 2* Math.PI *radius;
   }
   
  }
  public double S //свойство только для чтения
  {
   get 
   { 
    return Math.PI *radius*radius;
   }
   
  }
 }

 class Program
 {
  static void Main()
  {
   Circle a = new Circle(0, 0, 1);  //вызов конструктора
   a.Print();
   //установка новых значений
   a.X=1;
   a.Y=1;
   a.R=10;
   //a.S=100; //ошибка - свойство доступно только для чтения
   Console.WriteLine("центр=({0},{1}) 
                         радиус={2} 
                         периметр={3:f2} 
                         площадь={4:f2}", 
       a.X, a.Y, a.R, a.P, a.S);
  }
 }
13.6 Один класс - один файл
С добавлением новых классов в программу резко увеличивается ее размер, что затрудняет ее прочтение. Поэтому следует руководствоваться одним простым принципом "один класс - один файл". Для того чтобы создать новый файл для класса Circle выполним следующие действия:
1.	В окне Solution Explorer щелкните правой кнопкой на имени проекта Hello (на рисунке выделен жирным). 
 
2.	Выполните команду Add/Add Class… 
 
В поле Name напишите Сircle.cs и нажмите кнопку Add.
Теперь окно Solution Explorer выглядит следующим образом:
 
А файл Circle.cs выглядит следующим образом:
using System;

namespace ConsoleApplication1
{
 public class Circle
 {
  public Circle()
  {
   //
   // TODO: Add constructor logic here
   //
  }
 }
}
3.	Замените namespace ConsoleApplication1 на namespace MyProgram, для того чтобы идентификаторы файлов Program.cs и Circle.cs были определены в одном пространстве имен. 
4.	Перенесите класс Circle из файла Program.cs в файл Circle.cs. 
5.	Теперь запустите программу и посмотрите, что она делает. 
Самостоятельная работа
Используя дополнительную литературу и Интернет, рассмотрите следующие темы:
1.	Пространства имен: объявление, вложение одного пространства имен в другое, пространства имен, действующие по умолчанию. 
2.	Директивы препроцессора из назначение и использование. 
13.7. Классы: деструкторы, индексаторы
Деструкторы
В С# существует специальный вид метода, называемый деструктором, который вызывается сборщиком мусора непосредственно перед удалением объекта из памяти. 
Замечание. Напоминаем, что сборщик мусора удаляет объекты, на которые нет ссылок. Он работает в соответствии со своей внутренней стратегией в неизвестные для программиста моменты времени.
В деструкторе описываются действия, гарантирующие корректность последующего удаления объекта. Например, проверяется все ли ресурсы, используемые объектом, освобождены (файлы закрыты, удаленное соединение разорвано и т. п.). 
Синтаксис деструктора:
[атрибуты] [extern] ~имя_класса()
{тело_деструктора}
Деструктор не имеет параметров, не возвращает значения и не требует указания спецификаторов доступа. Его имя совпадает с именем класса и предваряется тильдой (~), символизирующей обратные по отношению к конструктору действия. Тело деструктора представляет собой блок или просто точку с запятой. Если деструктор определен как внешний, то используется спецификатор extern. Пример работы деструктора:
 class DemoArray
 {
  int[] MyArray;//закрытый массив
  string name; //закрытое поле

  public DemoArray(int size,int x, string name)//конструктор 
  {
   MyArray = new int[size];
   this.name = name;
   for (int i=0;i<size; ++i) MyArray[i]=x;
  }

  public void Print ()//метод
  {
   Console.Write(name+ " : ");
   foreach (int a in MyArray) Console.Write(a+" ");
   Console.WriteLine();
  }
  public int LengthN //свойство
  {
   get { return MyArray.Length; }
  }

  ~DemoArray()//деструктор
  {
   Console.WriteLine("сработал деструктор для объекта "+this.name);
  }
 }

 class Program
 {
  static void Main()
  {
   DemoArray a= new DemoArray(5,2, "один");
   a.Print();
   DemoArray b = new DemoArray(6,1, "два");
   b.Print();
   a = b;
   a.Print();
  }
 }
Задание. Обратите внимание на то, что деструкторы были вызваны автоматически. Дайте объяснение тому, в какой последовательности были вызваны деструкторы.
В общем случае применение деструкторов замедляет процесс сборки мусора. Поэтому создавать деструкторы следует только тогда, когда необходимо освободить какие-то ресурсы перед удалением объекта.
Индексаторы
Индексатор представляет собой разновидность свойства и обычно применяется для организации доступа к скрытым полям класса по индексу, например, так же, как мы обращаемся к элементу массива. Синтаксис индексатора аналогичен синтаксису свойства:
[атрибуты] [спецификаторы] тип this [список параметров] // последние [ ] являются элементами синтаксиса
{
 [get код_доступа]
 [set код_доступа]
}
Спецификаторы аналогичны спецификаторам свойств и методов. Индексаторы чаще всего объявляются со спецификатором public, поскольку они входят в интерфейс объекта. Атрибуты и спецификаторы могут отсутствовать.
Код доступа представляет собой блоки операторов, которые выполняются при получении (get) или установке (set) значения некоторого элемента класса. Может отсутствовать либо часть get, либо set, но не обе одновременно. Если отсутствует часть set, индексатор доступен только для чтения, если отсутствует часть get, индексатор доступен только для записи.
Список параметров содержит одно или несколько описаний индексов, по которым выполняется доступ к элементу. Чаще всего используется один индекс целого типа. 
В качестве примера рассмотрим индексатор, который позволяет получить n-член последовательности Фиббоначи:
 class DemoFib
 {
   
  public int this[int i] //индексатор, доступный только для чтения
  {
   get
   {
    if (i <=0) throw new Exception("недопустимое значение индекса");
    else if (i==1 || i==2) return 1;
    else 
    {int a=1, b=1, c;
     for (int j=3; j<=i; ++j)
     {
      c=a+b;
      a=b;
      b=c;
      }
     return b; 
    }
   }
  }
 }

 class Program
 {
  static void Main()
  {
   Console.Write("n=");
   int n=int.Parse(Console.ReadLine());
   DemoFib a=new DemoFib();
   try
   {
    Console.WriteLine("a[{0}]={1}",n,a[n]);
   }
   catch (Exception e) 
   {
    Console.WriteLine(e.Message);
   }
  }
 }
Индексаторы очень удобно применять для создания специализированных массивов, на работу с которыми накладываются какие-либо ограничения. Рассмотрим в качестве примера класс-массив, значения элементов которого находятся в диапазоне [0, 100]. Кроме того, при доступе к элементу проверяется, не вышел ли индекс за допустимые границы.
 class DemoArray
 {
  int[] MyArray;//закрытый массив
  
  public DemoArray(int size)//конструктор 
  {
   MyArray = new int[size];
  }
    
  public int LengthArray //свойство, возвращающее размерность
  {
   get { return MyArray.Length; }
  }

  public int this[int i] //индексатор
  {
   get
   {
    if (i <0 || i >= MyArray.Length) throw new Exception("выход за границы массива");
    else return MyArray[i];
   }
   set
   {
    if (i <0 || i >= MyArray.Length) throw new Exception("выход за границы массива");
    else if (value >= 0 && value <= 100) MyArray[i] = value;
    else throw new Exception("присваивается недопустимое значение");
   }
  }
 }

 class Program
 {
  static void Main()
  {
   DemoArray a = new DemoArray(10);
   for (int i=0; i<a.LengthArray; i++)
   {
    a[i] = i * i;    // использование индексатора в режиме записи
    Console.Write(a[i]+" ");// использование индексатора в режиме чтения
   }
   Console.WriteLine();
   try
   {
    //a[10]=100;
    //a[0]=200;
   }
   catch (Exception e)
   {
    Console.WriteLine(e.Message);
   }
  }
 }
Задание. В блоке try содержатся две закомментированные команды. Посмотрите, как проведет себя программа, если убрать комментарии: вначале один, затем другой.
Язык С# допускает использование многомерных индексаторов. Они применяются для работы с многомерными массивами. Рассмотрим на примере предыдущую задачу при условии, что организуется двумерный массив.
 class DemoArray
 {
  int[,] MyArray;//закрытый массив
  int n, m;//закрытые поля: размерность массива

  public DemoArray(int sizeN, int sizeM)//конструктор 
  {
   MyArray = new int[sizeN, sizeM];
   this.n = sizeN;
   this.m = sizeM;
  }

  public int LengthN //свойство, возвращающее количество строк
  {
   get { return n; }
  }

  public int LengthM //свойство, возвращающее количество строк
  {
   get { return m; }
  }

  public int this[int i, int j] //индексатор
  {
   get
   {
    if (i < 0 || i >= n || j < 0 || j >= m) throw new Exception("выход за границы массива");
    else return MyArray[i, j];
   }
   set
   {
    if (i < 0 || i >= n || j < 0 || j >= m) throw new Exception("выход за границы массива");
    else if (value >= 0 && value <= 100) MyArray[i, j] = value;
    else throw new Exception("присваивается недопустимое значение");
   }
  }
 }

  class Program
  {
   static void Main()
   {
    DemoArray a = new DemoArray(3, 3);
    for (int i = 0; i < a.LengthN; i++,Console.WriteLine())
    {
     for (int j = 0; j < a.LengthM; j++)
      {
       a[i, j] = i *j;    // использование индексатора в режиме записи
       Console.Write("{0,5}", a[i, j]);// использование индексатора в режиме чтения
      }
    }
    Console.WriteLine();
    try
    {
     //Console.WriteLine(a[3,3]);
     //a[0,0]=200;
    }
    catch (Exception e)
    {
     Console.WriteLine(e.Message);
    }
  
   }
  }

Задание. В блоке try содержатся две закомментированные команды. Посмотрите, как проведет себя программа если убрать комментарии - вначале один, затем другой.
13.8 Операции класса
С# позволяет переопределить большинство операций так, чтобы при использовании их объектами конкретного класса выполнялись действия, отличные от стандартных. Это дает возможность применять объекты собственных типов данных в составе выражений, например:
newObject x, y, z;
…
z = x+y; // используется операция сложения, переопределенная для класса newObject
Определение собственных операций класса называют перегрузкой операций. Перегрузка операций обычно применяется для классов, для которых семантика операций делает программу более понятной. Если назначение операции интуитивно непонятно, перегружать такую операцию не рекомендуется.
Операции класса описываются с помощью методов специального вида, синтаксис которых выглядит следующим образом: 
[ атрибуты] спецификаторы объявитель_операции
{тело}

В качестве спецификаторов одновременно используются ключевые слова public и static. Кроме того, операцию можно объявить как внешнюю - extern. Объявление операции может выглядеть по-разному, в зависимости от того, что мы перегружаем: унарную или бинарную операцию.
При описании операций необходимо соблюдать следующие правила:
1.	операция должна быть описана как открытый статический метод класса (public static); 
2.	параметры в операцию должны передаваться по значению (то есть недопустимо использовать параметры ref и out); 
3.	сигнатуры всех операций класса должны различаться; 
4.	типы, используемые в операции, должны иметь не меньшие права доступа, чем сама операция (то есть должны быть доступны при использовании операции). 
Унарные операции
В классе можно переопределять следующие унарные операции: + - ! ~ ++ --, а также константы true и false. При этом, если была перегружена константа true, то должна быть перегружена и константа false, и наоборот.
Синтаксис объявителя унарной операции: 
тип operator унарная_операция (параметр)
Примеры заголовков унарных операций:
public static int operator + (DemoArray m)
public static DemoArray operator --(DemoArray m)
public static bool operator true (DemoArray m)
Параметр, передаваемый в операцию, должен иметь тип класса, для которого она определяется. При этом операция должна возвращать:
1.	для операций +, -, !, ~ величину любого типа; 
2.	для операций ++, -- величину типа класса, для которого она определяется; 
3.	для операций true и false величину типа bool. 
Операции не должны изменять значение передаваемого им операнда. Операция, возвращающая величину типа класса, для которого она определяется, должна создать новый объект этого класса, выполнить с ним необходимые действия и передать его в качестве результата.
В качестве примера рассмотрим класс DemoArray, реализующий одномерный массив, в котором содержатся следующие функциональные элементы:
1.	конструктор, позволяющий создать объект-массив заданной размерности; 
2.	конструктор, позволяющий инициализировать объект-массив обычным массивом; 
3.	свойство, возвращающее размерность массива; 
4.	индексатор, позволяющий просматривать и устанавливать значение по индексу в закрытом поле-массиве; 
5.	метод вывода закрытого поля-массива; 
6.	перегрузка операции унарный минус (все элементы массива меняют свое значение на противоположное); 
7.	перегрузка операции инкремента (все элементы массива увеличивают свое значение на 1); 
8.	перегруза констант true и false (при обращении к объекту будет возвращаться значение true, если все элементы массива положительные, в противном случае, будет возвращаться значение false). 
class DemoArray
 {
  int[] MyArray;//закрытый массив
  
  public DemoArray(int size)//конструктор 1
  {
   MyArray = new int[size];
  }

  public DemoArray(params int[] arr)//конструктор 2
  {
   MyArray = new int[arr.Length];
   for (int i = 0; i < MyArray.Length; i++) MyArray[i] = arr[i];
  }
    
  public int LengthArray //свойство, возвращающее размерность
  {
   get { return MyArray.Length; }
  }

  public int this[int i] //индексатор
  {
   get
   {
    if (i < 0 || i >= MyArray.Length) throw new Exception("выход за границы массива");
    return MyArray[i];
   }
   set
   {
    if (i < 0 || i >= MyArray.Length) throw new Exception("выход за границы массива");
    else MyArray[i] = value;
   }
  }
  
  public static DemoArray operator -(DemoArray x) //перегрузка операции унарный минус
  {
   DemoArray temp = new DemoArray(x.LengthArray);
   for (int i = 0; i < x.LengthArray; ++i)
    temp[i] = -x[i];
   return temp;
  } 

  public static DemoArray operator ++(DemoArray x) //перегрузка операции инкремента
  {
   DemoArray temp = new DemoArray(x.LengthArray);
   for (int i = 0; i < x.LengthArray; ++i)
    temp[i] = x[i]+1;  
   return temp;
  }

  public static bool operator true(DemoArray a) //перегрузка константы true
  {
   foreach (int i in a.MyArray)
   {
    if (i<0)
    {
     return false;
    }
   }
   return true;
  }

  public static bool operator false(DemoArray a)//перегрузка константы false
  {
   foreach (int i in a.MyArray)
   {
    if (i>0)
    {
     return true;
    }
   }
   return false;
  }

  public void Print(string name) //метод - выводит поле-массив на экран
  {
   Console.WriteLine(name + ": ");
   for (int i = 0; i < MyArray.Length; i++)
    Console.Write(MyArray[i] + " ");
   Console.WriteLine();
  }
 }

 class Program
 {
  static void Main()
  {
   try
   {
    DemoArray Mas = new DemoArray(1, -4, 3, -5, 0); //вызов конструктора 2
    Mas.Print("Исходный массив");
    Console.WriteLine("\nУнарный минус");
    DemoArray newMas=-Mas; //применение операции унарного минуса 
    Mas.Print("Mассив Mas"); //обратите внимание, что создается новый объект и знаки меняются
    newMas.Print("Массив newMas"); //только у нового массива 
    Console.WriteLine("\nОперация префиксного инкремента");
    DemoArray Mas1=++Mas;
 Mas.Print("Mассив Mas"); 
    Mas1.Print("Mассив Mas1=++Mas");
    Console.WriteLine("\nОперация постфиксного инкремента");
    DemoArray Mas2=Mas++;
    Mas.Print("Mассив Mas"); 
    Mas2.Print("Mассив Mas2=Mas++");
    if (Mas)
     Console.WriteLine("\nВ массиве все элементы положительные\n");
    else Console.WriteLine("\nВ массиве есть не положительные элементы\n");
   }
   catch (Exception e)
   {
    Console.WriteLine(e.Message);
   }
 }
Задание. Добавьте в класс DemoArray переопределение унарного плюса (все элементы массива преобразуются в положительные), унарного декремента (все элементы массива уменьшаются на единицу) 
Бинарные операции
При разработке класса можно перегрузить следующие бинарные операции: + - * / % & | ^ << >> == != < > <= >=. Обратите внимание, операций присваивания в этом списке нет.
Синтаксис объявителя бинарной операции:
тип operator бинарная_операция (параметр1, параметр 2)
Примеры заголовков бинарных операций:
public static DemoArray operator + (DemoArray a, DemoArray b)
public static bool operator == (DemoArray a, DemoArray b)
При переопределении бинарных операций нужно учитывать следующие правила:
1.	Хотя бы один параметр, передаваемый в операцию, должен иметь тип класса, для которого она определяется. 
2.	Операция может возвращать величину любого типа. 
3.	Операции отношений определяются только парами и обычно возвращают логическое значение. Чаще всего переопределяются операции сравнения на равенство и неравенство для того, чтобы обеспечить сравнение значения некоторых полей объектов, а не ссылок на объект. Для того чтобы переопределить операции отношений, требуется знание стандартных интерфейсов, которые будут рассматриваться чуть позже. 
В качестве примера вернемся к классу DemoArray, реализующему одномерный массив, и добавим в него две версии переопределенной операции +: 
•	Вариант 1: добавляет к каждому элементу массива заданное число; 
•	Вариант 2: поэлементно складывает два массива 
class DemoArray
 {
  …
  public static DemoArray operator +(DemoArray x, int a) //вариант 1
  {
   DemoArray temp = new DemoArray(x.LengthArray);
   for (int i = 0; i < x.LengthArray; ++i)
    temp[i]=x[i]+a;
   return temp;
  }

  public static DemoArray operator +(DemoArray x, DemoArray y) //вариант 2
  {
   if (x.LengthArray == y.LengthArray)
   {
    DemoArray temp = new DemoArray(x.LengthArray);
    for (int i = 0; i < x.LengthArray; ++i)
     temp[i] = x[i] + y[i];
    return temp;
   }
   else throw new Exception("несоответствие размерностей"); 
  }
 }

 class Program
 {
  static void Main()
  {
   try
   {
    DemoArray a = new DemoArray(1, -4, 3, -5, 0);
    a.Print("Массива a");
    DemoArray b=a+10;
    b.Print("\nМассива b");
    DemoArray c = a+b;
    c.Print("\nМассива c");
   }
   catch (Exception e)
   {
    Console.WriteLine(e.Message);
   }
  }
 }
Задание. Добавьте в класс DemoArray переопределение бинарного минуса (из всех элементов массива вычитается заданное число) и операции & (поэлементно сравнивает два массива, если соответствующие элементы попарно совпадают, то операция возвращает значение true, иначе false).

Операции преобразования типов
Операции преобразования типов обеспечивают возможность явного и неявного преобразования между пользовательскими типами данных. Синтаксис объявителя операции преобразования типов выглядит следующим образом:
explicit operator целевой_тип (параметр)  //явное преобразование
implicit operator целевой_тип (параметр)  //неявное преобразование
Эти операции выполняют преобразование из типа параметра в тип, указанный в заголовке операции. Одним из этих типов должен быть класс, для которого выполняется преобразование.
Неявное преобразование выполняется автоматически в следующих ситуациях:
1.	при присваивании объекта переменной целевого типа; 
2.	при использовании объекта в выражении, содержащем переменные целевого типа; 
3.	при передаче объекта в метод параметра целевого типа; 
4.	при явном приведении типа. 
Явное преобразование выполняется при использовании операции приведения типа.
При определении операции преобразования типа следует учитывать следующие особенности:
1.	тип возвращаемого значения (целевой_тип) включается в сигнатуру объявителя операции; 
2.	ключевые слова explicit и implicit не включаются в сигнатуру объявителя операции. 
Следовательно, для одного и того класса нельзя определить одновременно и явную, и неявную версию. Однако, т.к. неявное преобразование автоматически выполнятся при явном использовании операции приведения типа, то достаточно разработать только неявную версию операции преобразования типа.
В качестве примера вернемся к классу DemoArray, реализующему одномерный массив, и добавим в него неявную версию переопределения типа DemoArray в тип одномерный массив и наоборот: 
class DemoArray
 {
  …

  public static implicit operator DemoArray (int []a) //неявное преобразование типа int [] в DemoArray
  {
   return new DemoArray(a); 
  }

  public static implicit operator int [](DemoArray a) //неявное преобразование типа DemoArray в int []
  {
   int []temp=new int[a.LengthArray];
   for (int i = 0; i < a.LengthArray; ++i)
    temp[i] = a[i];
   return temp; 
  }
 }

 class Program
 {
  static void arrayPrint(string name, int[]a) //метод, который позволяет вывести на экран одномерный массив
  {
   Console.WriteLine(name + ": ");
   for (int i = 0; i < a.Length; i++)
    Console.Write(a[i] + " ");
   Console.WriteLine();
  }

  static void Main()
  {
   try
   {
    DemoArray a = new DemoArray(1, -4, 3, -5, 0);
    int []mas1=a; //неявное преобразование типа DemoArray в int []
    int []mas2=(int []) a; //явное преобразование типа DemoArray в int []
    DemoArray b1 =mas1; //неявное преобразование типа int [] в DemoArray    
    DemoArray b2 =(DemoArray)mas2; //явное преобразование типа int [] в DemoArray
    
    //изменение значений
    mas1[0]=0;  mas2[0]=-1;   
    b1[0]=100;  b2[0]=-100;

    //вывод на экран
    a.Print("Массива a"); 
    arrayPrint("Maccив mas1", mas1);
    arrayPrint("Maccив mas2", mas2);
    b1.Print("Массива b1");
    b2.Print("Массива b2");
    }
   catch (Exception e)
   {
    Console.WriteLine(e.Message);
   }
  }
 }
Задание. В методе Main используется операция приведения типа DemoArray к int[] (и наоборот) в явном виде, хотя явная версия операции преобразования типа DemoArray к int[] не была определена. Объясните, почему возможно использование явного приведения типа.
Самостоятельная работа
Используя дополнительную литературу и Интернет, рассмотрите следующие темы:
1.	Сборки: понятие сборки, создание и использование. 
2.	Создание и использование библиотек.
 
Лекция 14. Нследование классов, иерархия классов
14.1 Иерархия и наследование
Управлять большим количеством разрозненных классов довольно сложно. С этой проблемой можно справиться путем упорядочивания и ранжирования классов, то есть объединяя общие для нескольких классов свойства в одном классе и используя его в качестве базового. Эту возможность предоставляет механизм наследования.
Наследование применяется для следующих взаимосвязанных целей: 
1.	исключения из программы повторяющихся фрагментов кода; 
2.	упрощения модификации программы; 
3.	упрощения создания новых программ на основе существующих. 
Наследование является единственной возможностью использовать объекты, исходный код которых недоступен, но в которые требуется внести изменения.
Кроме механизма наследования в данном разделе мы рассмотрим такие важные понятия ООП как полиморфизм и инкапсуляцию , которые также принимают участие в формировании иерархии классов. 
Наследование
Класс в С# может иметь произвольное количество потомков и только одного предка. При описании класса имя его предка записывается в заголовке класса после двоеточия. Если имя предка не указано, предком считается базовый класс всей иерархии System.Object. Синтаксис наследования:
[атрибуты] [спецификаторы] class имя_класса [: предки]
{ тело_класса}
Обратите внимание на то, что слово "предки" присутствует в описании класса во множественном числе, хотя класс может иметь только одного предка. Это связано с тем, что класс наряду с единственным предком-классом может наследовать интерфейсы (специальный вид классов, не имеющих реализации). Интерфейсы будут рассмотрены чуть позже.
Класс, который наследуется, называется базовым. Класс, который наследует базовый класс, называется производным. Производный класс, наследует все переменные, методы, свойства, операторы и индексаторы, определенные в базовом классе, кроме того в производный класс могут быть добавлены уникальные элементы или переопределены существующие.
Рассмотрим наследование классов на примере геометрических фигур на плоскости. В качестве базового класса создадим класс DemoPoint (точка на плоскости), в качестве производного класса от DemoPoint класс DemoLine (отрезок на плоскости):
class DemoPoint //базовый класс
  {
    public int x;
    public int y;
    public void Show()
    {
      Console.WriteLine("({0}, {1})", x, y);
    }
  }

  class DemoLine : DemoPoint //производный класс
  {
    public int xEnd;
    public int yEnd;
    public  void Show()
    {
      Console.WriteLine("({0}, {1})-({2}, {3})", x, y ,xEnd, yEnd);
    }
  }

  class Program
  {
    static void Main()
    {
      DemoPoint point = new DemoPoint();
      point.x = 0;
      point.y = 0;
      point.Show();
      DemoLine line = new DemoLine();
      line.x = 2;  line.y = 2;
      line.xEnd = 10;  line.yEnd = 10;
      line.Show();
    }
  }
Экземпляр класса DemoLine с одинаковой легкостью использует как собственные поля и методы, так и унаследованные от класса DemoPoint. При этом, если метод производного класса называется также как и метод базового класса, то вызывается метод производного. Однако компилятором будет сгенерировано предупреждение:
 


Чтобы избежать подобного предупреждения необходимо перед одноименным членом производного класса, в данном случае перед методом Show в классе DemoLine, поставить спецификатор new. Данный спецификатор скрывает одноименный член базового класса и предупреждений выдаваться не будет.
Использование защищенного доступа
В нашем примере поля x и у базового класса были открыты для доступа (public). Если убрать public, то поля автоматически станут закрытыми для доступа (private), в том числе и для доступа из производного класса. Решить проблему доступа к закрытым полям базового класса из производного можно двумя способами: используя свойства класса или спецификатор protected. При объявлении какого-то члена класса с помощью спецификатора protected, он становится закрытым для всех классов, кроме производных.
class DemoPoint
  {
      protected int x;
      protected int y;
      public void Show()
      {
        Console.WriteLine("({0}, {1})",x, y);
      }
    }

    class DemoLine : DemoPoint
    {
      public int xEnd;
      public int yEnd;
      public new void Show()
      {
        x=2; y=2; //доступ к закрытым полям базового класса
        Console.WriteLine("({0}, {1})-({2}, {3})", x, y, xEnd, yEnd);
      }
    }
   
    class Program
    {
      static void Main()
      {
        DemoPoint point = new DemoPoint();
        point.Show();
        DemoLine line = new DemoLine();
        //line.x = 2; line.y = 2; //доступ к полям закрыт
        line.xEnd = 10;    line.yEnd = 10;
        line.Show();
      }
    }
  }
Обратите внимание на то, что доступ к полям х и y из класса Program невозможен, а из производного класса DemoLine возможен.
14.2 Наследование конструкторов
В иерархии классов как базовые, так и производные классы могут иметь собственные конструкторы. При этом конструктор базового класса создает часть объекта, соответствующую базовому классу, а конструктор производного класса - часть объекта, соответствующую производному классу. Так как базовый класс не имеет доступа к элементам производного класса, то их конструкторы должны быть раздельными. 
В предыдущем примере классы создавались за счет автоматического вызова средствами С# конструктора по умолчанию. Добавим конструктор только в производный класс DemoLine:
class DemoPoint
{
  protected int x;
  protected int y;
  public void Show()
  {
    Console.WriteLine("({0}, {1})",x, y);
  }
}

class DemoLine : DemoPoint
{
  public int xEnd;
  public int yEnd;
  new public void Show()
  {
    Console.WriteLine("({0}, {1})-({2}, {3})", x, y, xEnd, yEnd);
  }

  public DemoLine(int x1, int y1, int x2, int y2) //конструктор производного класса
  {
    x = x1;    y = y1;
    xEnd = x2; yEnd = y2;
  }
}

class Program
{
  static void Main()
  {
    DemoPoint point = new DemoPoint(); //вызывается конструктор по умолчанию 
    point.Show();
    DemoLine line = new DemoLine(2, 2, 10, 10); //вызывается собственный конструктор 
    line.Show();
  }
}
В данном случае конструктор определяется только в производном классе, поэтому часть объекта, соответствующая базовому классу, создается автоматически с помощью конструктора по умолчанию, а часть объекта, соответствующая производному классу, создается собственным конструктором.
Если же конструкторы определены и в базовом, и в производном классе, то процесс создания объектов несколько усложняется, т.к. должны выполниться конструкторы обоих классов. В этом случае используется ключевое слово base, которое имеет два назначения:
1.	позволяет вызвать конструктор базового класса: 
Производный класс может вызывать конструктор, определенный в его базовом классе, используя расширенную форму объявления конструктора и ключевое слово base. Формат расширенного объявления:
конструктор_производного_класса (список_параметров) : base (список_аргументов)
{ тело конструктора }

где с помощью элемента списка аргументов передаются параметры конструктору базового класса. Например: 

class DemoPoint
    {
      protected int x;
      protected int y;
      public void Show()
      {
        Console.WriteLine("({0}, {1})",x, y);
}
      public DemoPoint (int x, int y)//конструктор базового класса
      {
        this.x=x;  this.y=y;
      }
    }

class DemoLine : DemoPoint
    {
      public int xEnd;
      public int yEnd;
      new public void Show()
      {
        Console.WriteLine("({0}, {1})-({2}, {3})", x, y, xEnd, yEnd);
      }

      public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1) //конструктор производного класса
      {
        xEnd = x2; yEnd = y2;
      }
    }

class Program
    {
      static void Main()
      {
        DemoPoint point= new DemoPoint(5, 5);
        point.Show();
        DemoLine line = new DemoLine( 2, 2, 10, 10);
        line.Show();
      }
    }
Задание. Объясните, почему в конструкторе базового класса для инициализации полей используется параметр this, а в конструкторе производного класса нет.
В общем случае с помощью ключевого слова base можно вызвать конструктор любой формы, определенный в базовом классе. Реально же выполнится тот конструктор, параметры которого будут соответствовать переданным при вызове аргументам. Например:
class DemoPoint
{
  protected int x;
  protected int y;
  public void Show()
  {
    Console.WriteLine("({0}, {1})",x, y);
}
  public DemoPoint () //конструктор базового класса по умолчанию
  {
    this.x=1;  this.y=1;
  }
  public DemoPoint (int x, int y) //конструктор базового класса с параметрами
  {
    this.x=x;  this.y=y;
  }
}

class DemoLine : DemoPoint
{
  public int xEnd;
  public int yEnd;
  new public void Show()
  {
    Console.WriteLine("({0}, {1})-({2}, {3})", x, y, xEnd, yEnd);
  }
  public DemoLine() //конструктор производного класса по умолчанию
  {
    xEnd = 100; yEnd = 100;
  }
  public DemoLine(int x2, int y2) //конструктор производного класса с двумя параметрами
  {
    xEnd = x2; yEnd = y2;
  }  
  //конструктор производного класса с четырьмя параметрами
  public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1)
  {
    xEnd = x2; yEnd = y2;
  }
}

class Program
{
  static void Main()
  {
    DemoPoint point1= new DemoPoint(); //вызов конструктора по умолчанию
    DemoPoint point2= new DemoPoint(5, 5); //вызов конструктора с параметрами
    point1.Show();
    point2.Show();
    DemoLine line1 = new DemoLine();//вызов конструктора по умолчанию
    DemoLine line2 = new DemoLine(4, 4);   //вызов конструктора с двумя параметрами
    //вызов конструктора с четырьмя параметрами
    DemoLine line3 = new DemoLine(2, 2, 10, 10);
    line1.Show();
    line2.Show();
    line3.Show();
  }
}
Задание. Объясните, как при вызове конструкторе производного класса инициируется вызов конструктора базового класса.
2.	позволяет получить доступ к члену базового класса, который скрыт "за" членом производного класса. 
В этом случае ключевое слово base действует подобно ссылке this, за исключением того, что ссылка base всегда указывает на базовый класс для производного класса, в котором она используется. В этом случае формат ее записи выглядит следующим образом:
base.член_класса
Здесь в качестве элемента член_класса можно указывать либо метод, либо поле экземпляра. Эта форма ссылки base наиболее применима в тех случаях, когда имя члена в производном классе скрывает член с таким же именем в базовом классе. 
class DemoPoint
  {
    protected int x;
    protected int y;
    public void Show()
    {
      Console.Write("({0}, {1})",x, y);
    }
    public DemoPoint (int x, int y)//конструктор базового класса
    {
      this.x=x;  this.y=y;
    }
  }

  class DemoLine : DemoPoint
  {
    public int xEnd;
    public int yEnd;
    new public void Show()
    {
      base.Show(); //вызов члена базового класса
      Console.WriteLine("-({0}, {1})", xEnd, yEnd);
    }

    public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1) //конструктор производного класса
    {
      xEnd = x2; yEnd = y2;
    }
  }

  class Program
  {
    static void Main()
    {
      DemoLine line = new DemoLine( 2, 2, 10, 10);
      line.Show();
    }
  }
Несмотря на то, что метод Show в классе DemoLine скрывает одноименный метод в классе DemoPoint, ссылка base позволяет получить доступ к методу Show в базовом классе. Аналогично с помощью ссылки base можно получить доступ к одноименным полям базового класса.
14.3 Многоуровневая иерархия
До сих пор мы рассматривали простой тип иерархии классов, который состоит из одного базового и одного производного класса. В общем случае можно построить иерархию классов, состоящую из любого количества уровней наследования. Рассмотрим следующую иерархию классов:
 
class DemoPoint
{
  protected int x;
  protected int y;
  public void Show()
  {
    Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
  }
  public DemoPoint (int x, int y)
  {
    this.x=x;  this.y=y;
  }
}

class DemoShape : DemoPoint
{
  protected int z;
  new public void Show()
  {
    Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
  }
  public DemoShape(int x, int y, int z):base(x, y) 
  {
    this.z=z;
  }
}

class DemoLine : DemoPoint
{
  protected int x2;
  protected int y2;
  new public void Show()
  {
    Console.WriteLine("отрезок на плоскости: ({0}, {1})-({2},{3})",x,y, x2, y2);
  }
  public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1) 
  {
    this.x2 = x2; this.y2 = y2;
  }
}

class DemoTriangle: DemoLine
{
  protected int x3;
  protected int y3;
  new public void Show()
  {
    Console.WriteLine("треугольник на плоскости: ({0}, {1})-({2},{3})-({4},{5})",x,y, x2, y2, x3, y3);
  }
  public DemoTriangle(int x1, int y1, int x2, int y2, int x3, int y3):base(x1, y1, x2, y2)    
  {
    this.x3 = x3; this.y3 = y3;
  }
}
  
class Program
{
  static void Main()
  {
    DemoPoint point = new DemoPoint(1,1);
    point.Show();
    DemoShape pointShape = new DemoShape(1,1,1);
    pointShape.Show();
    DemoLine line = new DemoLine( 2, 2, 10, 10);
    line.Show();
    DemoTriangle triangle = new DemoTriangle (0,0,0,3,4,0);
    triangle.Show();
  }
}
14.4 Переменные базового класса и производного класса	
С# является языком со строгой типизацией, в нем требуется строгое соблюдение совместимости типов с учетом стандартных преобразований типов. Из чего следует, что переменная одного типа обычно не может ссылаться на объект другого ссылочного типа. За одним небольшим исключением - ссылочная переменная базового класса может ссылаться на объект любого производного класса. Продемонстрируем это на примере:
class DemoPoint
  {
    public int x;
    public int y;
    public void Show()
    {
      Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
    }
    public DemoPoint (int x, int y)
    {
      this.x=x;  this.y=y;
    }
  }

class DemoShape : DemoPoint
  {
    public int z;
    new public void Show()
    {
      Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
    }
    public DemoShape(int x, int y, int z):base(x, y) 
    {
      this.z=z;
    }
}

class Program
  {
    static void Main()
    {
      DemoPoint point1 = new DemoPoint(0,1);
      Console.WriteLine("({0}, {1})",point1.x,point1.y);
      DemoShape pointShape = new DemoShape(2,3,4);
      Console.WriteLine("({0}, {1}, {2})",pointShape.x, pointShape.y, pointShape.z);
      DemoPoint point2=pointShape; //допустимая операция
      //ошибка - не соответствие типов указателей
      //pointShape=point1; 
      Console.WriteLine("({0}, {1})", point2.x, point2.y);
      //ошибка, т.к. в классе DemoPoint нет поля z
      //Console.WriteLine("({0}, {1}, {2})", point2.x, point2.y, point2.z);
    }
  }
Ошибка возникнет и при попытке через объект point2 обратиться к методу Show. Например, point2.Show(). В этом случае компилятор не сможет определить, какой метод Show вызвать - для базового или для производного класса. Для решения данной проблемы можно воспользоваться таким понятием как полиморфизм, который основывается на механизме виртуальных методов.
14.5 Виртуальные методы
Виртуальный метод - это метод, который объявлен в базовом классе с использованием ключевого слова virtual, и затем переопределен в производном классе с помощью ключевого слова override. При этом если реализована многоуровневая иерархия классов, то каждый производный класс может иметь свою собственную версию виртуального метода. Этот факт особенно полезен в случае, когда доступ к объекту производного класса осуществляется через ссылочную переменную базового класса. В этой ситуации С# сам выбирает какую версию виртуального метода нужно вызвать. Этот выбор производится по типу объекта, на которую ссылается данная ссылка. Например: 
class DemoPoint //базовый класс
  {
    protected int x;
    protected int y;
    public virtual void Show()  //виртуальный метод
    {
      Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
    }
    public DemoPoint (int x, int y)
    {
      this.x=x;  this.y=y;
    }
  }
  class DemoShape : DemoPoint //производный класс
  {
    protected int z;
    public override void Show() //перегрузка виртуального метода
    {
      Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
    }

    public DemoShape(int x, int y, int z):base(x, y) //конструктор производного класса
    {
      this.z=z;
    }

  }
  class DemoLine : DemoPoint //производный класс
  {
    protected int x2;
    protected int y2;
    public override void Show()  //перегрузка виртуального метода
    {
      Console.WriteLine("отрезок на плоскости: ({0}, {1})-({2},{3})",x,y, x2, y2);
    }
    public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1) 
    {
      this.x2 = x2; this.y2 = y2;
    }
  }
  
  class Program
  {
    static void Main()
    {
      DemoPoint point1 = new DemoPoint(0,1);
      point1.Show();
      DemoShape pointShape = new DemoShape(2,3,4);
      pointShape.Show();
      DemoLine line = new DemoLine(0,0, 10, 10);
      line.Show();
      Console.WriteLine();
      //использование ссылки базового класса на объекты производных классов
      DemoPoint point2=pointShape;
      point2.Show();
      point2=line;
      point2.Show(); 
    }
  }
Таким образом, благодаря полиморфизму через ссылочную переменную возможно обращаться к объектам разного типа, а также с помощью одного и того же имени выполнять различные действия.
14.6 Абстрактные методы и классы
Иногда полезно создать базовый класс, определяющий только своего рода "пустой бланк", который унаследуют все производные классы, причем каждый из них заполнит этот "бланк" собственной информацией. Такой класс определяет структуру методов, которые производные классы должны реализовать, но сам при этом не обеспечивает реализации этих методов. Подобная ситуация может возникнуть, когда базовый класс попросту не в состоянии реализовать метод. В данной ситуации разрабатываются абстрактные методы или целые абстрактные классы.
Абстрактный метод создается с помощью модификатора abstract. Он не имеет тела и, следовательно, не реализуется базовым классом, а производные классы должны его обязательно переопределить. Абстрактный метод автоматически является виртуальным, однако использовать спецификатор virtual не нужно. Более того, если вы попытаетесь использовать два спецификатора одновременно, abstract и virtual, то компилятор выдаст сообщение об ошибке. 
Задание. Подумайте, можно ли спецификатор abstract применять в сочетании со спецификатором static. И объясните почему?
Если класс содержит один или несколько абстрактных классов, то его также нужно объявить как абстрактный, используя спецификатор abstract перед class. Поскольку абстрактный класс полностью не реализован, то невозможно создать экземпляр класса с помощью операции new. Например, если класс Demo определен как абстрактный, то попытка создать экземпляр класса Demo повлечет ошибку:
Demo a = new Demo();
Однако, можно создать массив ссылок, используя этот же абстрактный класс:
Demo [] Ob=new Demo[5];
Если производный класс наследует абстрактный, то он должен полностью переопределить все абстрактные методы базового класса или также быть объявлен как абстрактный. Таким образом, спецификатор abstract наследуется до тех пор, пока в производном классе не будут реализованы все абстрактные методы.
Рассмотрим пример использования абстрактных методов и классов.
abstract class Demo //абстрактный класс
  {
    abstract public void Show();//абстрактный метод
    abstract public double Dlina();//абстрактный метод
  }

  class DemoPoint:Demo //производный класс от абстрактного
  {
    protected int x;
    protected int y;
    public DemoPoint (int x, int y)
    {
      this.x=x;  this.y=y;
    }
    public override void Show() //переопределение абстрактного метода
    {
      Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
    }
    public override double Dlina()  //переопределение абстрактного метода
    {
      return Math.Sqrt(x*x+y*y);
    }
  }

  class DemoShape : DemoPoint //производный класс 
  {
    protected int z;
    public DemoShape(int x, int y, int z):base(x, y) 
    {
      this.z=z;
    }
    public override void Show()  //переопределение абстрактного метода
    {
      Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
    }
    public override double Dlina()  //переопределение абстрактного метода
    {
      return Math.Sqrt(x*x+y*y+z*z);
    }
  }

  class DemoLine : DemoPoint //производный класс
  {
    protected int x2;
    protected int y2;
    public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1) 
    {
      this.x2 = x2; this.y2 = y2;
    }
    public override void Show()  //переопределение абстрактного метода
    {
      Console.WriteLine("отрезок на плоскости: ({0}, {1})-({2},{3})",x,y, x2, y2);
    }
    public override double Dlina()  //переопределение абстрактного метода
    {
      return Math.Sqrt((x-x2)*(x-x2)+(y-y2)*(y-y2));
    }
  }
  
  class Program
  {
    static void Main()
    {
      Demo [] Ob=new Demo[5]; //массив ссылок
      //заполнения массива ссылками на объекты производных классов
      Ob[0]=new DemoPoint(1,1);
      Ob[1]=new DemoShape(1,1,1);
      Ob[2]=new DemoLine(0,3,4,0);
      Ob[3]=new DemoLine(2,1,2,10);
      Ob[4]=new DemoPoint(0,100);
      foreach (Demo a in Ob) //просмотр массива
      {
        a.Show();
        Console.WriteLine("Dlina: {0:f2}\n", a.Dlina());
      }
    }
  }
14.7 Запрет наследования
В С# есть ключевое слово sealed, позволяющее описать класс, от которого запрещено наследование. Например:
sealed class Demo {   … }
class newDemo: Demo {   …  }  // ошибка
Задание. Подумайте: 
1.	для чего может создаваться класс, от которого нельзя наследовать? 
2.	можно ли использовать сочетание спецификаторов sealed и abstract при описании класса, и почему? 
Самостоятельная работа
Используя дополнительную литературу и Интернет, рассмотрите следующие темы:
1.	Идентификация типов во время выполнения программы: использование операторов is, as, typeof. 
2.	Отражение и его использование для получения информации о методах, конструкторов типов, типов из сборок и автоматического распознавания типов.
 
Лекция 15. Интерфейсы и структуры
15.1. Пользовательские и стандартные интерфейсы
В объектно-ориентированном программировании иногда требуется определить, что класс должен делать, а не как он будет это делать. Такой подход может быть реализован с помощью абстрактного класса, при этом в абстрактном классе часть методов может быть реализована, часть нет. Кроме этого в С# предусмотрена возможность полностью отделить структуру класса от его реализации. Это делается с помощью интерфейса.
Интерфейс - это "крайний случай" абстрактного класса, в котором не предусмотрена ни одна реализация члена класса. Таким образом, интерфейс описывает функциональность классов, но не определяет способа ее реализации. Каждый класс, наследуя интерфейс, может реализовать его элементы по-своему. Так достигается полиморфизм - объекты разных классов по-разному реагируют на вызовы одного и того же метода. 
Синтаксис интерфейса:
[атрибуты] [спецификаторы] interface имя_интерфейса : [предки]
{
//объявление функциональных членов интерфейса без реализации
… 
}
Для интерфейса могут быть указаны спецификаторы new, public, internal и private. Спецификатор new применяется для вложенных интерфейсов и имеет такой же смысл, как и соответствующий спецификатор метода класса. По умолчанию интерфейс доступен только из сборки, в которой он описан (internal). 
Все функциональные члены интерфейса по умолчанию являются открытыми (public) и абстрактными (abstract), поэтому при описании метода указывается только типа возвращаемого им значения и сигнатуры. 
В качестве функциональных членов в интерфейсе можно объявлять сигнатуры методов, свойств, индексаторов и событий (для Windows-приложений). Интерфейсы не могут содержать члены данных, конструкторы, деструкторы или операторные методы (методы, переопределяющие операции). Ни один член интерфейса не может быть объявлен статическим.
Напомним, что класс может наследовать один базовый класс и несколько интерфейсов. Класс, наследующий интерфейс, должен реализовать его в полном объеме. Т.к. функциональные члены, объявленные внутри интерфейса, являются открытыми, то их реализация также должна быть открытой. Кроме того, сигнатура функционального члена в реализации должна в точности совпадать с сигнатурой, заданной в определении интерфейса.
В качестве примера рассмотрим интерфейс IDemo и его реализацию для классов DemoPoint и DemoLine из предыдущей лекции:
//определение интерфейса
interface IDemo
 {
  void Show();   //объявление метода
  double Dlina();   //объявление метода
  int X {get;}   //объявление свойства, доступного только для чтения
  int this [int i]{get;set;} //объявление индексатора, доступного для чтения-записи
 }

//класс DemoPoint наследует интерфейс IDemo
class DemoPoint:IDemo
 {
  protected int x;
  protected int y;
  public DemoPoint ( int x, int y) 
  {
   this.x=x; this.y=y;
   }
  public void Show() //реализация метода, объявленного в интерфейсе
  {
   Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
  }
  public double Dlina() //реализация метода, объявленного в интерфейсе
  {
   return Math.Sqrt(x*x+y*y);
  } 
  public int X //реализация свойства, объявленного в интерфейсе
  {
   get
   {
    return x;
   }
  }

  public int this [int i] //реализация индексатора, объявленного в интерфейсе
  {
   get
   {
    if (i==0) return x;
    else if (i==1) return y;
    else throw new Exception ("недопустимое значение индекса");
}
   set
   {
    if (i==0) x=value;
    else if (i==1) y=value;
    else throw new Exception ("недопустимое значение индекса");
   }
  }
 }

//класс DemoShape наследует класс DemoPoint и интерфейс IDemo
class DemoShape : DemoPoint, IDemo
{
  protected int z;
  public DemoShape(int x, int y, int z):base(x, y) 
  {
   this.z=z;
  }
  // реализация метода, объявленного в интерфейсе, с сокрытием одноименного метода из 
  //базового класса
  public new void Show() 
  {
   Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
  }
  // реализация метода, объявленного в интерфейсе, с сокрытием одноименного метода из 
  //базового класса
  public new double Dlina()
  {
   return Math.Sqrt(x*x+y*y+z*z);
  }
  // реализация индексатора, объявленного в интерфейсе, с сокрытием одноименного 
  // индексатора из базового класса
  public new int this [int i] 
  {
   get
   {
    if (i==0) return x;
    else if (i==1) return y;
     else if (i==2) return z;
      else throw new Exception ("недопустимое значение индекса");
   }
   set
   {
    if (i==0) x=value;
    else if (i==1) y=value;
     else if (i==2) z=value;
     else throw new Exception ("недопустимое значение индекса");
   }
  }
  
 }

class Program
 {
  static void Main()
  {
   //создание массива интерфейсных ссылок
   IDemo []a =new IDemo[4];
   //заполнение массива
   a[0]=new DemoPoint(0,1);
   a[1]=new DemoPoint(-3, 0);
   a[2]=new DemoShape(3,4,0);
   a[3]= new DemoShape(0,5, 6);
   //просмотр массива
   foreach (IDemo x in a)
   {
    x.Show();
    Console.WriteLine("Dlina={0:f2}",x.Dlina());
    Console.WriteLine("x="+x.X);
    x[1]+=x[0];
    Console.Write("новые координаты - ");
    x.Show();
    Console.WriteLine();
   }
  }
}
Обратите внимание, что в интерфейсе IDemo было объявлено свойство Х, доступное только для чтения. Наследуя интерфейс IDemo, класс DemoPoint определил реализацию данного свойства. Класс DemoShape, наследуя класс DemoPoint и IDemo, не предложил собственной реализации свойства Х, поэтому при обращении к объекту типа DemoShape вызывается реализация данного свойства, определенная в базовом классе.
Задания. 
1.	Добавьте в интерфейс IDemo свойство Y, которое позволит обращаться для чтения к значению поля у. Реализуйте работу с данным свойством в классах DemoPoint и DemoShape. 
2.	Добавьте свойство Z для обращения к полю z класса DemoShape. Подумайте, куда именно нужно добавить определение данного свойства и почему. 
15.2 Стандартные интерфейсы .Net
В библиотеке классов .Net определено множество стандартных интерфейсов, задающих желаемую функциональность объектов. Например, интерфейс IComparable задает метод сравнения объектов по принципу больше и меньше, что позволяет переопределить соответствующие операции в рамках класса, наследующего интерфейс IComparable. Реализация интерфейсов IEnumerable и IEnumerator дает возможность просматривать содержимое объекта с помощью оператора foreach.
Можно создавать собственные классы, реализующие стандартные интерфейсы, что позволит использовать объекты этих классов стандартными способами.
Более подробно рассмотрим стандартный интерфейс IComparable.
Интерфейс IComparable определен в пространстве имен System и содержит единственный метод CompareTo, возвращающий результат сравнения двух объектов - текущего и переданного ему в качестве параметра:
interface IComparable
{
 int CompareTo(object obj);
}
Реализация данного метода должна возвращать:
1.	0 - если текущий объект и параметр равны; 
2.	отрицательное число, если текущий объект меньше параметра; 
3.	положительное число, если текущий объект больше параметра. 
В качестве примера рассмотрим реализацию классом DemoPoint стандартного интерфейса IComparable.
// класс DemoPoint реализует стандартный интерфейс IComparable
class DemoPoint:IComparable
{
 protected int x;
 protected int y;
 public DemoPoint ( int x, int y)
 {
  this.x=x; this.y=y;
  
 }
 public void Show()
 {
  Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
 }
 public double Dlina()
 {
  return Math.Sqrt(x*x+y*y);
 } 
 //реализация метода CompareTo
 public int CompareTo (object obj)
 {
  DemoPoint b=(DemoPoint) obj; //преобразуем к типу DemoPoint
  //определяем критерии сравнения текущего объекта с параметром в 
  // зависимости от удаленности точки от начала координат
  if (this.Dlina()==b.Dlina()) return 0;
  else if (this.Dlina()>b.Dlina()) return 1;
  else return -1;
}
}

class Program
{
 static void Main()
 {
  //создаем массив ссылок
DemoPoint []a =new DemoPoint[4];
  a[0]=new DemoPoint(5,-1);
  a[1]=new DemoPoint(-3, 3);
  a[2]=new DemoPoint(3,4);
  a[3]= new DemoPoint(0,1);
  //сортируем массив точек, при этом в качестве критерия сортировки будет 
//использоваться собственная реализация метода CompareTo 
  Array.Sort(a);
  Console.WriteLine();
  foreach (DemoPoint x in a)
  {
   x.Show();
   Console.WriteLine("Dlina={0:f2} ",x.Dlina());
  }
 }
 }
Задание. Измените метод CompareTo так, чтобы метод Sort сортировал массив точек по убыванию расстояния между точкой и началом координат. 
Обратите внимание на то, что во время реализации метода CompareTo в качестве параметра передавалась ссылка на объект типа object. Напомним, что класс object является корневым классом для всех остальных в С#. Поэтому он может ссылаться на объект любого типа. Но чтобы потом получить доступ к членам объекта произвольного класса, нужно выполнить приведение типов. 
Используя собственную реализацию метода CompareTo можно перегрузить операции отношения. Напомним, что операции отношения должны перегружаться парами: < и >, <= и >=, == и !=. 
В следующем примере для класса DemoPoint перегрузим операции == и != таким образом, чтобы при сравнении двух объектов возвращалось значение true, если точки находятся на равном удалении от начала координат, в противном случае - false.
class DemoPoint:IComparable
{
protected int x;
 protected int y;
 public DemoPoint ( int x, int y)
 {
  this.x=x; this.y=y;
 }
 public void Show()
 {
  Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
 }
 public double Dlina() 
 {
  return Math.Sqrt(x*x+y*y);
 } 
 public int CompareTo (object obj)
 {
  DemoPoint b=(DemoPoint) obj;
  if (this.Dlina()==b.Dlina()) return 0;
  else if (this.Dlina()>b.Dlina()) return 1;
  else return -1;
}
  public static bool operator ==(DemoPoint a, DemoPoint b)
 {
  return (a.CompareTo(b)==0);
 }
 public static bool operator !=(DemoPoint a, DemoPoint b)
 {
  return (a.CompareTo(b)!=0);
 }
}
 
class Program
{
 static void Main()
 {
  DemoPoint a =new DemoPoint(-3,0);
  DemoPoint b=new DemoPoint(0,3);
  if (a==b) Console.WriteLine("равно удалены от начала координат");
   else Console.WriteLine("не равно удалены от начала координат");
 }
}
Задание. Перегрузите в классе DemoPoint следущие пары операций: 
1.	> и <, так чтобы при сравнении двух объектов возвращалось значение true, если первая точка расположена дальше от начала координат, чем вторая, иначе false. 
2.	>= и <=, так чтобы при сравнении двух объектов возвращалось значение true если первая точка расположена не ближе к началу координат, чем вторая, иначе false. 
15.3 Структуры
Классы, как вы уже знаете, являются ссылочными данными. Это означает, что к экземплярам классов можно обратиться только через ссылку. В С# реализован тип данных, аналогичный классу, но который в отличие от классов является размерным типом. Таким типом является структура. 
Так как структура является размерным типом, то экземпляр структуры хранит значение своих элементов, а не ссылки на них, и располагается в стеке данных, а не в куче. В связи с этим фактом структура не может участвовать в иерархии наследования, а может только реализовывать интерфейсы. Кроме того, структуре запрещено:
1.	определять конструктор по умолчанию, поскольку он определен неявно и присваивает всем своим элементам значения по умолчанию (нули соответствующего типа); 
2.	определять деструктор, поскольку это бессмысленно. 
Синтаксис структуры:
[атрибуты][спецификаторы] struct имя_структуры [: интерфейсы]
{
 тело_структуры
}
Спецификаторы структуры имеют такой же смысл, как и для класса. Однако из спецификаторов доступа допускается использовать только public, internal и для вложенных структур еще и private. Кроме того, структуры не могут быть абстрактными, поскольку по умолчанию они бесплодны.
Интерфейсы, реализуемые структурой, перечисляются через запятую.
Тело структуры может содержать: константы, поля, конструкторы, методы, свойства, индексаторы, операторные методы, вложенные типы и события. 
При описании структуры задавать значение по умолчанию можно только для статических полей. Остальным полям с помощью конструктора по умолчанию будут присвоены нули для полей размерных типов и null для полей ссылочных типов.
Параметр this интерпретируется как значение, поэтому его можно использовать для ссылок, но не для присваивания.
Так как структуры не могут участвовать в иерархии, то для ее членов недопустимо использовать спецификаторы protected и protected internal. Методы структур не могут быть абстрактными и виртуальными. А переопределяться могут только те методы, которые унаследованы от базового класса object.
Рассмотрим пример структуры SPoint, реализующей стандартный интерфейс IComparable. В данной структуре определены:
1.	поля x и у; 
2.	конструктор, в который передаются заданные координаты точки; 
3.	метод Dlina, который позволяет вычислить расстояние от точки до начала координат; 
4.	перегружен метод ToString базового класса object; 
5.	реализован метод CompareTo стандартного интерфейса IComparable; 
6.	перегружены операции == и !=. 
 //описание структуры
 struct SPoint: IComparable
 {
  public int x, y; 
  public SPoint (int x, int y) 
  {
   this.x=a; this.y=y;
  }
  public double Dlina() //метод
  {
   return Math.Sqrt(x*x+y*y);
}
  public override string ToString() 
  {
   return "("+x.ToString()+", "+y.ToString()+")";
  }
  public int CompareTo (object obj)
  {
   SPoint b=(SPoint) obj;
   if (this.Dlina()==b.Dlina()) return 0;
   else if (this.Dlina()>b.Dlina()) return 1;
   else return -1;
  }
  public static bool operator ==(SPoint a, SPoint b)
  {
   return (a.CompareTo(b)==0);
  }
  public static bool operator !=(SPoint a, SPoint b)
  {
   return (a.CompareTo(b)!=0);
  }
 }
 
 class Program
 {
  static void Main()
  {
   //создание и заполнение массива структур   
   SPoint []a =new SPoint[4];
   a[0]=new SPoint(-3,0);
   a[1]=new SPoint(-0, 3);
   a[2]=new SPoint(3,4);
   a[3]= new SPoint(0,1);
   //сравнение двух структур
   if (a[0]==a[1])
   Console.WriteLine("точки {0} и {1} равноудалены от начала координат\n", 
       a[0].ToString(),a[1].ToString());
   else Console.WriteLine("точки {0} и {1} не равноудалены от начала координат\n", 
       a[0].ToString(),a[1].ToString());
   Array.Sort(a); //сортировка массива структур
   //просмотр массива структур
   foreach (SPoint x in a)
   {
    Console.WriteLine("Точка: "+x.ToString());
    Console.WriteLine("удалена от начала координат на расстояние равное: "+x.Dlina());
     Console.WriteLine(); 
   }
  }
 }
Как видно из примера, экземпляр структуры, как и экземпляр класса, создаются с помощью оператора new, но это не обязательно. Если оператор new не используется, то структура все равно создается, но не инициализируется. По этой причине следующая последовательность команд будет ошибочна:
SPoint one;
Console.WriteLine(one.ToString());
Если при объявлении структуры не был вызван конструктор, то поля нужно инициализировать вручную:
SPoint one;
one.x=100; one.y=100;
Console.WriteLine(one.ToString());
Так как структуры являются размерными типами, то присваивание одной структуры другой создает копию экземпляра структуры. Этот факт является важным отличием структуры от класса. В результате выполнения следующего фрагмента программы мы убедимся, что структуры one и two не зависят друг от друга.
SPoint one=new SPoint(); //вызов конструктора по умолчанию
SPoint two=new SPoint(1,1); //вызов собственного конструктора
Console.WriteLine(one.ToString());
Console.WriteLine(two.ToString());
one=two;
one.x=100;
Console.WriteLine(one.ToString());
Сonsole.WriteLine(two.ToString());
Как при решении практических задач выбрать, что использовать - класс или структуру? Если создаваемые типы данных содержат небольшое количество полей, с которыми удобнее работать как со значениями, а не как со ссылками, то расходы на выделение динамической памяти для небольших объектов снизят быстродействие программы, поэтому такие типы данных эффективнее реализовывать через структуры. Во всех остальных случаях эффективнее использовать классы. Однако передача структуры в методы по значению потребует и дополнительного времени, и дополнительной памяти для создания копии. В таких случаях эффективнее использовать классы.
Самостоятельная работа
В пространстве имен System.Collection определено несколько интерфейсов, определяющих функциональность многих стандартных классов в С#, в том числе и коллекций (которые будет рассматриваться в следующем разделе). Рассмотрим более подробно интерфейсные коллекции, описание которых приведено в следующей таблице:
Интерфейс	Описание
IEnumerator 	Содержит методы, которые позволяют поэлементно получать содержимое коллекции
IEnumerable 	Определяет метод GetEnumerator( ), который поддерживает нумератор для любого класса коллекции
ICollection	Определяет элементы, которые должны иметь все коллекции
IComparer 	Определяет метод Compare( ) , который выполняет сравнение объектов, хранимых в коллекции
IList	Определяет коллекцию, к которой можно получить доступ посредством индексатора
IDictionary	Определяет коллекцию (словарь), которая состоит из пар ключ/значение
IDictionaryEnumerator 	Определяет нумератор для коллекции, которая реализует интерфейс IDictionary
IHashCodeProvider	Определяет хеш-функцию
Основополагающим для всех коллекций является реализация перечислителя (нумератора), который поддерживается интерфейсами IEnumerator и IEnumerable. Перечислитель обеспечивает стандартизованный способ поэлементного доступа к содержимому коллекции, в том числе и через использование цикла foreach.
Интерфейс ICollection наследует интерфейс IEnumerable. В ICollection объявлены основные методы и свойства, без которых не может обойтись ни одна коллекция: 
Элемент интерфейса	Его тип	описание
int Сount {get;}	Свойство	Определяет количество элементов коллекции в данный момент. Если Count равно нулю, то коллекция пуста.
void CopyTo (Array target, int startIdx)	Метод	Обеспечивает переход от коллекции к стандартному С#-массиву, копируя содержимое коллекции в массив, заданный параметром target, начиная с индекса, заданного параметром startIdx .
Интерфейс IList наследует интерфейс ICollection и определяет поведение коллекции, доступ к элементам которой разрешен посредством индекса с отсчетом от нуля. Помимо методов, определенных в интерфейсе ICollection, интерфейс IList определяет и собственные методы:
Элемент интерфейса 	Его тип	Описание
int Add(object obj) 	Метод	Добавляет объект obj в вызывающую коллекцию. Возвращает индекс, по которому этот объект сохранен
void Clear()	Метод	Удаляет все элементы из вызывающей коллекции
bool Contains(object obj) 	Метод	Возвращает значение true, если вызывающая коллекция содержит объект, переданный в параметре obj, и значение false в противном случае
int IndexOf(object obj) 	Метод	Возвращает индекс объекта obj, если он (объект) содержится в вызывающей коллекции. Если объект obj не обнаружен, метод возвращает -1
void Insert(int idx, object obj)	Метод	Вставляет в вызывающую коллекцию объект obj по индексу, заданному параметром idx. Элементы, находившиеся до этого по индексу idx и далее, смещаются вперед, чтобы освободить место для вставляемого объекта obj
void Remove(object obj)	Метод	Удаляет первое вхождение объекта obj из вызывающей коллекции. Элементы, находившиеся до этого за удаленным элементом, смещаются назад, чтобы ликвидировать образовавшуюся "брешь"
void RemoveAt(int idx)	Метод	Удаляет из вызывающей коллекции объект, расположенный по индексу, заданному параметром idx. Элементы, находившиеся до этого за удаленным элементом, смещаются, ликвидируя образовавшуюся "брешь"
bool IsFixedSize { get; }	Свойство	Принимает значение true, если коллекция имеет фиксированный размер. Это означает, что в такую коллекцию нельзя вставлять элементы и удалять их из нее.
bool IsReadOnly { get; }	Свойство	Принимает значение true, если коллекция предназначена только для чтения. 
object this[int idx] { get; set; }	Индексатор	Используется для считывания или записи значения элемента с индексом idx. Нельзя применить для добавления в коллекцию нового элемента.
Интерфейс IDictionary наследует интерфейс ICollection. Он определяет поведение коллекции, которая устанавливает соответствие между уникальными ключами и значениями. Коллекции, реализующий интерфейс IDictionary называют словарями. Ключ - это объект, который используется для получения соответствующего ему значения. Сохраненную однажды пару можно затем извлечь по заданному ключу.
Элемент интерфейса	Его тип	Описание
void Add (object к, object v)	метод	Добавляет в вызывающую коллекцию пару ключ/значение, заданную параметрами к и v. Ключ к не должен быть нулевым. При попытке задать нулевой ключ генерируют исключение типа NotSupportedException Если окажется, что ключ к уже хранится в коллекции, генерируется исключение типа ArgumentException
void Clear () 	метод	Удаляет все пары ключ/значение из вызывающей коллекции
bool Contains (object к) 	метод	Возвращает значение true , если вызывающая коллекция содержит объект к в качестве ключа. В противном случае возвращает значение false
IDictionaryEnumerator GetEnumerator()	метод	Возвращает нумератор для вызывающей коллекции
void Remove (object к) 	метод	Удаляет элемент, ключ которого равен значению к
bool isFixedSize { get }	свойство	Равно значению true , если коллекция имеет фиксированный размер
bool isReadOnly { get }	свойство	Равно значению true, если коллекция предназначена только для чтения
ICollection Keys { get }	свойство	Получает коллекцию ключей
icollection Values { get}	свойство	Получает коллекцию значений
object this[object key] { get; set; }	индексатор	Этот индексатор можно использовать для получения или установки значения элемента, а также для добавления в коллекцию нового элемента. "Индекс" в данном случае является ключом элемента.
Интерфейс IDictionaryEnumerator является производным от интерфейса IEnumerator и распространяет свои функциональные возможности нумератора на область словарей.
В интерфейсе IComparer определен метод Compare (), который позволяет сравнивать два объекта:
int Compare(object vl, object v2)
Метод Compare () возвращает положительное число, если значение vl больше значения v2, отрицательное, если vl меньше v2, и нуль, если сравниваемые значения равны. Этот интерфейс можно использовать для задания способа сортировки элементов коллекции.
Интерфейс IHashCodeProvider должен быть реализован коллекцией, если программисту необходимо определить собственную версию метода GetHashCode ().
Задание
Для получения дополнительной информации по данным интерфейсам обратитесь к дополнительной литературе, интернет и документации по С#
 
Лекция 16. Коллекции
16.1. Классификация коллекций. 
В С# под коллекцией понимается некоторая группа объектов. Коллекции упрощают реализацию многих задач программирования, предлагая уже готовые решения для построения структур данных. Все коллекции разработаны на основе четко определенных интерфейсов, поэтому стандартизируют способ обработки группы объектов. Среда .NET Framework поддерживает три основных типа коллекций: общего назначения, специализированные и ориентированные на побитовую организацию данных. 
Коллекции общего назначения определены в пространстве имен System.Collection и реализуют такие структуры данных, как стеки, очереди, динамические массивы, словари (хеш-таблицы, предназначенные для хранения пар ключ/значение), отсортированный список для хранения пар ключ/значение. Коллекции общего назначения работают с данными типа object, поэтому их можно использовать для хранения данных любого типа. 
Коллекции специального назначения определены в пространстве имен System.Collection.Specialized и ориентированы на обработку данных конкретного типа или на обработку данных уникальным способом. Например, существуют специализированные коллекции, предназначенные только для обработки строк.
В пространстве имен System.Collection определена единственная коллекция, ориентированная на побитовую организацию данных, которая служит для хранения групп битов и поддерживает такой набор операций, который не характерен для коллекций других типов. 
В данном разделе мы рассмотрим коллекции общего назначения.
16.2 Коллекции общего назначения
Классы коллекций общего назначения:
Класс 	Описание
Stack 	Стек - частный случай однонаправленного списка, действующий по принципу: последним пришел - первым вышел
Queue 	Очередь - частный случай однонаправленного списка, действующего по принципу:первым пришел - первым вышел
ArrayList	Динамический массив, т.е. массив который при необходимости может увеличивать свой размер
Hashtable 	Хеш-таблица для пар ключ/значение
SortedList	Отсортированный список пар ключ/значение
Рассмотрим данные коллекции более подробно.
Замечание. Абстрактный тип данных (АТД) список - это последовательность элементов a1, а2,…,аn (n  0) одного типа. Количество элементов n называется длиной списка. Если n > 0, то а1 называется первым элементом списка, а аn - последним элементом списка. В случае n = 0 имеем пустой список, который не содержит элементов. Важное свойство списка заключается в том, что его элементы линейно упорядочены в соответствии с их позицией в списке. Так элемент аi предшествует аi+1 для i=1, 2, …n-1 и аi следует за аi-1 для i=2, …n. Список называется однонаправленным, если каждый элемент списка содержит ссылку на следующий элемент. Если каждый элемент списка содержит две ссылки (одну на следующий элемент в списке, вторую - на предыдущий элемент), то такой список называется двунаправленным (двусвязным). А если последний элемент связать указателем с первым, то получится кольцевой список. 
16.3 Класс Stack
АТД стек - это частный случай однонаправленного списка, добавление элементов в который и выборка элементов из которого выполняются с одного конца, называемого вершиной стека (головой - head). При выборке элемент исключается из стека. Другие операции со стеком не определены. Говорят, что стек реализует принцип обслуживания LIFO (last in - fist out, последним пришел - первым вышел). Стек проще всего представить себе в виде пирамиды, на которую надевают кольца.
 
Достать первое кольцо можно только после того, как будут сняты все верхние кольца.
В С# реализацию АТД стек представляет класс Stack, который реализует интерфейсы ICollection, IEnumerable и ICloneable. Stack - это динамическая коллекция, размер которой изменяется. 
В классе Stack определены следующие конструкторы:
public Stack(); //создает пустой стек, начальная вместимость которого равна 10
public Stack(int capacity); // создает пустой стек, начальная вместимость которого равна capacity
public Stack(ICollection c); //создает стек, который содержит элементы коллекции, заданной 
//параметром с, и аналогичной (аналогичной - с чем?) вместимостью
Кроме методов, определенных в интерфейсах, реализуемых классом Stack, в этом классе определены собственные методы:
Метод	Описание
public virtual bool Contains(object v)	Возвращает значение true, если объект v содержится в вызывающем стеке, в противном случае возвращает значение false.
public virtual void Clear()	Устанавливает свойство Сount равным нулю, тем самым очищая стек.
public virtual object Peek()	Возвращает элемент, расположенный в вершине стека, но не извлекая его из стека
public virtual object Pop()	Возвращает элемент, расположенный в вершине стека, и извлекает его из стека
public virtual void Push(object v)	Помещает объект v в стек
public virtual object[] ToArray()	Возвращает массив, который содержит копии элементов вызывающего стека
Рассмотрим несколько примеров использования стека.
Пример 1. Для заданного значения n запишем в стек все числа от 1 до n, а затем извлечем из стека:
using System;
using System.Collections;

namespace ConsoleApplication
{
 class Program
 {
  public static void Main()
  {
   Console.Write("n= ");
   int n=int.Parse(Console.ReadLine());
   Stack intStack = new Stack();
   for (int i = 1; i <= n; i++)
    intStack.Push(i);
   Console.WriteLine("Размерность стека " + intStack.Count);

   Console.WriteLine("Верхний элемент стека = " + intStack.Peek());
   Console.WriteLine("Размерность стека " + intStack.Count);

   Console.Write("Содержимое стека = ");
   while (intStack.Count != 0)
   Console.Write("{0} ", intStack.Pop());
   Console.WriteLine("\nНовая размерность стека " + intStack.Count);
  }
 }
}
Пример 2. В текстовом файле содержится математическое выражение. Проверить баланс круглых скобок в данном выражении.
using System;
using System.Collections;
using System.IO;

namespace MyProgram
{
 class Program
 {
  public static void Main()
  {
   StreamReader fileIn=new StreamReader("t.txt",);
   string line=fileIn.ReadToEnd();
   fileIn.Close();
   Stack skobki=new Stack();
   bool flag=true;
//проверяем баланс скобок 
   for ( int i=0; i<line.Length;i++)
   {
    //если текущий символ открывающаяся скобка, то помещаем ее в стек
    if (line[i] == '(') skobki.Push(i);  
     else if (line[i] == ')') //если текущий символ закрывающаяся скобка, то
    {
    //если стек пустой, то для закрывающейся скобки не хватает парной открывающейся
    if (skobki.Count == 0) 
     { flag = false; Console.WriteLine("Возможно в позиции " + i + "лишняя ) скобка"); }
      else skobki.Pop(); //иначе извлекаем парную скобку
    }
   }
   //если после просмотра строки стек оказался пустым, то скобки сбалансированы
   if (skobki.Count == 0) { if (flag)Console.WriteLine("скобки сбалансированы"); }
   else //иначе баланс скобок нарушен
   {
    Console.Write("Возможно лишняя ( скобка в позиции:");
    while (skobki.Count != 0)
    {
     Console.Write("{0} ", (int)skobki.Pop());
    }
    Console.WriteLine();
   }
  }
 }
}
________t.txt_________
(1+2)-4*(a-3)/(2-7+6)
16.4 Класс Queue
АТД очередь - это частный случай однонаправленного списка, добавление элементов в который выполняется в один конец (хвост), а выборка производится с другого конца (головы). Другие операции с очередью не определены. При выборке элемент исключается из очереди. Говорят, что очередь реализует принцип обслуживания FIFO (fist in - fist out, первым пришел - первым вышел). Очередь проще всего представить в виде узкой трубы, в один конец которой бросают мячи, а с другого конца которой они вылетают. Понятно, что мяч, который был брошен в трубу первым, первым и вылетит с другого конца. 
 
В С# реализацию АТД очередь представляет класс Queue, который также как и стек реализует интерфейсы ICollection, IEnumerable и ICloneable. Queue - это динамическая коллекция, размер которой изменяется. При необходимости увеличение вместимости очереди происходит с коэффициентом роста по умолчанию равным 2.0. 
В классе Queue определены следующие конструкторы:
public Queue(); //создает пустую очередь, начальная вместимость которой равна 32
public Queue (int capacity); // создает пустую очередь, начальная вместимость которой равна capacity
//создает пустую очередь, начальная вместимость которой равна capacity, и коэффициент роста
//устанавливается параметром n
public Queue (int capacity, float n); 
//создает очередь, которая содержит элементы коллекции, заданной параметром с, и аналогичной
//вместимостью
public Queue (ICollection c); 
Кроме методов, определенных в интерфейсах, реализуемых классом Queue, в этом классе определены собственные методы:
Метод	Описание
public virtual bool Contains (object v)	Возвращает значение true, если объект v содержится в вызывающей очереди, в противном случае возвращает значение false
public virtual void clear ()	Устанавливает свойство Count равным нулю, тем самым очищая очередь
public virtual object Dequeue ()	Возвращает объект из начала вызывающей очереди, удаляя его из очереди
public virtual object Peek ()	Возвращает объект из начала вызывающей очереди, не удаляя его из очереди
public virtual void Enqueue(object v)	Добавляет объект v в конец очереди
public virtual object [ ] ToArrау ()	Возвращает массив, который содержит копии элементов из вызывающей очереди
public virtual void TrimToSizeO	Устанавливает свойство Capacity равным значению свойства Count
Рассмотрим несколько примеров использования очереди.
Пример 1. Для заданного значения n запишем в очередь все числа от 1 до n, а затем извлечем их из очереди:
using System;
using System.Collections;
namespace MyProgram
{
 class Program
 {
  public static void Main()
  {
   Console.Write("n= ");
   int n=int.Parse(Console.ReadLine());
   Queue intQ = new Queue();
   for (int i = 1; i <= n; i++)
    intQ.Enqueue(i);
   Console.WriteLine("Размерность очереди " + intQ.Count);

   Console.WriteLine("Верхний элемент очереди = " + intQ.Peek());
   Console.WriteLine("Размерность очереди " + intQ.Count);
      
   Console.Write("Содержимое очереди = " );
   while (intQ.Count!=0)
    Console.Write("{0} ", intQ.Dequeue());
   Console.WriteLine("\nНовая размерность очереди " + intQ.Count);
  }
 }
}
Пример 2. В текстовом файле записана информация о людях (фамилия, имя, отчество, возраст, вес через пробел). Вывести на экран вначале информацию о людях младше 40 лет, а затем информацию о всех остальных.
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace MyProgram
{
 class Program
 {
  public struct one //структура для хранения данных об одном человеке
  {
   public string f;
   public string i;
   public string o;
   public int age;
   public float massa;
  }
    
  public static void Main()
  {
    StreamReader fileIn = new StreamReader("t.txt",Encoding.GetEncoding(1251));
    string line;
    Queue people = new Queue();
    one a;
    Console.WriteLine("ВОЗРАСТ МЕНЕЕ 40 ЛЕТ");
    while ((line = fileIn.ReadLine()) != null) //читаем до конца файла 
    {
     string [] temp = line.Split(' '); //разбиваем строку на составные элементы
     //заполняем структуру 
     a.f = temp[0];
     a.i = temp[1];
     a.o = temp[2];
     a.age = int.Parse(temp[3]);
     a.massa = float.Parse(temp[4]);
     // если возраст меньше 40 лет, то выводим данные на экран, иначе помещаем их в 
     //очередь для временного хранения
     if (a.age<40) 
      Console.WriteLine(a.f + "\t"+ a.i + "\t"+ a.o + "\t"+a.age + "\t" + a.massa);
     else people.Enqueue(a);
    }
    fileIn.Close();
       
    Console.WriteLine("ВОЗРАСТ 40 ЛЕТ И СТАРШЕ");
    while (people.Count != 0) //извлекаем из очереди данные
    {
     a = (one)people.Dequeue();
     Console.WriteLine(a.f + "\t"+ a.i + "\t"+ a.o + "\t"+a.age + "\t" + a.massa);
    }
   
  }
 }
}_______________t.txt__________________
Иванов Сергей Николаевич 21 64
Петров Игорь Юрьевич 45 88
Семёнов Михаил Алексеевич 20 70
Пиманов Александр Дмитриевич 53 101
16.5 Класс ArrayList
В С# стандартные массивы имеют фиксированную длину, которая не может измениться во время выполнения программы. Класс ArrayList предназначен для поддержки динамических массивов, которые при необходимости могут увеличиваться или сокращаться. 
Объект класса ArrayList представляет собой массив переменной длины, элементами которого являются объектные ссылки. Любой объект класса ArrayList создается с некоторым начальным размером. При превышении этого размера коллекция автоматически удваивается. В случае удаления объектов массив можно сократить. 
Класс ArrayList реализует интерфейсы ICollection, IList, IEnumerable и ICloneable. В классе ArrayList определены следующие конструкторы:
//создает пустой массив с максимальной емкостью равной 16 элементам, при текущей размерности 0 
public ArrayList()  
public ArrayList(int capacity) //создает массив с заданной емкостью capacity, при текущей размерности 0
public ArrayList(ICollection с) //строит массив, который инициализируется элементами коллекции с 
Помимо методов, определенных в интерфейсах, которые реализует класс ArrayList, в нем определены и собственные методы:
Метод 	Описание
public virtual void AddRange (ICollection с)	Добавляет элементы из коллекции с в конец вызывающей коллекции
public virtual int BinarySearch (object v) 	В вызывающей отсортированной коллекции выполняет поиск значения, заданного параметром v. Возвращает индекс найденного элемента. Если искомое значение не обнаружено, возвращает отрицательное значение.
public virtual int BinarySearch (object v, IComparer comp)	В вызывающей отсортированной коллекции выполняет поиск значения, заданного параметром v, на основе метода сравнения объектов, заданного параметром соmp. Возвращает индекс найденного элемента. Если искомое значение не обнаружено, возвращает отрицательное значение. 
public virtual int BinarySearch (int startldx, int count, object v, IComparer comp)	В вызывающей отсортированной коллекции выполняет поиск значения, заданного параметром v, на основе метода сравнения объектов, заданного параметром comp. Поиск начинается с элемента, индекс которого равен значению startIdx, и включает count элементов. Метод возвращает индекс найденного элемента. Если искомое значение не обнаружено, возвращает отрицательное значение. 
public virtual void CopyTo(Array ar, int startIdx)	Копирует содержимое вызывающей коллекции, начиная с элемента, индекс которого равен значению startIdx, в массив, заданный параметром аr. Приемный массив должен быть одномерным и совместимым по типу с элементами коллекции.
public virtual void CopyTo(int srcldx, Array ar, int destIdx, int count)	Копирует count элементов вызывающей коллекции, начиная с элемента, индекс которого равен значению srcIdx, в массив, заданный параметром аr, начиная с элемента, индекс которого равен значению destIdx. Приемный массив должен быть одномерным и совместимым по типу с элементами коллекции
public virtual ArrayList GetRange(int idx, int count)	Возвращает часть вызывающей коллекции типа ArrayList. Диапазон возвращаемой коллекции начинается с индекса idx и включает count элементов. Возвращаемый объект ссылается на те же элементы, что и вызывающий объект
public static ArrayList FixedSize(ArrayList ar)	Превращает коллекцию ar в ArrayList-массив с фиксированным размером и возвращает результат
public virtual void InsertRange(int startldx, ICollection c)	Вставляет элементы коллекции, заданной параметром с, в вызывающую коллекцию, начиная с индекса, заданного параметром startIdx
public virtual int LastlndexOf(object v)	Возвращает индекс последнего вхождения объекта v в вызывающей коллекции. Если искомый объект не обнаружен, возвращает отрицательное значение
public static ArrayList Readonly(ArrayList ar)	Превращает коллекцию ar в ArrayList-массив, предназначенный только для чтения
public virtual void RemoveRange(int idx, int count)	Удаляет count элементов из вызывающей коллекции, начиная с элемента, индекс которого равен значению idx
public virtual void Reverse()	Располагает элементы вызывающей коллекции в обратном порядке
public virtual void Reverse(int startldx, int count)	Располагает в обратном порядке count элементов вызывающей коллекции, начиная с индекса startldx
public virtual void SetRange(int startldx, ICollection c)	Заменяет элементы вызывающей коллекции, начиная с индекса startldx, элементами коллекции, заданной параметром с
public virtual void Sort()	Сортирует коллекцию по возрастанию
public virtual void Sort(IComparer comp)	Сортирует вызывающую коллекцию на основе метода сравнения объектов, заданного параметром comp. Если параметр comp имеет нулевое значение, для каждого объекта используется стандартный метод сравнения
public virtual void Sort ( int startidx, int endidx, icomparer comp)	Сортирует часть вызывающей коллекции на основе метода сравнения объектов, заданного параметром comp. Сортировка начинается с индекса startidx и заканчивается индексом endidx. Если параметр comp имеет нулевое значение, для каждого объекта используется стандартный метод сравнения
public virtual object [ ] ToArray ()	Возвращает массив, который содержит копии элементов вызывающего объекта
public virtual Array ToArray (Type type)	Возвращает массив, который содержит копии элементов вызывающего объекта. Тип элементов в этом массиве задается параметром type
public virtual void TrimToSize()	Устанавливает свойство Capacity равным значению свойства Count
Свойство Capacity позволяет узнать или установить емкость вызывающего динамического массива типа ArrayList. Емкость представляет собой количество элементов, которые можно сохранить в ArrayList-массиве без его увеличения. Если вам заранее известно, сколько элементов должно содержаться в ArrayList-массиве, то размерность массива можно установить используя свойство Capacity, съэкономив тем самым системные ресурсы. Если нужно уменьшить размер ArrayList-массива, то путем установки свойства Capacity можно сделать его меньшим. Но устанавливаемое значение не должно быть меньше значения свойства Count, иначе будет сгенерировано исключение ArgumentOutOfRangeException. Чтобы сделать емкость ArrayList-массива равной действительному количеству элементов, хранимых в нем в данный момент, установите свойство Capacity равным свойству Count. Того же эффекта можно добиться, вызвав метод TrimToSize ().
Рассмотрим несколько примеров использования динамического массива.
using System;
using System.Collections;

namespace MyProgram
{
 class Program
 {
  static void ArrayPrint(string s, ArrayList a)
  {
   Console.WriteLine(s);
   foreach (int i in a)
    Console.Write(i + " ");
   Console.WriteLine();
  }

  static void Main(string[] args)
  {
   ArrayList myArray = new ArrayList();
   Console.WriteLine("Начальная емкость массива: " + myArray.Capacity);
   Console.WriteLine("Начальное количество элементов: " + myArray.Count);

   Console.WriteLine("\nДобавили 5 цифр");
   for (int i = 0; i < 5; i++) myArray.Add(i);
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);
      
   Console.WriteLine("\nОптимизируем емкость массива");
   myArray.Capacity=myArray.Count;
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);

   Console.WriteLine("\nДобавляем элементы в массив");
   myArray.Add(10);
   myArray.Insert(1, 0); 
   myArray.AddRange(myArray);
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);

   Console.WriteLine("\nУдаляем элементы из массива");
   myArray.Remove(0);
   myArray.RemoveAt(10);
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);

   Console.WriteLine("\nУдаляем весь массив");
   myArray.Clear();
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);
  }
 }
}
Пример 2. В текстовом файле записана информация о людях (фамилия, имя, отчество, возраст, вес через пробел). Вывести на экран информацию о людях, отсортированную по возрасту.
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace MyProgram
{
 class Program
 {
  public struct one //структура для хранения данных об одном человеке
  {
   public string f;
   public string i;
   public string o;
   public int age;
   public float massa;
  }

  public class SortByAge : IComparer //реализация стандартного интерфейса 
  {
   int IComparer.Compare(object x, object y)  //переопределение метода Compare
   {
    one t1 = (one)x;
    one t2 = (one)y;
    if (t1.age > t2.age) return 1;
    if (t1.age < t2.age) return -1;
    return 0;
   }
  }

  static void ArrayPrint(string s, ArrayList a)
  {
   Console.WriteLine(s);
   foreach (one x in a)
    Console.WriteLine(x.f + "\t"+ x.i + "\t"+ x.o + "\t"+x.age + "\t" + x.massa);
  }

  static void Main(string[] args)
  {
    StreamReader fileIn = new StreamReader("t.txt",Encoding.GetEncoding(1251));
    string line;
    one a;
    ArrayList people = new ArrayList();
    string[] temp = new string[5];
    while ((line=fileIn.ReadLine())!=null) //цикл для организации обработки файла 
    {
     temp = line.Split(' '); 
     a.f = temp[0];
     a.i = temp[1];
     a.o = temp[2];
     a.age = int.Parse(temp[3]);
     a.massa = float.Parse(temp[4]);
     people.Add(a);
    }
    fileIn.Close();

    ArrayPrint("Исходные данные: ", people);
    people.Sort(new Program.SortByAge());  //вызов сортировки
    ArrayPrint("Отсортированные данные: ", people);
  }
 }
}
______________t.txt________________
Иванов Сергей Николаевич 21 64
Петров Игорь Юрьевич 45 88
Семёнов Михаил Алексеевич 20 70
Пиманов Александр Дмитриевич 53 101
Замечание. Обратите внимание на то, что в данном примере был разработан вложенный класс SortByAge, реализующий стандартный интерфейс IComparer. В этом классе был перегружен метод Compare, позволяющий сравнивать между собой два объекта типа one. Созданный класс использовался для сортировки коллекции по заданному критерию (по возрасту).
16.6 Класс Hashtable
Класс Hashtable предназначен для создания коллекции, в которой для хранения объектов используется хеш-таблица. В хеш-таблице для хранения информации используется механизм, именуемый хешированием (hashing). Суть хеширования состоит в том, что для определения уникального значения, которое называется хеш-кодом, используется информационное содержимое соответствующего ему ключа. Хеш-код затем используется в качестве индекса, по которому в таблице отыскиваются данные, соответствующие этому ключу. Преобразование ключа в хеш-код выполняется автоматически, т.е. сам хеш-код вы даже не увидите. Но преимущество хеширования - в том, что оно позволяет сокращать время выполнения таких операций, как поиск, считывание и запись данных, даже для больших объемов информации. 
Класс Hashtable реализует стандартные интерфейсы IDictionary, ICollection, IEnumerable, ISerializable, IDeserializationCallback и ICloneable. Размер хеш-таблицы может динамически изменяться. Размер таблицы увеличивается тогда, когда количество элементов превышает значение, равное произведению вместимости таблицы и ее коэффициента заполнения, который может принимать значение на интервале от 0,1 до 1,0. По умолчанию установлен коэффициент равный 1,0.
В классе Hashtable определено несколько конструкторов:
public Hashtable()   //создает пустую хеш-таблицу 
// строит хеш-таблицу, которая инициализируется элементами коллекции с
public Hashtable(IDictionary с) 
public Hashtable(int capacity) //создает хеш-таблицу с вместимостью capacity
//создает хеш-таблицу вместимостью capacity и коэффициентом заполнения n 
public Hashtable(int capacity, float n)
Помимо методов, определенных в интерфейсах, которые реализует класс Hashtable, в нем определены и собственные методы:
Метод 	Описание
public virtual bool ContainsKey (object k) 	Возвращает значение true , если в вызывающей хеш-таблице содержится ключ, заданный параметром k. В противном случае возвращает значение false
public virtual bool ContainsValue (object v) 	Возвращает значение true, если в вызывающей хеш-таблице содержится значение, заданное параметром v. В противном случае возвращает значение false
public virtual IDictionaryEnumerator GetEnumerator() 	Возвращает для вызывающей хеш-таблицы нумератор типа IDictionaryEnumerator
В классе Hashtable, помимо свойств, определенных в реализованных им интерфейсах, определены два собственных public-свойства:
public virtual ICollection Keys { get; } //позволяет получить коллекцию ключей
public virtual ICollection Values { get; } //позволяет получить коллекцию значений
Для добавления элемента в хеш-таблицу необходимо вызвать метод Add(), который принимает два отдельных аргумента: ключ и значение. Важно отметить, что хеш-таблица не гарантирует сохранения порядка элементов, т.к хеширование обычно не применяется к отсортированным таблицам.
Рассмотрим пример, который демонстрирует использование Hashtable коллекции:
Пример 1:рассмотрим простые операции с хеш-таблицей
using System;
using System.Collections;

namespace MyProgram
{
 class Program
 {
    
  static void printTab(string s, Hashtable a)
  {
   Console.WriteLine(s);
   ICollection key = a.Keys; //Прочитали все ключи
   foreach (string i in key)//использование ключа для получения значения
   {
    Console.WriteLine(i+"\t"+a[i]);
   }
   Console.WriteLine();
  }

  static void Main(string[] args)
  {
   Hashtable tab = new Hashtable();
   Console.WriteLine("Начальное количество элементов: " + tab.Count);
   printTab("Содержимое таблицы: ", tab);

   Console.WriteLine("Добавили в таблицу записи");
   tab.Add("001","ПЕРВЫЙ");
   tab.Add("002","ВТОРОЙ");
   tab.Add("003","ТРЕТИЙ");
   tab.Add("004", "ЧЕТВЕРТЫЙ");
   tab.Add("005", "ПЯТЫЙ");
   Console.WriteLine("Текущее количество элементов: " + tab.Count);
   printTab("Содержимое заполненной таблицы", tab);
   tab["005"] = "НОВЫЙ ПЯТЫЙ";
   tab["001"] = "НОВЫЙ ПЕРВЫЙ";
   printTab("Содержимое измененной таблицы", tab); 
  }
 }
}
Пример 2. Разработаем простейшую записную книжку, в которую можно добавлять и удалять телефоны, а также осуществлять поиск номера телефона по фамилии и фамилии по номеру телефона.
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace MyProgram
{
 class Program
 {
  static void printTab(string s, Hashtable a)
  {
   Console.WriteLine(s);
   ICollection key = a.Keys; //Прочитали все ключи
   foreach (string i in key)//использование ключа для получения значения
   {
    Console.WriteLine(i + "\t" + a[i]);
   }
  }

  static void Main(string[] args)
  {
    StreamReader fileIn = new StreamReader("t.txt",Encoding.GetEncoding(1251));
    string line;
    Hashtable people = new Hashtable();
    while ((line = fileIn.ReadLine()) != null) //цикл для организации обработки файла 
    {
     string [] temp = line.Split(' ');
     people.Add(temp[0],temp[1]);
    }
    fileIn.Close();
    printTab("Исходные данные: ", people);
    
    Console.WriteLine("Введите номер телефона");
    line = Console.ReadLine();
    if (people.ContainsKey(line)) Console.WriteLine(line + "\t" + people[line]);
    else
    {
     Console.WriteLine("Такого номера нет в записной книжке.\nВведите фамилию: ");
     string line2=Console.ReadLine();
     people.Add(line,line2);
    }
    printTab("Исходные данные: ", people);

    Console.WriteLine("Введите фамилию для удаления");
    line = Console.ReadLine();
    if (people.ContainsValue(line))
    {
     ICollection key =people.Keys; //Прочитали все ключи
     Console.WriteLine(line);
     string del="";
     foreach (string i in key)//использование ключа для получения значения
      if (string.Compare((string)people[i], line) == 0)
      {
       del = i;
       break;
      }

     Console.WriteLine(del + "\t" + people[del] + "- данные удалены!!!");
     people.Remove(del);
     printTab("Измененные данные: ", people);       
    }
    else Console.WriteLine("Такого абонента в записной книжке нет ");
  }
 }
}
_________t.txt____________
12-34-56 Иванов
78-90-12 Петров
34-56-78 Семёнов
90-11-12 Пиманов
Самостоятельная работа
Используя дополнительную литературу и Интернет рассмотреть класс SortedList. 
Лекция 17. Организация интерфейса windows-приложений.
17.1 Струткура простейшего windows-приложения
Структуру простейшего windows-приложения рассмотрим на примере приложения Hello, которое состоит из одной формы, не населенной элементами управления.

В самое начало фала исходного текста приложения мастер проектов вставил строки, подключающие несколько пространств имен (name space) с помощью ключевого слова using:
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
Пространство имен System содержит определение фундаментальных и базовых классов, определяющих типы данных, события, обработчики событий и другие, необходимые в каждом приложении компоненты.
Пространство имен System.Drawing необходимо для доступа к интерфейсу графических устройств (Graphics Device Interface, GDI). Классы, определенные в этом пространстве имен, необходимы для рисования в окнах приложений текста, линий, двухмерных фигур, изображений и других графических объектов.
В пространстве имен System.Collections определены классы, реализующие функциональность таких контейнеров, как массивы, списки, словари, и т.п.
Классы пространства System.ComponentModel используются для реализации необходимого поведения компонентов и элементов управления приложения на этапе его разработки и выполнения.
Пространство имен System.Windows.Forms  — в нем определены классы, реализующие поведение оконных форм, составляющих базу оконных приложений Microsoft windows на платформе Microsoft .NET Frameworks.
Класс System.Data необходим приложениям, работающим с базами данных. 

Пприложение также определяет собственное пространство имен Hello:
namespace Hello
{
  …
}
В пространтсве имен Hello содержится определение только одного класса Form1:
/// <summary>
/// Summary description for Form1.
/// </summary>
public class Form1 : System.Windows.Forms.Form
{
  …
}
Этот класс создается на базе класса System.Windows.Forms.Form. Перед определением класса добавлены комментарии специального вида, включающий в себя тег <summary>. Это описание Вы можете отредактировать по своему усмотрению, отразив в нем какую-либо осмысленную информацию о назначении класса. Наличие подобных комментариев упрощает документирование проекта.

Рассмотрим поля и методы, определенные в классе Form1.
В классе Form1 мастер проекта создал одно поле components типа private и класса System.ComponentModel.Container:
/// <summary>
/// Required designer variable.
/// </summary>
private System.ComponentModel.Container components = null;
Оно представляет собой контейнер, предназначенный для хранения компонентов, размещаемых в форме. 

Конструктор класса Form1, вызывается при создании новой формы и инициализирует все компоненты, размещенные на форме. С этой целью конструктор вызывает метод InitializeComponent, определенный в классе Form1:
public Form1()
{
  //
  // Required for Windows Form Designer support
  //
  InitializeComponent();

  //
  // TODO: Add any constructor code 
  // after InitializeComponent call
  //
}
Деструктор класса Form1 в явном виде отсутствует. Однако для освобождения ресурсов приложения после закрытия формы в этом классе определен метод Dispose:
/// <summary>
/// Clean up any resources being used.
/// </summary>
protected override void Dispose( bool disposing )
{
  if( disposing )
  {
     if (components != null) 
     {
       components.Dispose();
     }
  }
  base.Dispose( disposing );
}
В его задачу входит освобождение ресурсов всех компонентов, хранящихся в упомянутом выше контейнере components, при закрытии формы. Далее этот метод вызывает метод Dispose базового класса (т.е. класса System.Windows.Forms.Form) для выполнения действий по освобождению ресурсов, определенных в этом классе.

Метод InitializeComponent заключен внутри блока, образованного ключевыми словами #region и #endregion:
#region Windows Form Designer generated code
/// <summary>
/// Required method for Designer support - do not modify
/// the contents of this method with the code editor.
/// </summary>
private void InitializeComponent()
{
  this.components = new System.ComponentModel.Container();
  this.Size = new System.Drawing.Size(300,300);
  this.Text = "Form1";
}
#endregion
В автоматически созданном комментарии к методу InitializeComponent говорится о том, что этот метод используется мастером форм, и его не следует модифицировать вручную. 
Прежде всего, этот метод создает новый контейнер для хранения компонентов, и записывает его в описанное ранее поле components:
this.components = new System.ComponentModel.Container();
Далее метод InitializeComponent устанавливает два атрибута формы — ее размер Size и текст заголовка Text:
this.Size = new System.Drawing.Size(300,300);
this.Text = "Form1";
Так как пока форма не содержит никаких элементов управления, на этом инициализация формы будет закончена.

В классе Form1 определен статический метод Main, получающий управление при запуске приложения:
/// <summary>
/// The main entry point for the application.
/// </summary>
[STAThread]
static void Main() 
{
  Application.Run(new Form1());
}
Этот метод играет роль точки входа приложения, с которой и начинается его работа. Метод Main очень прост. Он состоит всего из одной строки, в которой вызывается метод Application.Run:
  Application.Run(new Form1());
В качестве параметра методу Application.Run передается ссылка на новый, только что созданный объект класса Form1 (т.е. на форму).
Как это работает?
Вначале конструктор создает объект класса Form1 — новую форму, выступающую в качестве главного окна нашего приложения. Метод Application.Run, получая при вызове ссылку на эту форму, инициализирует цикл обработки сообщений и запускает его. Когда пользователь закрывает главное окно приложения, метод Application.Run возвращает управление, и приложение завершает свою работу.
В форме нашего первого приложения нет никаких компонентов и элементов управления, поэтому нет и обработчиков событий, создаваемых этими компонентами. 

Усовершенствуйте приложение, добавив в него кнопку и предусмотрев обработку событий, связанных с этой кнопкой.
17.2 Элементы управления на форме
Усовершенствуйте приложение Hello, добавив в него кнопку и предусмотрев обработку событий, связанных с этой кнопкой.
 
После добавления кнопки в классе Form1 появилось новое поле button1, предназначенное для хранения ссылки на кнопку:
private System.Windows.Forms.Button button1;
Кнопка создается как объект класса System.Windows.Forms.Button. Самые большие изменения затрагивают метод InitializeComponent, отвечающий за инициализацию формы. Теперь в нем появились строки, отвечающие за создание и размещение кнопки внутри формы:

Прежде всего, метод InitializeComponent создает кнопку как объект класса System.Windows.Forms.Button, и сохраняет ссылку на этот объект в поле button1 для дальнейшего использования:
this.button1 = new System.Windows.Forms.Button();
После этого начинается процесс размещения кнопки на поверхности формы. Этот процесс начинается с вызова метода SuspendLayout:
this.SuspendLayout();
Это делается для временного отключения механизма генерации сообщений, связанных с размещением элементов в окне формы. Такое отключение позволяет снизить непроизводительные затраты ресурсов процессора при размещении в форме нескольких компонентов сразу.
После того как все необходимые компоненты будут размещены, механизм генерации упомянутых выше сообщений включается снова при помощи метода ResumeLayout:
this.ResumeLayout(false);
В промежутке между вызовами методов SuspendLayout и ResumeLayout программа добавляет и размещает элементы управления, а также настраивает их свойства.Первым делом в форму добавляется кнопка:
this.button1.Location = new System.Drawing.Point(200, 16);
Для рисования кнопки внутри окна формы в определенной позиции программа вызывает метод System.Drawing.Point. Координаты места расположения кнопки по горизонтальной  и вертикальной оси координат передаются методу через параметры.

Далее программа устанавливает свойства кнопки:
this.button1.Name = "button1";
this.button1.TabIndex = 0;
this.button1.Text = "Сообщение";
Свойство Name хранит идентификатор кнопки. При необходимости этот идентификатор можно отредактировать.
В свойстве Text хранится надпись на кнопке. Что же касается свойства TabIndex, то оно приобретает значение, когда в форме имеется несколько элементов управления, таких как кнопки, поля редактирования, списки и т.д. Это свойство задает порядок выбора элементов в окне формы при использовании клавиши табуляции. Напомним, что с помощью клавиши табуляции можно перемещать фокус ввода между элементами управления обычных диалоговых окон Microsoft Windows.

После добавления кнопки и настройки ее свойств метод InitializeComponent задает свойства самой формы:
this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
this.ClientSize = new System.Drawing.Size(292, 273);
this.Controls.AddRange(
  new System.Windows.Forms.Control[] 
  {
     this.button1
  }
);
Свойство AutoScaleBaseSize задает базовые размеры, которые используются формой для автоматического масштабирования. При этом за основу берется размер системного шрифта.
При помощи свойства ClientSize программа определяет размеры так называемой клиентской области окна (client area) нашей формы. Эта область не включает в себя заголовок окна, рамку и полосы прокрутки.
И, наконец, при помощи метода Controls.AddRange программа добавляет в форму контейнер с массивом System.Windows.Forms.Control[] элементов управления. В нашем случае этот массив состоит из одной кнопки с идентификатором button1.

Последнее, что делает метод InitializeComponent, это настройка свойств формы Name и Text:
this.Name = "Form1";
this.Text = "Form1";
Первое из них задает имя (идентификатор) формы, а второе — текстовую строку, отображаемую в заголовке формы.
Заметьте, что мы сделали лишь несколько движений мышью, добавив кнопку в окно формы. При этом мастер форм автоматически добавил  весь код, необходимый для создания и размещения кнопки.
17.3 Обработка событий
Хотя в усовершенствованной версии приложения есть кнопка, она не несет никакой полезной нагрузки. Теперь нашей задачей будет создание для этой кнопки обработчика события. Когда пользователь щелкает кнопку мышью, этот обработчик должен будет выводить на экран компьютера диалоговое окно с сообщением, а в исходный текст приложения будет добавлен метод button1_Click:
private void button1_Click(object sender, System.EventArgs e)
{
     
}
Пока этот метод, получающий управление при щелчке кнопки, ничего не делает. Метод button1_Click — это обработчик события, возникающего, когда пользователь щелкает кнопку. Чтобы этот метод заработал, его нужно подключить на этапе инициализации формы. Такое подключение обеспечивает следующая строка, добавленная дизайнером формы в метод InitializeComponent:
this.button1.Click += new System.EventHandler(this.button1_Click);
Чтобы в процессе обработки сообщения от кнопки вывести на экран сообщение, измените исходный текст метода button1_Click следующим образом:
private void button1_Click(object sender, System.EventArgs e)
{
  MessageBox.Show("Для Вас есть сообщение!");
}
Мы вставили сюда вызов метода MessageBox.Show. Этот метод отображает на экране диалоговое окно с текстом сообщения.
 

Платформа .NET требует точной сигнатуры для любого обработчика событий. button1_Click () и все остальные обработчики событий обязаны выглядеть следующим образом:
void button1_Click (object sender, EventArgs e)//е также может быть производным от EventArgs
{
// код для обработки события
}
Обработчики событий не могут возвращать ничего, кроме void. В них отсутствует точка, которая могла бы служить для возврата значения. Обработчики должны принимать два параметра. Первый параметр является ссылкой на объект, который сгенерировал событие. Второй параметр должен быть ссылкой либо на базовый класс .NET System.EventArgs, либо на производный класс. Класс EventArgs представляет собой общий базовый класс для всех уведомлений о произошедших событиях.
В окне свойств каждого элемента управления на вкладке событий перечислены все доступные события для этого элемента.
Для демонстрации обработки событий мыши можно спроектировать приложение, в котором кнопка будет убегать от указателя мыши, т.е. нажать ее будет невозможно. Для этого необходимо изменять положение кнопки на форме в зависимости от того, где находится указатель мыши. Реализовать это можно задействовав событие MouseMove кнопки. Это событие наступает, когда указатель мыши перемещается в области кнопки. 
В обработчике этого события связываем движение мыши с координатами кнопки и устанавливаем координаты кнопки, куда она будет возвращаться, если во время своего движения выйдет за указанную область:
private void btnno_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
{
      btnno.Top -= e.Y; //e.Y и e.X – это координаты курсора мыши   
      btnno.Left += e.X;
      if (btnno.Top < -10 || btnno.Top > 100)
      btnno.Top = 60;
      if (btnno.Left < -80 || btnno.Left > 250)
      btnno.Left = 120;
}
17.4 Работа с элементами управления
Элементы управления — это компоненты, обеспечивающие взаимодействие между пользователем и программой. Среда Visual Studio.NET предоставляет большое количество элементов, которые можно сгруппировать по нескольким функциональным группам.
Группа командных объектов: элементы управления Button, LinkLabel, ToolBar реагируют на нажатие кнопки мыши и немедленно запускают какое-либо действие. Группа текстовых объектов: большинство приложений предоставляют возможность пользователю вводить текст и, в свою очередь, выводят различную информацию в виде текстовых записей. Элементы TextBox, RichTextBox принимают текст, а элементы Label, StatusBar выводят ее.
Группа переключателей: приложение может содержать несколько предопределенных вариантов выполнения действия или задачи; элементы управления этой группы предоставляют возможность выбора пользователю. Это одна из самых обширных групп элементов, в которую входят ComboBox, ListBox, ListView, TreeView, NumericUpDown и многие другие.
Группа контейнеров: с элементами этой группы действия приложения практически никогда не связываются, но они имеют большое значение для организации других элементов управления, их группировки и общего дизайна формы. Как правило, элементы этой группы, расположенные на форме, служат подложкой кнопкам, текстовым полям, спискам — поэтому они и называются контейнерами. Элементы Panel, GroupBox, TabControl, кроме всего прочего, разделяют возможности приложения на логические группы, обеспечивая удобство работы.
Группа графических элементов:  даже самое простое приложение Windows содержит графику — иконки, заставку, встроенные изображения. Для размещения и отображения их на форме используются элементы для работы с графикой — Image List, Picture Box.
Диалоговые окна: выполняя различные операции с документом — открытие, сохранение, печать, предварительный просмотр, — мы сталкиваемся с соответствующими диалоговыми окнами. Разработчикам .NET не приходится заниматься созданием окон стандартных процедур: элементы OpenFileDialog, SaveFile Dialog, ColorDialog, PrintDialog содержат уже готовые операции.
Группа меню: многие пользователи настраивают интерфейс приложений на свой вкус: одним нравится наличие определенных панелей инструментов, другим – индивидуальное расположение окон. Но в любом приложении будет присутствовать меню, содержащее в себе доступ ко всем возможностям и настройкам приложения. Элементы MainMenu, ContextMenu представляют собой готовые формы для внесения заголовков и пунктов меню.
17.5 Кнопки
Наряду с надписями и полями редактирования текстовой информации кнопки встречаются чаще всего в пользовательском интерфейсе приложений.
Кнопки создаются на базе класса System.Windows.Forms.Button. В этом классе предусмотрено значительное количество свойств, с помощью которого можно создавать кнопки самого разного вида.
 
Программист может задавать внешний вид и поведение кнопки, помещать на ее поверхность графические изображения, а также задавать для кнопки фоновое графическое изображение. Шрифт текста, а также расположение текста и графического изображения можно изменять.

Текст надписи, расположенной на кнопке, задается с помощью свойства Text. Это свойство, как и другие свойства элементов управления, можно задавать во время проектирования приложения (design time), а также программно во время работы приложения (run time).
Вот, например, как программа может изменить текст надписи для кнопки buttonRed:
buttonRed.Text = "Красный";
Стандартные кнопки ОС Microsoft Windows не допускают изменение шрифта или цвета надписей.

Свойство Font задает шрифт надписи. На этапе визуального проектирования приложения можно выбрать этот шрифт из числа шрифтов, установленных в ОС, при помощи стандартного диалогового окна. Программно шрифт задается следующим образом:
buttonYellow.Font = new System.Drawing.Font("Comic Sans MS", 11.25F,
  System.Drawing.FontStyle.Regular,  System.Drawing.GraphicsUnit.Point, ((System.Byte)(204)));
Здесь мы создаем новый шрифт как объект класса System.Drawing.Font, передавая конструктору через параметры такие атрибуты шрифта, как название, размер, стиль, единицы измерения размера шрифта и кодировку.

Редактируя свойство ForeColor, можно выбрать для надписи любой цвет. Ранее мы уже рассказывали о диалоговом окне выбора цвета. 
buttonYellow.ForeColor = System.Drawing.Color.DarkGreen;
Здесь мы задали темно-зеленый цвет надписи, воспользовавшись для этого статической константой System.Drawing.Color.DarkGreen. 

По умолчанию текст надписи центруется внутри окна кнопки. Однако, изменяя свойство TextAlign, можно выровнять текст по правой, левой, верхней или нижней границам. Кроме этого, можно выровнять текст по углам окна кнопки.Программно выравнивание текста задается следующим образом:
buttonGreen.TextAlign = System.Drawing.ContentAlignment.BottomCenter;
Учитывая стремление разработчиков приложений придавать своим программам интерфейс, подобный интерфейсу Web-приложений, создатели класса System.Windows.Forms.Button позаботились о возможности изменения стиля кнопки.
Стиль кнопки задается свойством FlatStyle. Это свойство может иметь следующие значения:
•         Flat;
•         Popup;
•         Standard;
•         System
Стиль Standard предназначен для создания обычных «серых» кнопок, знакомых Вам по старым приложениям Microsoft Windows. Если выбрать стиль System, то внешний вид кнопки будет определяться настройками ОС. Кнопка Popup рисуется плоской. Однако когда пользователь указывает на нее курсором мыши, кнопка принимает объемный вид. Этот стиль удобно использовать в тех случаях, когда нужно создать несколько расположенных рядом кнопок. В этом случае кнопка, над которой в настоящий момент находится курсор мыши, будет выделяться своим объемным видом. И, наконец, кнопка Flat всегда остается плоской. Но если пользователь располагает над такой кнопкой курсор мыши, кнопка становится темнее. Стиль кнопки можно определить средствами Microsoft Visual Studio .NET, а можно задать программно, например:
buttonYellow.FlatStyle = System.Windows.Forms.FlatStyle.Popup;
Приложение может динамически во время своей работы блокировать и разблокировать кнопки и элементы управления, расположенные в формах. Для того чтобы заблокировать кнопку, установите значение свойства Enabled равным true. Заблокированная кнопка отображается в форме, однако не реагирует на мышь и клавиатуру, а также не создает событий.
При необходимости приложение может скрыть кнопку или другой элемент управления, установив значение свойства Visible равным false. Скрытый элемент управления не отображается в форме и не создает событий.

Можно значительно улучшить внешний вид кнопки, расположив на ее поверхности графическое изображение. Чтобы поместить на поверхность кнопки графическое изображение, необходимо отредактировать свойство Image. Перед этим необходимо скопировать файл изображения в каталог проекта, а затем добавить его в проект. Программно изображение на поверхности кнопки задается так:
buttonGreen.Image = 
  ((System.Drawing.Bitmap)
  (resources.GetObject("buttonGreen.Image")));
Здесь изображение извлекается из ресурсов приложения с помощью метода resources.GetObject, а затем, после приведения типа к System.Drawing.Bitmap, записывается в свойство Image. 

До сих пор мы рассматривали только одно событие Click, создаваемое при щелчке кнопки мышью. Однако кнопка, как и остальные элементы управления, создает множество других событий. 
 
Все события, перечисленные на вкладке событий, разделены на группы. Группа Action (действие) включает в себя только событие Click. Что же касается группы Mouse (события, связанные с мышью), то в ней имеется целых шесть событий. Они создаются, когда пользователь нажимает кнопку мыши в окне кнопки (событие MouseDown), располагает курсор мыши над поверхностью окна кнопки (MouseEnter) или убирает курсор мыши из этого окна (MouseLeave) и т.д. Выделяя по очереди левой клавишей мыши названия событий, Вы можете прочитать в нижней части вкладки краткое описание условий, при которых это событие возникает.
На вкладке событий Вы можете назначить обработчики для любых событий.

Рассмотрим использование события buttonsEnter. Реализуем возможность, которая заключается в том, что при наведении курсора мыши на кнопку она будет менять свой цвет на красный. Для этого добавим на форму три кнопки. В класс Form1 добавим поле oldColor, предназначенное для хранения исходного цвета фона кнопки:
Color oldColor;
Добавим исходный текст обработчика событий buttonsEnter, подключенного ко всем кнопкам нашего приложения:
private void buttonsEnter(object sender, System.EventArgs e)
{
  Button btn = (Button)sender;
  oldColor = btn.BackColor;
  btn.BackColor = Color.Red;

}
Получив управление, наш обработчик событий получает идентификатор кнопки, вызвавшей событие, и сохраняет его в переменной btn. Затем обработчик сохраняет в поле oldColor текущий цвет фона кнопки, получая его из свойства btn.BackColor, а затем раскрашивает фон кнопки в красный цвет:
Button btn = (Button)sender;
oldColor = btn.BackColor;
btn.BackColor = Color.Red;
Когда мышь покидает окно наших кнопок, управление получает обработчик событий buttonsLeave:
private void buttonsLeave(object sender, System.EventArgs e)
{
  Button btn = (Button)sender;
  btn.BackColor = oldColor;
 }
Его задача — восстановление исходного цвета фона кнопки, окно которой покинул курсор мыши.
Обработка событий MouseDown и MouseUp позволяет задать, например, произвольный вид кнопки в нажатом и отжатом состоянии.
17.6 Работа с элементами управления в режиме работы приложения
Для добавления элементов управления во время работы приложения используется объект ControlsCollection, содержащий ряд методов. Под коллекцией элементов понимается их упорядоченная последовательность.
Метод	Описание
Add	Добавление элемента в коллекцию
AddRange	Добавление массива элементов
Clear	Удаление всех элементов из коллекции
Remove	Удаление элемента из коллекции
RemoveAt	Удаление элемента по заданному индексу
Count	Общее число элементов в коллекции
Рассмотрим пример: при нажатии на кнопку будем создавать на форме еще одну кнопку, при нажатии на созданную будем создавать еще одну кнопку и т.д. При щелчке правой кнопкой мыши по любой из кнопок, она будет удаляться. 
Создайте новое приложение и назовите его AddRemoveControls. Устанавливаем свойству AutoScroll формы значение True для возможности прокрутки формы. Добавляем на форму кнопку и помещаем ее в верхний левый угол формы. В поле свойства Text кнопки вводим Clone. Переходим в обработчик кнопки:
private void button1_Click(object sender, System.EventArgs e)
{
   //Создаем экземпляр btn класса Button
   Button btn = new Button();
  //Определяем количество элементов управления и находим последний
  //добавленный на форму control
   Control prev = (Control)this.Controls[this.Controls.Count-1];
   //Устанавливаем позицию добавляемых кнопок
   int x1 = prev.Location.X;
   int y1 = prev.Location.Y;
   int height = prev.Height;
   int width = prev.Width;
   btn.Location = new Point(x1+ width+5, y1 + height +5);
   btn.Width = prev.Width;
   btn.Height = prev.Height;
   //Добавляем событие для новой кнопки и обработчик button1_Click
   btn.Click+= new EventHandler(button1_Click);
   //Устанавливаем свойство Text кнопки
   btn.Text = "Clone";
   //Добавляем экземпляр в коллекцию
   this.Controls.Add(btn);
   //Определяем обработчик для события MouseUp экземпляра кнопки btn
   btn.MouseUp+= new MouseEventHandler(button1_MouseUp);
}
Переключаемся в режим дизайна формы, выделяем кнопку, в окне Properties нажимаем на кнопку событий (Events) и дважды щелкаем в поле события MouseUp:

private void button1_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
{
   if(e.Button==MouseButtons.Right)
   {
 //Удаляем данную кнопку
 this.Controls.Remove((Control)sender);
   }
}
Запускаем приложение. При щелчке правой кнопкой мыши на любой из кнопок добавляется еще одна, а при щелчке левой кнопкой мыши на заданной кнопке она исчезает. 
17.7 Работа со списками: ListBox, ComboBox, NumericUpDown.
Перед программистом часто встает задача организации списков, предназначенных для выбора строки из некоторого заранее определенного набора строк. Например, может потребоваться список файлов из текущего каталога, список названий цветов для раскраски какого-либо объекта приложения, список режимов работы приложения и т. д. Стандартные диалоговые окна, такие как Open и Save As, содержат списки файлов, каталогов и дисковых устройств. 
На панели инструментов Tools системы разработки программного обеспечения Microsoft Visual Studio .NET имеются готовые элементы управления, с помощью которых программист может легко добавить списки различных типов в свое приложение.
 
В левом верхнем углу этого окна находится список, созданный на базе класса ListBox. С его помощью Вы можете создавать одно-колоночные и многоколоночные списки, имеющие вертикальную (для одно-колоночных списков) и горизонтальную (для многоколоночных списков) полосу прокрутки. Список ListBox позволяет пользователю выбирать как один, так и несколько элементов.

Список, создаваемый на базе класса CheckedListBox, тоже допускает выбор одного или нескольких элементов. Этот список показан в правом верхнем углу рисунка. Он представляет собой комбинацию списка ListBox и флажков CheckBox, рассмотренных в предыдущем разделе этой главы.

Список класса ComboBox, показанный в левой части рисунка, является комбинацией списка и однострочного редактора текста. Поэтому для данного списка используются свойства и события, аналогичные свойствам и событиям списка ListBox и редактора текста класса TextBox.

В нижней части главного окна нашего приложения находятся элементы управления DomainUpDown и NumericUpDown. Первый из них позволяет выбирать текстовую строку из списка методом последовательного перебора, а второй — последовательно изменять значение числовой величины. Рассмотрим использование этих элементов управления подробнее.

Список класса ListBox. В процессе визуального проектирования приложения для создания списка ListBox программист перетаскивает значок этого списка, расположенный на инструментальной панели Toolbox. При этом в приложение будет добавлен следующий программный код:
this.listBox1 = new System.Windows.Forms.ListBox();
Здесь список создается как объект класса System.Windows.Forms.ListBox.
Сразу после создания список пуст. Редактируя свойство Items, можно добавить в список необходимое количество строк. При этом на программном уровне добавление строк будет выполнено при помощи метода AddRange:
this.listBox1.Items.AddRange(
new object[] 
  {
     "Каждый",
     "Охотник",
     "Желает",
     "Знать",
     "Где",
     "Сидит",
     "Фазан"
  }
);
Этот метод позволяет добавить в список сразу несколько строк. 

Свойство SelectionMode определяет режим выделения элементов списка и может принимать следующие значения:
•         SelectionMode.None;
•         SelectionMode.One;
•         SelectionMode.MultiSimple;
•         SelectionMode.MultiExtended.
Значение SelectionMode.None запрещает выделение элементов и может быть использовано, например, для динамического блокирования списка.Если присвоить свойству SelectionMode значение SelectionMode.One, пользователь сможет выделить в списке только один элемент. Значения SelectionMode.MultiSimple и SelectionMode.MultiExtended позволяют выделять в списке сразу несколько элементов. В первом из этих случаев выделение нескольких элементов выполняется мышью или клавишей пробела, а во втором дополнительно можно использовать клавишу Shift и клавиши перемещения курсора.

При помощи свойства Sorted, присвоив ему значение true, можно включить режим сортировки строк списка, отключенный по умолчанию. Свойство MultiColumn позволяет расположить строки списка в несколько столбцов.

Обычно в форме, содержащий список, имеется кнопка или другой элемент управления, с помощью которого пользователь закрывает форму и передает подготовленные с ее помощью данные вызывающей программе. Именно на этом этапе обработчик событий должен определить, какие строки были выделены пользователем в списке.

Вначале мы рассмотрим ситуацию, когда пользователю разрешается выделять из списка только один элемент. В этом случае свойству SelectionMode должно быть присвоено значение One.
В этом случае номер выделенной строки будет храниться в свойстве SelectedIndex. Самой верхней строке списка соответствует нулевое значение. Заметим, что если пользователь не выделил ни одной строки, в свойство SelectedIndex будет записано отрицательное значение.
Что же касается SelectedItem, то это свойство хранит текст строки, выделенной в списке пользователем, или пустую строку, если пользователь не выделил ни одной строки списка.
Для работы с этими свойствами создайте обработчик событий button1_Click для кнопки OK, расположенной в главном окне приложения
private void button1_Click(object sender, System.EventArgs e)
{
  string str;
  str = "Список ListBox:";

  str += "\nИндекс: " + listBox1.SelectedIndex;
  str += "\nЭлемент: " + listBox1.SelectedItem;
  MessageBox.Show(str);
}
Этот обработчик последовательно дописывает к строке str индекс выделенной строки списка и текст этой строки, а затем отображает результат в диалоговом окне MessageBox. 
 
Если пользователю разрешено выбирать из списка сразу несколько элементов, то программа может получить номера выделенных строк, анализируя свойство SelectedIndices. Это свойство представляет собой контейнер, содержащий список выделенных строк. Аналогично, текст выделенных строк можно извлечь из контейнера SelectedItems:
str += "\n";
foreach (int idx in listBox1.SelectedIndices)
{
  str += " " + idx;
}

str += "\n";
foreach (string s in listBox1.SelectedItems)
{
  str += " " + s;
}
Добавьте приведенные выше строки в тело обработчика событий button1_Click непосредственно перед вызовом метода MessageBox.Show. 
 
Заметьте, что свойства SelectedIndex и SelectedIndex при выделении нескольких строк будут содержать информацию только о первой выделенной строке.

Список класса ComboBox. Как мы уже говорили, элемент управления ComboBox представляет собой комбинацию однострочного редактора текста и списка. Когда пользователь щелкает кнопку со стрелкой, расположенную в правой части окна элемента управления ComboBox, список раскрывается, и пользователь может выбрать из него нужную строку. Если же такой строки нет, или если пользователь не желает ее искать, строку можно ввести непосредственно с клавиатуры в поле редактирования.
После создания программа добавляет в список новые строки с помощью метода AddRange:
this.comboBox1 = new System.Windows.Forms.ComboBox();
…
this.comboBox1.Items.AddRange(
  new object[] 
  {
     "Каждый",
     "Охотник",
     "Желает",
     "Знать",
     "Где",
     "Сидит",
     "Фазан"
  }
);
С помощью свойства Sorted можно отсортировать элементы списка по алфавиту, для чего нужно присвоить этому свойству значение true. Чтобы получить строку, выбранную пользователем из списка или введенную в поле редактирования элемента управления ComboBox, необходимо обратиться к свойству Text:
str += "\n\nСписок ComboBox: " + comboBox1.Text;

Элемент управления NumericUpDown. Хотя, строго говоря, элемент управления NumericUpDown и не является списком в обычном понимании этого слова, он позволяет изменять цифровые значения, «прокручивая» их в окне при помощи кнопок со стрелками.
Вот как программа создает элемент управления NumericUpDown:
this.numericUpDown1 = new System.Windows.Forms.NumericUpDown();
Вы можете выполнить дополнительные настройки, отредактировав соответствующие свойства.
Прежде всего, при помощи свойства Hexadecimal можно переключить элемент управления NumericUpDown в режим ввода шестнадцатеричных чисел, если приравнять этому свойству значение true.

Свойство DecimalPlaces задает количество цифр после десятичной точки. Присвоив значению ThousandsSeparator значение true, можно включить режим выделения разрядов тысяч.

Величина инкремента и декремента задается свойством Increment, а минимальное и максимальное значения — при помощи свойств Minimum и Maximum, соответственно.

Для того чтобы получить текущее значение, установленное пользователем в окне элемента управления NumericUpDown, воспользуйтесь свойством Value:
str += "\nСписок NumericUpDown: " + numericUpDown1.Value; 

17.8 Работа с переключателями: RadioButton, CheckBox
Переключатели с зависимой фиксацией (RadioButton). Такие флажки объединяются в группы, причем в отмеченном состоянии может находиться лишь один флажок из группы. Флажки с зависимой фиксацией создаются на базе класса System.Windows.Forms.RadioButton. 
 
В левой части этого окна находятся флажки, предназначенные для изменения цвета фона надписи «Выберите цвет фона и текста», а в правой — для изменения цвета этой надписи. Создавая форму главного окна для этого приложения, были іспользованы элементы управления GroupBox и Panel. Элемент управления GroupBox используется для объединения флажков, задающих цвет фона, а элемент управления Panel — цвет текста.
Элемент управления GroupBox снабжается рамкой с надписью, объясняющей назначение объединяемых внутри рамки элементов управления. Что же касается панели Panel, то она представляет собой прямоугольное окно без надписи, внутри которого можно помещать произвольные объекты. Эта панель может иметь полосы прокрутки.

Как наши флажки привязываются к панелям GroupBox и Panel?
Рассмотрим фрагменты кода приложения RadioButtonApp, отвечающие за создание флажков, задающих цвет фона, а также за создание объединяющего их элемента управления GroupBox.

На этапе инициализации приложения создается сам элемент управления GroupBox (как объект класса System.Windows.Forms.GroupBox), и флажки с зависимой фиксацией:
this.groupBox1 = new System.Windows.Forms.GroupBox();
this.radioButtonBkgRed = new System.Windows.Forms.RadioButton();
this.radioButtonBkgGreen = new System.Windows.Forms.RadioButton();
this.radioButtonBkgBlue = new System.Windows.Forms.RadioButton();
this.radioButtonBkgWhite = new System.Windows.Forms.RadioButton();
Далее флажки добавляются в элемент управления GroupBox при помощи метода AddRange:
// 
// groupBox1
// 
this.groupBox1.Controls.AddRange(
  new System.Windows.Forms.Control[]
  {
     this.radioButtonBkgWhite,
     this.radioButtonBkgBlue,
     this.radioButtonBkgGreen,
     this.radioButtonBkgRed
  });
Аналогичным образом создается панель panel1 класса Panel, надпись и флажки, расположенные внутри панели:
this.panel1 = new System.Windows.Forms.Panel();
this.label1 = new System.Windows.Forms.Label();
this.radioButtonForeRed = new System.Windows.Forms.RadioButton();
this.radioButtonForeGreen = new System.Windows.Forms.RadioButton();
this.radioButtonForeBlue = new System.Windows.Forms.RadioButton();
this.radioButtonForeBlack = new System.Windows.Forms.RadioButton();
Все объекты, расположенные внутри правой панели, добавляются в нее все тем же методом AddRange:
// 
// panel1
// 
this.panel1.Controls.AddRange(
  new System.Windows.Forms.Control[] 
  {
     this.radioButtonForeBlack,
     this.radioButtonForeBlue,
     this.radioButtonForeGreen,
     this.radioButtonForeRed,
     this.label1
  });
this.panel1.Location = new System.Drawing.Point(192, 8);
this.panel1.Name = "panel1";
this.panel1.Size = new System.Drawing.Size(152, 144);
this.panel1.TabIndex = 1;
Для каждой группы флажков мы создаем свой собственный обработчик события CheckedChanged. Это событие возникает, когда пользователь изменяет состояние флажка, устанавливая или снимая отметку.
Чтобы создать обработчик событий bkgChanged для группы флажков, отвечающих за изменение цвета фона нашей надписи, выделите любой флажок в группе Укажите цвет фона. Затем в окне Properties откройте вкладку событий, введите в поле CheckedChanged строку bkgChanged и нажмите клавишу Enter. В результате будет создано тело обработчика событий bkgChanged.
 
Далее выделите по очереди все остальные флажки группы Укажите цвет фона, и назначьте для них обработчик событий bkgChanged при помощи только что упомянутого окна Properties. Таким образом, изменение состояния всех флажков группы будет отслеживаться единым обработчиком событий bkgChanged.
Далее повторите эту операцию для второй группы флажков. Назначьте для них обработчик событий foreChanged.
Ниже мы привели модифицированные исходные тексты обработчиков событий bkgChanged и foreChanged:
private void bkgChanged(object sender, System.EventArgs e)
{
  RadioButton rb = (RadioButton)sender;
  switch(rb.Text)
  {
     case "Красный":
     {
       label2.BackColor = Color.LightCoral;
       break;
     }
     case "Зеленый":
     {
       label2.BackColor = Color.LightGreen;
       break;
    }
     case "Синий":
     {
       label2.BackColor = Color.LightBlue;
       break;
     }
     case "Белый":
     {
       label2.BackColor = Color.White;
       break;
     }
  }
}

private void foreChanged(object sender, System.EventArgs e)
{
  RadioButton rb = (RadioButton)sender;
     
  switch(rb.Text)
  {
     case "Красный":
     {
       label2.ForeColor = Color.Red;
       break;
     }
     case "Зеленый":
     {
       label2.ForeColor = Color.Green;
       break;
     }
     case "Синий":
     {
       label2.ForeColor = Color.Blue;
       break;
     }
     case "Белый":
     {
       label2.ForeColor = Color.White;
       break;
     }
  }
}
Эти обработчики событий работают по одинаковому алгоритму. Вначале они сохраняют в переменной rb идентификатор флажка, состояние которого было изменено. Затем обработчики извлекают текст надписи, расположенной возле флажка. В зависимости от этого текста, обработчики изменяют цвет фона или текста надписи label2, расположенной в нижней части главного окна нашего приложения.

Переключатели с независимой фиксацией (CheckBox). Флажки с независимой фиксацией работают независимо друг от друга. При этом не имеет никакого значения, расположены они внутри панелей GroupBox и Panel, или непосредственно в окне приложения. Эти флажки создаются на базе класса System.Windows.Forms.CheckBox.
Как правило, флажки с независимой фиксацией используется в программе, для того чтобы задавать какие-либо режимы, которые можно устанавливать независимо друг от друга. 
Такие флажки могут находиться во включенном или выключенном состоянии, а также в третьем, неопределенном состоянии.
Состав свойств флажков с независимой фиксацией, создаваемых на базе класса CheckBox, аналогичен составу свойств флажков с зависимой фиксацией RadioButton. Однако есть и отличия. Свойство Appearance определяет внешний вид флажка. По умолчанию значение этого свойства равно Normal, в результате чего флажок выглядит обычным образом. Если же установить значение этого свойства, равным Button, флажок будет похож на обычную кнопку. В отмеченном состоянии флажок будет нарисован как нажатая кнопка, а в неотмеченном — как отжатая кнопка.
Очень интересное свойство называется ThreeState. Если это свойство имеет значение true, то флажок сможет принимать не два, а три состояния:
•         включен;
•         выключен;
•         неопределенное состояние. 
Флажок последовательно проходит эти состояния, когда пользователь щелкает его мышью. Состояние флажка можно изменять и программным способом. Для этого нужно изменить значение свойства CheckState. 
Если флажок может находиться только в двух состояниях (свойство ThreeState равно false), то это свойство может принимать значения CheckState.Checked (флажок установлен) и CheckState.Unchecked (флажок не установлен). 
В том случае, когда значение свойства ThreeState равно true и флажок может принимать три состояния, свойство CheckState может иметь значение CheckState.Indeterminate (неопределенное состояние).
Флажки с независимой фиксацией работают самостоятельно, поэтому для каждого из них обычно предусматривают собственные обработчики событий. Но чаще всего состояние флажков определяется при работе обработчиков событий других элементов управления, таких, например, как кнопки.

Лекция 18. Графика в windows-приложениях
18.1 Рисование в форме
Графика необходима при организации пользовательского интерфейса. Образы информативнее текста. Framework .Net реализует расширенный графический интерфейс GDI+, обладающий широким набором возможностей. Но для рисования в формах достаточно иметь три объекта - перо, кисть и, хочется сказать, бумагу, но третий нужный объект - это объект класса Graphics, методы которого позволяют в формах заниматься графикой - рисовать и раскрашивать.
Класс Graphics - это основной класс, необходимый для рисования. Класс Graphics, так же, как и другие рассматриваемые здесь классы для перьев и кистей, находятся в пространстве имен Drawing, хотя классы некоторых кистей вложены в подпространство Drawing2D.
Объекты этого класса зависят от контекста устройства, (графика не обязательно отображается на дисплее компьютера, она может выводиться на принтер, графопостроитель или другие устройства), поэтому создание объектов класса Graphics выполняется не традиционным способом - без вызова конструктора класса. Создаются объекты специальными методами разных классов. Например, метод CreateGraphics класса Control - наследника класса Form - возвращает объект, ассоциированный с выводом графики на форму.
При рисовании в формах можно объявить в форме поле, описывающее объект класса Graphics:
Graphics graph;
а в конструкторе формы произвести связывание с реальным объектом:
graph = CreateGraphics();
Затем всюду в программе, где нужно работать с графикой, используется глобальный для формы объект graph и его методы. Есть другой способ получения этого объекта - обработчики некоторых событий получают объект класса Graphics среди передаваемых им аргументов. Например, в обработчике события Paint, занимающегося перерисовкой, этот объект можно получить так:
protected override void OnPaint(System.Windows.Forms.PaintEventArgs e)
{
   Graphics gr = e.Graphics;
   //перерисовка, использующая методы объекта gr
}
Для получения этого объекта можно использовать и статические методы самого класса Graphics.
У класса Graphics большое число методов и свойств. Для рисования наиболее важны три группы методов. К первой относится перегруженный метод DrawString, позволяющий выводить тексты в графическом режиме. Вторую группу составляют методы Draw - DrawEllipse, DrawLine, DrawArc и другие, позволяющие цветным пером (объектом класса Pen) рисовать геометрические фигуры: линии, различные кривые, прямоугольники, многоугольники, эллипсы и прочее. К третьей группе относятся методы Fill - FillEllipse, FillPie, FillRectangle и другие, позволяющие нарисовать и закрасить фигуру кистью. Кисти (объекты классов, производных от Brush), могут быть разные - сплошные, узорные, градиентные.
Методам группы Draw класса Graphics, рисующим контур фигуры, нужно передать перо - объект класса Pen. В конструкторе этого класса можно задать цвет пера и его толщину (чаще говорят "ширину пера"). Цвет задается объектом класса (структурой) Color. Для выбора подходящего цвета можно использовать упоминавшееся выше диалоговое окно Color либо одно из многочисленных статических свойств класса Color, возвращающее требуемый цвет. Возможно и непосредственное задание элементов структуры в виде комбинации RGB - трех цветов - красного, зеленого и голубого. Вместо создания нового пера с помощью конструктора можно использовать специальный класс предопределенных системных перьев.
Класс Brush, задающий кисти, устроен более сложно. Класс Brush является абстрактным классом, так что создавать кисти этого класса нельзя, но можно создавать кисти классов-потомков Brush. Таких классов пять - они задают кисть:
•	SolidBrush - для сплошной закраски области заданным цветом; 
•	TextureBrush - для закраски области заданной картинкой (image); 
•	HatchBrush - для закраски области предопределенным узором; 
•	LinearGradientBrush - для сплошной закраски с переходом от одного цвета к другому, где изменение оттенков задается линейным градиентом; 
•	PathGradientBrush - для сплошной закраски с переходом от одного цвета к другому, где изменение оттенков задается более сложным путем.
Первые два класса кистей находятся в пространстве имен System.Drawing, остальные - в System.Drawing.Drawing2D.
 
Создадим в нашем проекте новую форму RandomShapes, в которой будем рисовать и закрашивать геометрические фигуры трех разных типов - эллипсы, сектора, прямоугольники. Для каждого типа фигуры будем использовать свой тип кисти: эллипсы будем закрашивать градиентной кистью, сектора - сплошной, а прямоугольники - узорной. Цвет фигуры, ее размеры и положение будем выбирать случайным образом. Рисование фигур будет инициироваться в обработчике события Click. При каждом щелчке кнопкой мыши на форме будут рисоваться три новых экземпляра фигур каждого типа. 
Приведем программный код, реализующий рисование. Начнем, как обычно, с полей класса:
//fields
   int cx,cy;
   Graphics graph;
   Brush brush;
   Color color;
   Random rnd;
Инициализация полей производится в методе MyInit, вызываемом конструктором класса:
void MyInit()
   {
      cx = ClientSize.Width;
      cy = ClientSize.Height;
      graph = CreateGraphics();
      rnd = new Random();
   }
Рассмотрим теперь основной метод, реализующий рисование фигур различными кистями:
void DrawShapes()
   {
      for(int i=0; i<3; i++)
      {
         //выбирается цвет - красный, желтый, голубой
         int numcolor = rnd.Next(3);
         switch (numcolor)
         {
            case 0:
               color = Color.Blue; break;
            case 1:
               color = Color.Yellow; break;
            case 2:
               color = Color.Red; break;
         }
         //градиентной кистью рисуется эллипс,
         //местоположение случайно
         Point top = new Point(rnd.Next(cx), rnd.Next(cy));
         Size sz = new Size(rnd.Next(cx-top.X), rnd.Next(cy-top.Y));
         Rectangle rct = new Rectangle(top, sz);
         Point bottom = top + sz;
         brush = new LinearGradientBrush(top, bottom, 
            Color.White,color);
         graph.FillEllipse(brush,rct);
         //сплошной кистью рисуется сектор,
         //местоположение случайно
         top = new Point(rnd.Next(cx), rnd.Next(cy));
         sz = new Size(rnd.Next(cx-top.X), rnd.Next(cy-top.Y));
         rct = new Rectangle(top, sz);
         brush = new SolidBrush(color);
         graph.FillPie(brush,rct,30f,60f);
         //узорной кистью рисуется прямоугольник,
         //местоположение случайно
         top = new Point(rnd.Next(cx), rnd.Next(cy));
         sz = new Size(rnd.Next(cx-top.X), rnd.Next(cy-top.Y));
         rct = new Rectangle(top, sz);
         HatchStyle hs = (HatchStyle)rnd.Next(52);
         brush = new HatchBrush(hs,Color.White, Color.Black);
         graph.FillRectangle(brush,rct);
      }
   }
Здесь многое построено на работе со случайными числами. Случайным образом выбирается один из возможных цветов для рисования фигуры, ее размеры и положение. Наиболее интересно рассмотреть создание кистей разного типа. Когда создается градиентная кисть.
brush = new LinearGradientBrush(top, bottom, Color.White,color);
то нужно в конструкторе кисти задать две точки и два цвета. Точки определяют интервал изменения оттенков цвета от первого до второго. В начальной точке имеет место первый цвет, в конечной - второй, в остальных точках - их комбинация. Разумно, как это сделано у нас, в качестве точек выбирать противоположные углы прямоугольника, ограничивающего рисуемую фигуру.
Наиболее просто задается сплошная кисть:
brush = new SolidBrush(color);
Для нее достаточно указать только цвет. Для узорной кисти нужно задать предопределенный тип узора, всего их возможно 52. В нашем примере тип узора выбирается случайным образом:
HatchStyle hs = (HatchStyle)rnd.Next(52);
brush = new HatchBrush(hs,Color.White, Color.Black);
Помимо первого аргумента, задающего тип узора, указываются еще два цвета - первый определяет цвет повторяющегося элемента, второй - цвет границы между элементами узора.
Непосредственное рисование кистью осуществляют методы группы Fill:
graph.FillEllipse(brush,rct);
graph.FillPie(brush,rct,30f,60f);
graph.FillRectangle(brush,rct);
Первый аргумент всегда задает кисть, а остальные зависят от типа рисуемой фигуры. Как правило, всегда задается прямоугольник, ограничивающий данную фигуру.
Вызов метода DrawShapes, как уже говорилось, встроен в обработчик события Click формы RandomShapes:
private void RandomShapes_Click(object sender, System.EventArgs e)
{
   DrawShapes();
}
18.2 Работа с изображениями

